Sjasm Z80 Assembler v0.42c - www.xl2s.tk             [2024.09.10 - 10:28:54]

ESP8266_memio.asm
Errors: 0

       1   00:4000                      ; ESP8266 TCP/IP UNAPI BIOS v.1.3
       2   00:4000                      ; MSX PICO UART version
       3   00:4000                      ; Oduvaldo Pavan Junior
       4   00:4000                      ; ducasp@gmail.com
       5   00:4000                      ;    This code implements TCP/IP UNAPI Specification for MSX-SM
       6   00:4000                      ;
       7   00:4000                      ; Pieces of this code were based on DENYOTCP.ASM (Denyonet ROM)
       8   00:4000                      ; made by Konamiman
       9   00:4000                      ;
      10   00:4000                      ; This code also has contributions from KdL, most specifically in the Wi-Fi
      11   00:4000                      ; setup menus and functionality, he has helped quite a lot to get it to the
      12   00:4000                      ; final format and functionality, thanks!
      13   00:4000                      ;
      14   00:4000                      ; The MSX PICO version of this code has contribution from Jeroen Taverne That
      15   00:4000                      ; helped making some MACROs on the fixed / non speed optimized loop I/O parts
      16   00:4000                      ; of the code so we can easily switch this from I/O based to Memory Based.
      17   00:4000                      ;
      18   00:4000                      ; Note: this implementation depends upon ESP8266 having the UNAPI
      19   00:4000                      ; firmware flashed. This firmware has been developed by me as well.
      20   00:4000                      ;
      21   00:4000                      ; Usage is free as long as you publish your code changes. If you make a profit
      22   00:4000                      ; selling something using this code, a suggestion is that you donate one or two
      23   00:4000                      ; pieces of the hardware to the MSX DEV contest to be awarded to MSX DEV winners
      24   00:4000                      ; as this shouldn't cost much and perhaps will bring interest on developers to
      25   00:4000                      ; make games that support internet :)
      26   00:4000                      ;
      27   00:4000                      ; Design details:
      28   00:4000                      ; There are five instances of this ROM
      29   00:4000                      ;
      30   00:4000                      ; 1 - If configured as disabled in set-up menu item 4, or through setting F2
      31   00:4000                      ;     device to EF or keeping DEL pressed during boot, it won't load at all.
      32   00:4000                      ; 2 - F1 is pressed during boot, or through setting F2 device to F1, it will
      33   00:4000                      ;     show a setup menu, ESC resume boot.
      34   00:4000                      ; 3 - F2 is pressed during a soft reset, or trhough setting F2 device to F2 it
      35   00:4000                      ;     will force re-set of the ESP and re-connection to the AP.
      36   00:4000                      ; 4 - No key is pressed during a warm boot and F2 device is set to F0, UNAPI 
      37   00:4000                      ;     is enabled (default), EXTBIO HOOK for UNAPI calls is installed and HTIM_I
      38   00:4000                      ;     hook for internal usage and a few bytes at top of TPA are reserved upon
      39   00:4000                      ;     the first UNAPI function being called. No ESP reset or tries to set-up the
      40   00:4000                      ;     the RTC are done, so it is a quick warm-boot.
      41   00:4000                      ; 5 - No key is pressed during a cold boot or F2 is set to FE or any unknown
      42   00:4000                      ;     value, UNAPI is enabled (default), EXTBIO HOOK for UNAPI calls is installed
      43   00:4000                      ;     and HTIM_I hook for internal usage and a few bytes at top of TPA are reserved
      44   00:4000                      ;     upon the first UNAPI function being called. ESP is reset and if BIOS is set
      45   00:4000                      ;     up to do so, SNTP connection attempt is made and RTC is updated
      46   00:4000                      ;
      47   00:4000                      ; As a ROM, our segment is read only, so for RAM needs we need to use RAM not
      48   00:4000                      ; in our page. This ROM will do the following:
      49   00:4000                      ;
      50   00:4000                      ; If running the SETUP menu, we are going to "borrow" BASIC program area, that
      51   00:4000                      ; is saved at TXTTAB. We can't allocate memory at this point as any possible
      52   00:4000                      ; disk rom might be sitting on a slot that has not been initialized and results
      53   00:4000                      ; could be bad. The BASIC program area trick should be safe, unless some other
      54   00:4000                      ; cartridge runs a BASIC software for something (i.e.: wait disks be initialized
      55   00:4000                      ; ), in such case, that BASIC software or trick will most likely be corrupted
      56   00:4000                      ; after running our setup.
      57   00:4000                      ;
      58   00:4000                      ; After boot, we need RAM in the 4th page. We have the SLOT WORK AREA for free,
      59   00:4000                      ; it is 8 bytes reserved for our slot, and that is certainly not enough, just
      60   00:4000                      ; the EXTBIOS HOOK backup cost us 5 bytes, so we have three bytes remaining. Of
      61   00:4000                      ; those, we use two to indicate the bottom of the memory reserved in the 4th
      62   00:4000                      ; page. Whenever more memory is needed, HIMEM_RESERVED_SIZE must change, just
      63   00:4000                      ; remember that more memory reserved means less memory available to
      64   00:4000                      ; applications and BASIC, so use it wisely.
      65   00:4000                      ;
      66   00:4000                      ; Slot Work Area Details
      67   00:4000                      ; 0000 - 0004   : EXTBIO hook backup
      68   00:4000                      ; 0005 - 0006   : HIMEM Allocated area (starts with 00 xx, once allocated goes
      69   00:4000                      ;                 to Fxxx or Exxx so checking 0005 if 00 is enough)
      70   00:4000                      ; 007           : Unused
      71   00:4000                      ;
      72   00:4000                      ; Current HIMEM mapping offset related to the address stored in the 6th and 7th
      73   00:4000                      ; bytes of our slot work area:
      74   00:4000                      ;
      75   00:4000                      ; 0000 - 0004   : HTIM_I hook backup
      76   00:4000                      ; 0005 - 0006   : Counter that our HTIM_I hook updates
      77   00:4000                      ; 0007          : Store Single Byte some functions need
      78   00:4000                      ; 0008          : Stores whether DNS is ready or not
      79   00:4000                      ; 0009 - 000A   : Stores last DNS result
      80   00:4000                      ; 000B - 000C   : Stores a 16 bits value
      81   00:4000                      ; 000D - 0012   : Store a backup of BC / DE / HL
      82   00:4000                      ;   000D - 000E : C and B
      83   00:4000                      ;   000F - 0010 : D and E
      84   00:4000                      ;   0011 - 0012 : H and L
      85   00:4000                      ; 0013 - 001D   : Unused
      86   00:4000                      ;
      87   00:4000                      ; As this is sitting on a slot, there is a resoanable chance that this is initialized
      88   00:4000                      ; before any disk controllers. If that is the case, allocating memory at HIMEM is bad
      89   00:4000                      ; and might have two bad behaviors:
      90   00:4000                      ;
      91   00:4000                      ; 1 - Disk Controller is smart enough to determine HIMEM was moved and simply do not
      92   00:4000                      ; initialize. No disk available...
      93   00:4000                      ; 2 - Disk Controller doesn't care and simply wipe-out memory below original HIMEM at
      94   00:4000                      ; boot to create the disk interfaces static work area, thus, causing our allocated
      95   00:4000                      ; memory to be overwritten and MSX will most likely crash on ther first VDP interrupt
      96   00:4000                      ; after that...
      97   00:4000                      ;
      98   00:4000                      ; So, allocating memory at cartridge startup will make MSX freeze or misbehave or not
      99   00:4000                      ; have the disk available if our ROM is sitting in a slot lower than the disk. There
     100   00:4000                      ; are a few possibilities:
     101   00:4000                      ;
     102   00:4000                      ; 1 - Hook to H_STKE, it is called once all slots have been initialized... But, using
     103   00:4000                      ; this hook will make ESE SCSI to not work and halt with a "No enough memory" message,
     104   00:4000                      ; so I do not consider it a good option as the intention is to re-use code for other
     105   00:4000                      ; adapters.
     106   00:4000                      ; 2 - On any UNAPI call check the slot work area if the allocated area is other than 00
     107   00:4000                      ; and if it is, execute, otherwise, first execute our allocation routine. This has an
     108   00:4000                      ; overhead of a dozen instructions at every UNAPI function we execute, does not seem to
     109   00:4000                      ; impact performance compared to the UNAPI RAM driver that doesn't has it
     110   00:4000                      ; 3 - Try to go crazy and check for dos roms on slots above us, initialize those first
     111   00:4000                      ; if found... Too much trouble for a dozen instructions.
     112   00:4000                      ;
     113   00:4000                      ; So, for the moment the design decision is option #2
     114   00:4000                      ;
     115   00:4000                      ; F2 Device by KdL
     116   00:4000                      ; That device, present on recent OCM implementations, allow a byte to be saved and
     117   00:4000                      ; read from IO address F2. It has FF on start-up, and KdL devised the following
     118   00:4000                      ; values/states:
     119   00:4000                      ;
     120   00:4000                      ; FF - Default, meaning cold boot
     121   00:4000                      ; FE - Set this when an unexpected error occurred
     122   00:4000                      ; F2 - Equivalent to keeping F2 pressed at boot time, force the next warm boot
     123   00:4000                      ;      to try to detect the ESP8266
     124   00:4000                      ; F1 - Will force the Wi-Fi setup at next warm boot, so it is not needed to
     125   00:4000                      ;      keep F1 pressed
     126   00:4000                      ; F0 - Means that RTC has date and time, so the next warm boot doesn't check
     127   00:4000                      ;      for F1/F2 or try to update RTC, being faster
     128   00:4000                      ; EF - Set when ESP8266 was not found or by user at runtime to disable UNAPI
     129   00:4000                      ;      next warm boot
     130   00:4000                      ;
     131   00:4000                      ; MSX Pico also implements the F2 device
     132   00:4000                      
     133   00:4000                      ;*************************
     134   00:4000                      ;***  BUILD DEFINITIONS **
     135   00:4000                      ;*************************
     136   00:4000                      
     137   00:4000                      ;--- verbose rom...?
     138   00:4000  (00:0000)           NON_VERBOSE_ROM:        equ 0
     139   00:4000                      ;--- Use memory mapped IO or not...
     140   00:4000  (00:0001)           USE_MEM_IO:             equ 1
     141   00:4000                      
     142   00:4000                      ;*******************
     143   00:4000                      ;***  CONSTANTS  ***
     144   00:4000                      ;*******************
     145   00:4000                      
     146   00:4000                      ;--- System variables and routines:
     147   00:4000  (00:005F)           CHGMOD:                 equ #005F
     148   00:4000  (00:009C)           CHSNS:                  equ #009C
     149   00:4000  (00:009F)           CHGET:                  equ #009F
     150   00:4000  (00:00A2)           CHPUT:                  equ #00A2
     151   00:4000  (00:00C0)           BEEP:                   equ #00C0
     152   00:4000  (00:0141)           SNSMAT:                 equ #0141
     153   00:4000  (00:0156)           KILBUF:                 equ #0156
     154   00:4000  (00:F3B0)           LINLEN:                 equ #F3B0
     155   00:4000  (00:F3DB)           CLIKSW:                 equ #F3DB
     156   00:4000  (00:F3E1)           REG2SAV:                equ #F3E1
     157   00:4000  (00:F3E3)           REG4SAV:                equ #F3E3
     158   00:4000  (00:F676)           TXTTAB:                 equ #F676
     159   00:4000  (00:F847)           ARG:                    equ #F847
     160   00:4000  (00:FB20)           HOKVLD:                 equ #FB20
     161   00:4000  (00:FC4A)           HIMEM:                  equ #FC4A
     162   00:4000  (00:FCA9)           CSRSW:                  equ #FCA9
     163   00:4000  (00:FCC1)           EXPTBL:                 equ #FCC1
     164   00:4000  (00:FD09)           SLTWRK:                 equ #FD09
     165   00:4000  (00:FD9F)           H_TIMI:                 equ #FD9F
     166   00:4000  (00:FED0)           H_CLEA:                 equ #FED0
     167   00:4000  (00:FFCA)           EXTBIO:                 equ #FFCA
     168   00:4000                      
     169   00:4000                      
     170   00:4000                      ;--- Memory ports:
     171   00:4000  (00:7F06)           MEM_OUT_CMD_PORT:       equ #7F06
     172   00:4000  (00:7F07)           MEM_OUT_TX_PORT:        equ #7F07
     173   00:4000  (00:7F06)           MEM_IN_DATA_PORT:       equ #7F06
     174   00:4000  (00:7F07)           MEM_IN_STS_PORT:        equ #7F07
     175   00:4000  (00:7F05)           MEM_PORT_F2:            equ #7F05
     176   00:4000                      
     177   00:4000                      ;--- I/O ports:
     178   00:4000  (00:0006)           OUT_CMD_PORT:           equ #06
     179   00:4000  (00:0007)           OUT_TX_PORT:            equ #07
     180   00:4000  (00:0006)           IN_DATA_PORT:           equ #06
     181   00:4000  (00:0007)           IN_STS_PORT:            equ #07
     182   00:4000  (00:00F2)           PORT_F2:                equ #F2
     183   00:4000                      
     184   00:4000                      
     185   00:4000                          if USE_MEM_IO = 1
     186   00:4000                        MACRO SET_SPEED
     187   00:4000                    <     xor a
     188   00:4000                    <     ld  (MEM_OUT_CMD_PORT),a            ; Clear UART
     189   00:4000                    <   ENDM
     190   00:4000                      
     191   00:4000                        MACRO CLEAR_UART
     192   00:4000                    <     ld  a,20
     193   00:4000                    <     ld  (MEM_OUT_CMD_PORT),a            ; Clear UART
     194   00:4000                    <   ENDM
     195   00:4000                      
     196   00:4000                        MACRO SEND_DATA
     197   00:4000                    <     ld  (MEM_OUT_TX_PORT),a             ; Just send, no need to wait response
     198   00:4000                    <   ENDM
     199   00:4000                      
     200   00:4000                        MACRO RECEIVE_DATA
     201   00:4000                    <     ld a,(MEM_IN_DATA_PORT)
     202   00:4000                    <   ENDM
     203   00:4000                      
     204   00:4000                        MACRO LOAD_STS_PORT_IN_A
     205   00:4000                    <     ld  a,(MEM_IN_STS_PORT)
     206   00:4000                    <   ENDM
     207   00:4000                      
     208   00:4000                        MACRO CHECK_DATA
     209   00:4000                    <     ld  a,(MEM_IN_STS_PORT)
     210   00:4000                    <     bit 0,a                         ; If nz has data
     211   00:4000                    <   ENDM
     212   00:4000                      
     213   00:4000                        MACRO CHECK_QUICK_RECEIVE
     214   00:4000                    <     ld  a,(MEM_IN_STS_PORT)
     215   00:4000                    <     bit 3,a                         ; Quick Receive Supported?
     216   00:4000                    <   ENDM
     217   00:4000                      
     218   00:4000                        MACRO CHECK_BUFFER_UNDERRUN
     219   00:4000                    <     ld  a,(MEM_IN_STS_PORT)
     220   00:4000                    <     bit 4,a                         ; Buffer underrun?
     221   00:4000                    <   ENDM
     222   00:4000                      
     223   00:4000                        MACRO READ_F2
     224   00:4000                    <     ld  a,(MEM_PORT_F2)
     225   00:4000                    <   ENDM
     226   00:4000                      
     227   00:4000                        MACRO WRITE_F2
     228   00:4000                    <     ld  (MEM_PORT_F2),a
     229   00:4000                    <   ENDM
     230   00:4000                          else
     231   00:4000                    ~ 
     232   00:4000                    ~   MACRO SET_SPEED
     233   00:4000                    ~     xor a
     234   00:4000                    ~     out (OUT_CMD_PORT),a            ; Clear UART
     235   00:4000                    ~   ENDM
     236   00:4000                    ~ 
     237   00:4000                    ~   MACRO CLEAR_UART
     238   00:4000                    ~     ld  a,20
     239   00:4000                    ~     out (OUT_CMD_PORT),a            ; Clear UART
     240   00:4000                    ~   ENDM
     241   00:4000                    ~ 
     242   00:4000                    ~   MACRO SEND_DATA
     243   00:4000                    ~     out (OUT_TX_PORT),a             ; Just send, no need to wait response
     244   00:4000                    ~   ENDM
     245   00:4000                    ~ 
     246   00:4000                    ~   MACRO RECEIVE_DATA
     247   00:4000                    ~     in a,(IN_DATA_PORT)
     248   00:4000                    ~   ENDM
     249   00:4000                    ~ 
     250   00:4000                    ~   MACRO LOAD_STS_PORT_IN_A
     251   00:4000                    ~     in  a,(IN_STS_PORT)
     252   00:4000                    ~   ENDM
     253   00:4000                    ~ 
     254   00:4000                    ~   MACRO CHECK_DATA
     255   00:4000                    ~     in  a,(IN_STS_PORT)
     256   00:4000                    ~     bit 0,a                         ; If nz has data
     257   00:4000                    ~   ENDM
     258   00:4000                    ~ 
     259   00:4000                    ~   MACRO CHECK_QUICK_RECEIVE
     260   00:4000                    ~     ld  a,(IN_STS_PORT)
     261   00:4000                    ~     bit 3,a                         ; Quick Receive Supported?
     262   00:4000                    ~   ENDM
     263   00:4000                    ~ 
     264   00:4000                    ~   MACRO CHECK_BUFFER_UNDERRUN
     265   00:4000                    ~     in  a,(IN_STS_PORT)
     266   00:4000                    ~     bit 4,a                         ; Buffer underrun?
     267   00:4000                    ~   ENDM
     268   00:4000                    ~ 
     269   00:4000                    ~   MACRO READ_F2
     270   00:4000                    ~     in  a,(PORT_F2)
     271   00:4000                    ~   ENDM
     272   00:4000                    ~ 
     273   00:4000                    ~   MACRO WRITE_F2
     274   00:4000                    ~     out (PORT_F2),a
     275   00:4000                    ~   ENDM
     276   00:4000                    ~     endif
     277   00:4000                      
     278   00:4000                      ;--- API version and implementation version:
     279   00:4000  (00:0001)           API_V_P:                equ 1
     280   00:4000  (00:0002)           API_V_S:                equ 2
     281   00:4000  (00:0001)           ROM_V_P:                equ 1
     282   00:4000  (00:0003)           ROM_V_S:                equ 3
     283   00:4000                      
     284   00:4000                      ;--- Size of memory to reserve in upper TPA:
     285   00:4000  (00:001E)           HIMEM_RESERVED_SIZE     equ 30
     286   00:4000                      
     287   00:4000                      ;--- Layout of our TPA area:
     288   00:4000  (00:0000)           H_TIM_BACKUP_OFFSET     equ 0
     289   00:4000  (00:0005)           MEMORY_COUNTER_OFFSET   equ 5
     290   00:4000  (00:0007)           MEMORY_SB_VAR_OFFSET    equ 7
     291   00:4000  (00:0008)           MEMORY_DNS_READY_OFFSET equ 8
     292   00:4000  (00:0009)           MEMORY_DNS_RES_OFFSET   equ 9
     293   00:4000  (00:000B)           MEMORY_DB_VAR_OFFSET    equ #0B
     294   00:4000  (00:000D)           MEMORY_REGBACKUP_OFFSET equ #0D
     295   00:4000  (00:000D)           MEMORY_BCBACKUP_OFFSET  equ #0D
     296   00:4000  (00:000F)           MEMORY_DEBACKUP_OFFSET  equ #0F
     297   00:4000  (00:0011)           MEMORY_HLBACKUP_OFFSET  equ #11
     298   00:4000                      
     299   00:4000                      ;--- Scan Page Size
     300   00:4000  (00:0008)           SCAN_MAX_PAGE_SIZE      equ 8
     301   00:4000                      
     302   00:4000                      ;--- Maximum number of available standard and implementation-specific function
     303   00:4000                      ;--- numbers. Must be 0 to 127.
     304   00:4000  (00:001D)           MAX_FN:                 equ 29
     305   00:4000                      
     306   00:4000                      ;--- Must be either zero (if no implementation-specific functions available),
     307   00:4000                      ;--- or 128 to 254.
     308   00:4000  (00:0000)           MAX_IMPFN:              equ 0
     309   00:4000                      
     310   00:4000                      ;--- TCP/IP UNAPI error codes:
     311   00:4000  (00:0000)           ERR_OK:                 equ 0
     312   00:4000  (00:0001)           ERR_NOT_IMP:            equ 1
     313   00:4000  (00:0002)           ERR_NO_NETWORK:         equ 2
     314   00:4000  (00:0003)           ERR_NO_DATA:            equ 3
     315   00:4000  (00:0004)           ERR_INV_PARAM:          equ 4
     316   00:4000  (00:0005)           ERR_QUERY_EXISTS:       equ 5
     317   00:4000  (00:0006)           ERR_INV_IP:             equ 6
     318   00:4000  (00:0007)           ERR_NO_DNS:             equ 7
     319   00:4000  (00:0008)           ERR_DNS:                equ 8
     320   00:4000  (00:0009)           ERR_NO_FREE_CONN:       equ 9
     321   00:4000  (00:000A)           ERR_CONN_EXISTS:        equ 10
     322   00:4000  (00:000B)           ERR_NO_CONN:            equ 11
     323   00:4000  (00:000C)           ERR_CONN_STATE:         equ 12
     324   00:4000  (00:000D)           ERR_BUFFER:             equ 13
     325   00:4000  (00:000E)           ERR_LARGE_DGRAM:        equ 14
     326   00:4000  (00:000F)           ERR_INV_OPER:           equ 15
     327   00:4000                      
     328   00:4000                      ;--- TCP/IP UNAPI connection Status
     329   00:4000  (00:0000)           UNAPI_TCPIP_NS_CLOSED   equ 0
     330   00:4000  (00:0001)           UNAPI_TCPIP_NS_OPENING  equ 1
     331   00:4000  (00:0002)           UNAPI_TCPIP_NS_OPEN     equ 2
     332   00:4000  (00:00FF)           UNAPI_TCPIP_NS_UNKNOWN  equ 255
     333   00:4000                      
     334   00:4000                      ;************************
     335   00:4000                      ;***  MSX ROM HEADER  ***
     336   00:4000                      ;************************
     337   00:4000                          org #4000
     338   00:4000  41 42                   db                  #41,#42
     339   00:4002  10 40                   dw                  INIT        ; Initialize ESP, if not found, won't install hook
     340   00:4004  00 00                   dw                  0           ; Statement
     341   00:4006  00 00                   dw                  0           ; Device
     342   00:4008  00 00                   dw                  0           ; Text
     343   00:400A  00 (6)                  ds                  6           ; Reserved
     344   00:4010                      
     345   00:4010                      ;==================
     346   00:4010                      ;===  Start-up  ===
     347   00:4010                      ;==================
     348   00:4010                      
     349   00:4010                      INIT:
     350   00:4010  7C                      ld  a,h                         ; Let's test if we are mirrored and being executed in wrong page
     351   00:4011  FE 40                   cp  #40                         ; is MSB 0x40?
     352   00:4013  C0                      ret nz                          ; if not, return, it is a mirror
     353   00:4014                          ; Let's set some System Variables
     354   00:4014  AF                      xor a                           ; a = #00
     355   00:4015  32 A9 FC                ld  (CSRSW),a                   ; cursor display is disabled
     356   00:4018  32 DB F3                ld  (CLIKSW),a                  ; when key press, key click disabled
     357   00:401B                          ; Let's intercept [DEL] key
     358   00:401B  3E 08                   ld  a,8
     359   00:401D  CD 41 01                call    SNSMAT
     360   00:4020  CB 5F                   bit 3,a                         ; Test [DEL]
     361   00:4022  C8                      ret z                           ; If DEL is pressed, UNAPI driver is not loaded and exits
     362   00:4023                          ; Let's check the Screen Mode, ref. https://www.msx.org/wiki/VDP_Table_Base_Address_Registers
     363   00:4023  3A E1 F3                ld  a,(REG2SAV)
     364   00:4026  FE 02                   cp  2
     365   00:4028  CA 32 40                jp  z,SCREEN_SETUP              ; If yes, is SCREEN 3
     366   00:402B  3A E3 F3                ld  a,(REG4SAV)
     367   00:402E  FE 00                   cp  0
     368   00:4030  28 06                   jr  z,IS_SCREEN1                ; If yes, is SCREEN 1
     369   00:4032                      SCREEN_SETUP:
     370   00:4032                          ; Let's set the SCREEN 1
     371   00:4032  3E 01                   ld  a,1                         ; a = #01
     372   00:4034  F7                      rst #30
     373   00:4035  00                      db  0
     374   00:4036  5F 00                   dw  CHGMOD                      ; SCREEN 1
     375   00:4038                      IS_SCREEN1:
     376   00:4038  3E 1D                   ld  a,29                        ; WIDTH 29
     377   00:403A  32 B0 F3                ld  (LINLEN),a
     378   00:403D                          ; We check if the Port F2 device is available
     379   00:403D                          READ_F2                         ; a = #FF, default value if it comes from power off or hard reset
     379   00:403D  3A 05 7F          >     ld  a,(MEM_PORT_F2)
     380   00:4040  2F                      cpl                             ; a = #FF - a
     381   00:4041  4F                      ld  c,a                         ; c = #00
     382   00:4042                          WRITE_F2                        ; a = #00
     382   00:4042  32 05 7F          >     ld  (MEM_PORT_F2),a
     383   00:4045                          ; Wait 250ms to ensure a successful hard reset even if you press the button very quickly
     384   00:4045  CD FF 49                call    WAIT_250MS_AND_THEN_CONTINUE
     385   00:4048                          READ_F2                         ; a = #00?
     385   00:4048  3A 05 7F          >     ld  a,(MEM_PORT_F2)
     386   00:404B  2F                      cpl                             ; a = #FF - a
     387   00:404C                          WRITE_F2                        ; a = #FF?
     387   00:404C  32 05 7F          >     ld  (MEM_PORT_F2),a
     388   00:404F  F5                      push    af
     389   00:4050  3E FE                   ld  a,#FE                       ; Preset #FE, unexpected error
     390   00:4052                          WRITE_F2                        ; on port #F2
     390   00:4052  32 05 7F          >     ld  (MEM_PORT_F2),a
     391   00:4055  F1                      pop af
     392   00:4056  B9                      cp  c                           ; If not a = c, port #F2 is writable and available
     393   00:4057  28 3D                   jr  z,BOOT_FROM_POWER_OFF       ; If a = c, port #F2 is not available, let's proceed as "boot from power off"
     394   00:4059                          ; Ok, Port F2 device available
     395   00:4059  FE EF                   cp  #EF                         ; UNAPI driver has been disabled
     396   00:405B  20 04                   jr  nz,NOT_DISABLED_BY_F2       ; No, let's continue checking
     397   00:405D                          WRITE_F2                        ; If yes, UNAPI driver is not loaded and exits, but need to restore F2 port to not have a false error
     397   00:405D  32 05 7F          >     ld  (MEM_PORT_F2),a
     398   00:4060  C9                      ret                             ; And our work is done
     399   00:4061                      NOT_DISABLED_BY_F2:
     400   00:4061  FE F0                   cp  #F0                         ; UNAPI driver has been loaded at least once
     401   00:4063  C2 78 40                jp  nz, F2_IS_NOT_F0            ; Ok, has not been loaded
     402   00:4066                          ; Let's intercept [F1] key
     403   00:4066  3E 06                   ld  a,6
     404   00:4068  CD 41 01                call    SNSMAT
     405   00:406B  CB 6F                   bit 5,a                         ; Test [F1]
     406   00:406D  CA 38 42                jp  z,ENTERING_ESPSETUP         ; If F1 is pressed, let's execute our setup menu
     407   00:4070                          ; F1 is not pressed, continue
     408   00:4070  CB 77                   bit 6,a                         ; Test [F2]
     409   00:4072  C2 E9 40                jp  nz,INIT_UNAPI               ; If F2 is not pressed, let's proceed to INIT_UNAPI
     410   00:4075                          ; F2 is not pressed, continue
     411   00:4075  C3 A2 41                jp  INIT_NOCLOCKUPDAT2          ; If yes, proceed without affecting the connection or the date and time
     412   00:4078                      F2_IS_NOT_F0:
     413   00:4078  FE F1                   cp  #F1                         ; User requested to go directly to Wi-Fi Setup
     414   00:407A  CA 38 42                jp  z,ENTERING_ESPSETUP         ; If yes, let's execute our setup menu
     415   00:407D  FE F2                   cp  #F2                         ; User forces to check if ESP is installed
     416   00:407F  CA C5 40                jp  z,F2_IS_PRESSED             ; If yes, let's go check it out
     417   00:4082  FE FE                   cp  #FE                         ; Unexpected error from the previous reboot
     418   00:4084  20 10                   jr  nz,BOOT_FROM_POWER_OFF      ; If no one is confirmed, let's proceed as "boot from power off"
     419   00:4086                          ; Oops! An unexpected error occurred on the last reboot
     420   00:4086  21 7C 69                ld  hl,STR_OOPS                 ; Print Oops! An unexpected error message
     421   00:4089  CD 86 4C                call    PRINTHL                 ; and let's proceed as "boot from power off"
     422   00:408C  06 78                   ld  b,120                       ; Wait 2 seconds with message on screen
     423   00:408E                      WAIT_2S:
     424   00:408E  76                      halt
     425   00:408F  10 FD                   djnz    WAIT_2S                 ; If not zero, our time out has not elapsed
     426   00:4091  3E 0C                   ld  a,CLS
     427   00:4093  CD A2 00                call    CHPUT
     428   00:4096                      BOOT_FROM_POWER_OFF:
     429   00:4096                          ; Let's intercept [F1] key
     430   00:4096  3E 06                   ld  a,6
     431   00:4098  CD 41 01                call    SNSMAT
     432   00:409B  CB 6F                   bit 5,a                         ; Test [F1]
     433   00:409D  CA 38 42                jp  z,ENTERING_ESPSETUP         ; If F1 is pressed, let's execute our setup menu
     434   00:40A0                          ; F1 is not pressed, continue
     435   00:40A0                          if  NON_VERBOSE_ROM = 0
     436   00:40A0  21 56 5D                ld  hl,WELCOME
     437   00:40A3  CD 86 4C                call    PRINTHL
     438   00:40A6                          CHECK_QUICK_RECEIVE
     438   00:40A6  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
     438   00:40A9  CB 5F             >     bit 3,a
     439   00:40AB  20 08                   jr  nz,BOOT_FROM_POWER_OFF.1    ; QR Supported
     440   00:40AD  21 C0 5D                ld  hl,WELCOME_SF2
     441   00:40B0  CD 86 4C                call    PRINTHL
     442   00:40B3  18 06                   jr  BOOT_FROM_POWER_OFF.2
     443   00:40B5                      BOOT_FROM_POWER_OFF.1:
     444   00:40B5  21 A4 5D                ld  hl,WELCOME_SF
     445   00:40B8  CD 86 4C                call    PRINTHL
     446   00:40BB                      BOOT_FROM_POWER_OFF.2:
     447   00:40BB                          endif
     448   00:40BB  3E 06                   ld  a,6
     449   00:40BD  CD 41 01                call    SNSMAT
     450   00:40C0  CB 77                   bit 6,a                         ; Test [F2]
     451   00:40C2  C2 E9 40                jp  nz,INIT_UNAPI               ; If F2 is not pressed, let's proceed to INIT_UNAPI
     452   00:40C5                          ; F2 is pressed, continue
     453   00:40C5                      F2_IS_PRESSED:
     454   00:40C5  CD 99 5B                call    RESET_ESP
     455   00:40C8  B7                      or  a
     456   00:40C9  20 06                   jr  nz,ESP_NOT_FOUND
     457   00:40CB  21 D4 68                ld  hl,OK_S                     ; Properly detected
     458   00:40CE  C3 DB 40                jp  INIT_F_MSG                  ; Well, if reset successful, continue
     459   00:40D1                      ESP_NOT_FOUND:
     460   00:40D1                          ; If here, ESP was not found, so, exit with an error message
     461   00:40D1  78                      ld  a,b
     462   00:40D2  B7                      or  a
     463   00:40D3  21 EF 68                ld  hl,FAIL_S                   ; If 0, non responsive
     464   00:40D6  28 03                   jr  z,INIT_F_MSG
     465   00:40D8  21 3D 69                ld  hl,FAIL_F                   ; Otherwise, firmware is old
     466   00:40DB                      INIT_F_MSG:
     467   00:40DB  CD 86 4C                call    PRINTHL
     468   00:40DE                      INIT_F_WAIT:
     469   00:40DE  06 B4                   ld  b,180                       ; 3s
     470   00:40E0                      INIT_F_LOOP_WAIT:
     471   00:40E0  76                      halt
     472   00:40E1  10 FD                   djnz    INIT_F_LOOP_WAIT
     473   00:40E3                      AND_DONE:
     474   00:40E3  3E EF                   ld  a,#EF                       ; Set #EF, ESP Not Found
     475   00:40E5                          WRITE_F2                        ; on port #F2
     475   00:40E5  32 05 7F          >     ld  (MEM_PORT_F2),a
     476   00:40E8  C9                      ret                             ; And done
     477   00:40E9                      INIT_UNAPI:
     478   00:40E9                          CLEAR_UART
     478   00:40E9  3E 14             >     ld  a,20
     478   00:40EB  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     479   00:40EE  3E 63                   ld  a,CMD_QUERY_ACLK_SETTINGS
     480   00:40F0                          SEND_DATA
     480   00:40F0  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     481   00:40F3  21 3C 00                ld  hl,60                       ; Wait Up To 1s
     482   00:40F6  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
     483   00:40FA  DD 6B                   ld  ixl,e
     484   00:40FC  DD 62                   ld  ixh,d                       ; Address in IX
     485   00:40FE  CD 5E 4B                call    WAIT_MENU_CMD_RESPONSE
     486   00:4101  CA 98 41                jp  z,INIT_NOCLOCKUPDATE        ; If error, just skip
     487   00:4104                          ; Response received, IX+0 and IX+1 has Auto Clock and GMT
     488   00:4104  3E 03                   ld  a,3
     489   00:4106  DD BE 00                cp  (ix+0)
     490   00:4109  20 0B                   jr  nz,INIT_UNAPI2              ; If not disabled continue on INIT_UNAPI2
     491   00:410B                          ; Disabled, ok, so let's ensure connection is not locked (just in case it was setup as disabled right now)
     492   00:410B                          CLEAR_UART
     492   00:410B  3E 14             >     ld  a,20
     492   00:410D  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     493   00:4110  3E 68                   ld  a,CMD_WIFIRELEASE_ESP
     494   00:4112                          SEND_DATA                       ; Just send, no need to wait response
     494   00:4112  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     495   00:4115  C9                      ret
     496   00:4116                      INIT_UNAPI2:
     497   00:4116  3A 2D 00                ld  a,(#002D)                   ; Check MSX Version
     498   00:4119  B7                      or  a
     499   00:411A  28 7C                   jr  z,INIT_NOCLOCKUPDATE        ; If zero, MSX1, can't set clock
     500   00:411C  AF                      xor a
     501   00:411D  DD B6 00                or  (ix+0)
     502   00:4120  28 76                   jr  z,INIT_NOCLOCKUPDATE        ; if turned off, skip
     503   00:4122                          ; Ok, not zero, so we are going to simply request the time, it might take up to 10s
     504   00:4122  DD 23                   inc ix
     505   00:4124  DD 23                   inc ix                          ; ok, leave IX+0 and IX+1 intact
     506   00:4126                          ; b = number of response check attempts
     507   00:4126  06 05                   ld  b,5                         ; 5 * 2s = 10s
     508   00:4128                          CLEAR_UART
     508   00:4128  3E 14             >     ld  a,20
     508   00:412A  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     509   00:412D  3E 47                   ld  a,CMD_GET_TIME
     510   00:412F                          SEND_DATA
     510   00:412F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     511   00:4132                      TRY_AGAIN:
     512   00:4132  C5                      push    bc
     513   00:4133  21 78 00                ld  hl,120                      ; Wait Up To 2s per attempt
     514   00:4136  CD 5E 4B                call    WAIT_MENU_CMD_RESPONSE
     515   00:4139  20 1E                   jr  nz,INIT_CLOCKUPDATE         ; if ok, follow up
     516   00:413B  21 5C 69                ld  hl,STR_WAITING              ; Print Waiting for connection message
     517   00:413E  CD 86 4C                call    PRINTHL
     518   00:4141  3E FF                   ld  a,#ff
     519   00:4143  B8                      cp  b                           ; Was time-out the failure reason?
     520   00:4144  C1                      pop bc                          ; Restore stack ballance and retry counter
     521   00:4145  20 04                   jr  nz,STOP_TRYING              ; If error return code and not time-out, no more checks needed
     522   00:4147  3E 47                   ld  a,CMD_GET_TIME              ; Needed for retries
     523   00:4149  10 E7                   djnz    TRY_AGAIN
     524   00:414B                      STOP_TRYING:
     525   00:414B                          ; Leave a message that clock has not been updated
     526   00:414B  21 66 68                ld  hl,STR_CLKUPDT_FAIL
     527   00:414E  CD 86 4C                call    PRINTHL
     528   00:4151  3E F0                   ld  a,240                       ; Wait 4 seconds with message on screen
     529   00:4153                      WAIT_4S:
     530   00:4153  76                      halt
     531   00:4154  3D                      dec a
     532   00:4155                          ; If not zero, our time out has not elapsed
     533   00:4155  20 FC                   jr  nz,WAIT_4S
     534   00:4157  18 3F                   jr  INIT_NOCLOCKUPDATE          ; error, just skip to not set garbage in clock
     535   00:4159                      INIT_CLOCKUPDATE:
     536   00:4159  C1                      pop bc
     537   00:415A  DD 2B                   dec ix
     538   00:415C  DD 2B                   dec ix                          ; ix back where it should
     539   00:415E                          ; ix + 0 -> 0 If no need to set clock, 1 if set clock, 2 if set clock and request to turn Wi-Fi Off
     540   00:415E                          ; ix + 1 -> GMT setting, well, not going to use it
     541   00:415E                          ; ix + 2 -> Seconds
     542   00:415E                          ; ix + 3 -> Minutes
     543   00:415E                          ; ix + 4 -> Hours
     544   00:415E                          ; ix + 5 -> Day
     545   00:415E                          ; ix + 6 -> Month
     546   00:415E                          ; ix + 7 -> Year LSB
     547   00:415E                          ; ix + 8 -> Year MSB
     548   00:415E  DD 66 04                ld  h,(ix+4)
     549   00:4161  DD 6E 03                ld  l,(ix+3)
     550   00:4164  DD 56 02                ld  d,(ix+2)
     551   00:4167  CD DC 5B                call    SET_TIME
     552   00:416A  20 2C                   jr  nz,INIT_NOCLOCKUPDATE       ; if error, just skip
     553   00:416C  DD 66 08                ld  h,(ix+8)
     554   00:416F  DD 6E 07                ld  l,(ix+7)
     555   00:4172  DD 56 06                ld  d,(ix+6)
     556   00:4175  DD 5E 05                ld  e,(ix+5)
     557   00:4178  CD 09 5C                call    SET_DATE
     558   00:417B  3E 02                   ld  a,2
     559   00:417D  DD BE 00                cp  (ix+0)
     560   00:4180  20 16                   jr  nz,INIT_NOCLOCKUPDATE
     561   00:4182                          ; First, release any hold to Wi-Fi Connection
     562   00:4182                          CLEAR_UART
     562   00:4182  3E 14             >     ld  a,20
     562   00:4184  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     563   00:4187  3E 68                   ld  a,CMD_WIFIRELEASE_ESP
     564   00:4189                          SEND_DATA                       ; Just send, no need to wait response
     564   00:4189  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     565   00:418C                          ; And, turn off Wi-Fi Immediatelly
     566   00:418C                          CLEAR_UART
     566   00:418C  3E 14             >     ld  a,20
     566   00:418E  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     567   00:4191  3E 4F                   ld  a,CMD_WIFI_OFF
     568   00:4193                          SEND_DATA                       ; Just send, no need to wait response
     568   00:4193  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     569   00:4196  18 0A                   jr  INIT_NOCLOCKUPDAT2
     570   00:4198                      INIT_NOCLOCKUPDATE:
     571   00:4198                          ; Release any hold to Wi-Fi Connection
     572   00:4198                          CLEAR_UART
     572   00:4198  3E 14             >     ld  a,20
     572   00:419A  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     573   00:419D  3E 68                   ld  a,CMD_WIFIRELEASE_ESP
     574   00:419F                          SEND_DATA                       ; Just send, no need to wait response
     574   00:419F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     575   00:41A2                      INIT_NOCLOCKUPDAT2:
     576   00:41A2                          ; Save existing EXTBIO hook if it exists
     577   00:41A2  3A 20 FB                ld  a,(HOKVLD)
     578   00:41A5  CB 47                   bit 0,a
     579   00:41A7  20 0B                   jr  nz,SAVE_HOOK2               ; HOKVLD tells us if there is an extended BIOS already or not, if yes, save it
     580   00:41A9                          ; If here, no extended BIOS
     581   00:41A9  CD 6D 59                call    GETSLT
     582   00:41AC  CD C6 59                call    GETWRK                  ; Our ROM work area address is at HL (we can use up to 8 bytes)
     583   00:41AF  3E C9                   ld  a,#c9                       ; RET, as we are the first extended BIOS
     584   00:41B1  77                      ld  (hl),a
     585   00:41B2  18 13                   jr  PATCH                       ; And now all we need to do is patch the EXTBIO hook :)
     586   00:41B4                      
     587   00:41B4                      SAVE_HOOK2:
     588   00:41B4                          ; If here, we are not the first to extend bios, so we need to save the previous one
     589   00:41B4  CD 6D 59                call    GETSLT
     590   00:41B7  CD C6 59                call    GETWRK                  ; Our ROM work area address is at HL (we can use up to 8 bytes)
     591   00:41BA  EB                      ex  de,hl                       ; It is the destination for....
     592   00:41BB  21 CA FF                ld  hl,EXTBIO                   ; The actual EXTBIO hook
     593   00:41BE  01 05 00                ld  bc,5                        ; That is 5 bytes large
     594   00:41C1  ED B0                   ldir                            ; And move to our work area
     595   00:41C3  AF                      xor a
     596   00:41C4  12                      ld  (de),a                      ; Not initialized (de is at the sixth byte) of our slot work area
     597   00:41C5  13                      inc de
     598   00:41C6  12                      ld  (de),a                      ; Not initialized (de is at the seventh byte) of our slot work area
     599   00:41C7                      
     600   00:41C7                          ; Patch EXTBIO
     601   00:41C7                      PATCH:
     602   00:41C7  3E F7                   ld  a,#F7                       ; RST #30
     603   00:41C9  32 CA FF                ld  (EXTBIO),a                  ; In EXTBIO hook
     604   00:41CC  CD 6D 59                call    GETSLT                  ; Our Slot in A
     605   00:41CF  32 CB FF                ld  (EXTBIO+1),a                ; Next EXTBIO hook byte
     606   00:41D2  21 DB 4C                ld  hl,DO_EXTBIO                ; Our EXTBIO routine address
     607   00:41D5  22 CC FF                ld  (EXTBIO+2),hl               ; Goes to the following two bytes in the hook
     608   00:41D8                      
     609   00:41D8  21 CF FF                ld  hl,EXTBIO+5                 ; Must patch DISINT and ENAINT as well
     610   00:41DB  06 0A                   ld  b,5*2
     611   00:41DD                      PATCH2:
     612   00:41DD  36 C9                   ld  (hl),#C9
     613   00:41DF  23                      inc hl
     614   00:41E0  10 FB                   djnz    PATCH2                  ; So patch all 10 bytes with return
     615   00:41E2                      
     616   00:41E2  21 20 FB                ld  hl,HOKVLD
     617   00:41E5  CB C6                   set 0,(hl)                      ; And set HOKVLD properly to indicate an EXTBIOS is installed
     618   00:41E7                      INIT_OK:
     619   00:41E7                          if  NON_VERBOSE_ROM = 0
     620   00:41E7  21 D4 68                ld  hl,OK_S                     ; All done and set, nice exit message
     621   00:41EA  CD 86 4C                call    PRINTHL
     622   00:41ED                          endif
     623   00:41ED  3E F0                   ld  a,#F0                       ; Set #F0, UNAPI driver has been loaded at least once
     624   00:41EF                          WRITE_F2
     624   00:41EF  32 05 7F          >     ld  (MEM_PORT_F2),a
     625   00:41F2  C9                      ret
     626   00:41F3                      
     627   00:41F3                      ;==============================
     628   00:41F3                      ;===  TPA Memory Allocation  ==
     629   00:41F3                      ;==============================
     630   00:41F3                      HIMEM_ALLOC:
     631   00:41F3                          ; Now let's reserve memory in the 4th page for our usage
     632   00:41F3  2A 4A FC                ld hl,(HIMEM)                   ; Get HIMEM
     633   00:41F6  B7                      or  a                           ; Clear Carry
     634   00:41F7  11 1E 00                ld  de,HIMEM_RESERVED_SIZE      ; Reserve How much memory we need
     635   00:41FA  ED 52                   sbc hl,de                       ; New HIMEM
     636   00:41FC  22 4A FC                ld  (HIMEM),hl                  ; Save it
     637   00:41FF  23                      inc hl                          ; To be safe
     638   00:4200  EB                      ex  de,hl                       ; now in DE
     639   00:4201  CD 6D 59                call    GETSLT
     640   00:4204  CD DA 59                call    GETMEMPOINTERADDR       ; This is where we are going to store our memory area address
     641   00:4207                          ; GETSLT and GETMEMPOINTER do not change DE, so it still has the our memory area address
     642   00:4207  73                      ld  (hl),e
     643   00:4208  23                      inc hl
     644   00:4209  72                      ld  (hl),d                      ; And save our memory area there
     645   00:420A                          ; Ok, DE has our memory area, let's save old H_TIMI hook there
     646   00:420A  21 9F FD                ld  hl,H_TIMI                   ; The actual H_TIMI hook
     647   00:420D  01 05 00                ld  bc,5                        ; That is 5 bytes large
     648   00:4210  ED B0                   ldir                            ; And move to our memory area
     649   00:4212  F3                      di                              ; Turn of interrupts as we are going to patch H_TIMI
     650   00:4213                      PATCH_H_TIMI:
     651   00:4213  3E F7                   ld  a,#F7                       ; RST #30
     652   00:4215  32 9F FD                ld  (H_TIMI),a                  ; In H_TIMI hook
     653   00:4218  CD 6D 59                call    GETSLT                  ; Our Slot in A
     654   00:421B  32 A0 FD                ld  (H_TIMI+1),a                ; Next H_TIMI hook byte
     655   00:421E  21 C7 4C                ld  hl,DO_HTIMI                 ; Our H_TIMI routine address
     656   00:4221  22 A1 FD                ld  (H_TIMI+2),hl               ; Goes to the following two bytes in the hook
     657   00:4224  FB                      ei                              ; done, so re-enable interrupts
     658   00:4225                      
     659   00:4225                          ; Set DNS_READY to zero
     660   00:4225  AF                      xor a
     661   00:4226  CD 04 5B                call    SETDNSREADY
     662   00:4229                          ; Set TIME-OUT counter to zero
     663   00:4229  21 00 00                ld  hl,0
     664   00:422C  CD 0D 5A                call    SETCOUNTER
     665   00:422F  C9                      ret
     666   00:4230                      
     667   00:4230                      ;============================
     668   00:4230                      ;===  SETUP Menu Routines  ==
     669   00:4230                      ;===       Main Menu       ==
     670   00:4230                      ;============================
     671   00:4230                      ESPSETUP.EXIT:
     672   00:4230  3E 0C                   ld  a,CLS
     673   00:4232  CD A2 00                call    CHPUT
     674   00:4235  C3 E9 40                jp  INIT_UNAPI                  ; When done, resume initialization
     675   00:4238                      ENTERING_ESPSETUP:
     676   00:4238  21 3A 5D                ld  hl,ENTERING_WIFI_SETUP
     677   00:423B  CD 86 4C                call    PRINTHL
     678   00:423E  CD A3 5C                call    PATTERN_SETUP
     679   00:4241  CD FF 49                call    WAIT_250MS_AND_THEN_CONTINUE
     680   00:4244                          ; Hold Wi-Fi Connection On
     681   00:4244                          CLEAR_UART
     681   00:4244  3E 14             >     ld  a,20
     681   00:4246  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     682   00:4249  3E 48                   ld  a,CMD_WIFIHOLD_ESP
     683   00:424B                          SEND_DATA
     683   00:424B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     684   00:424E  21 3C 00                ld  hl,60                       ; Up to 1s time-out
     685   00:4251  CD 5E 4B                call    WAIT_MENU_CMD_RESPONSE  ; Wait response
     686   00:4254                          ; We do not want to error here, just in case user still need to upgrade ESP firmware
     687   00:4254                      ESPSETUP:
     688   00:4254  CD 99 5B                call    RESET_ESP
     689   00:4257  B7                      or  a
     690   00:4258  C2 D1 40                jp  nz,ESP_NOT_FOUND            ; Not well, ESP was not found
     691   00:425B                          ; Well, if reset successful, continue
     692   00:425B  21 56 5D                ld  hl,WELCOME
     693   00:425E  CD 86 4C                call    PRINTHL
     694   00:4261                          CHECK_QUICK_RECEIVE
     694   00:4261  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
     694   00:4264  CB 5F             >     bit 3,a
     695   00:4266  20 08                   jr  nz,ESPSETUP.2NF             ; If yes, tells Quick Receive support
     696   00:4268  21 C0 5D                ld  hl,WELCOME_SF2
     697   00:426B  CD 86 4C                call    PRINTHL                 ; Print Welcome message no QR
     698   00:426E  18 06                   jr  ESPSETUP.3NF
     699   00:4270                      ESPSETUP.2NF:
     700   00:4270  21 A4 5D                ld  hl,WELCOME_SF
     701   00:4273  CD 86 4C                call    PRINTHL                 ; Print Welcome message QR
     702   00:4276                      ESPSETUP.3NF:
     703   00:4276  21 E0 5D                ld  hl,WELCOME_CS
     704   00:4279  CD 86 4C                call    PRINTHL                 ; Print Wi-Fi is reconnecting to:
     705   00:427C                      ESPSETUP_NEXT:
     706   00:427C  CD 56 01                call    KILBUF                  ; Clear Keyboard Buffer
     707   00:427F  21 0A 5E                ld  hl,WELCOME_NEXT
     708   00:4282  CD 86 4C                call    PRINTHL
     709   00:4285  21 14 5E                ld  hl,WELCOME_SF_NEXT
     710   00:4288  CD 86 4C                call    PRINTHL                 ; Print Empty Welcome message
     711   00:428B  CD 21 43                call    GET_AP_STAT
     712   00:428E  CA C6 42                jp  z,ESPSETUP_NEXT.1G          ; Won't block in case of error
     713   00:4291                          ; Success, so connection state is in IX+0, then, zero terminated string with SSID starting at IX+1
     714   00:4291  DD 7E 00                ld  a,(ix+0)
     715   00:4294  21 17 5E                ld  hl,WELCOME_CS0_NEXT
     716   00:4297  FE 00                   cp  0
     717   00:4299  28 1F                   jr  z,ESPSETUP_NEXT.2F
     718   00:429B  21 41 5E                ld  hl,WELCOME_CS1_NEXT
     719   00:429E  FE 01                   cp  1
     720   00:42A0  28 18                   jr  z,ESPSETUP_NEXT.2F
     721   00:42A2  21 4A 5E                ld  hl,WELCOME_CS2_NEXT
     722   00:42A5  FE 02                   cp  2
     723   00:42A7  28 11                   jr  z,ESPSETUP_NEXT.2F
     724   00:42A9  21 74 5E                ld  hl,WELCOME_CS3_NEXT
     725   00:42AC  FE 03                   cp  3
     726   00:42AE  28 0A                   jr  z,ESPSETUP_NEXT.2F
     727   00:42B0  21 9E 5E                ld  hl,WELCOME_CS4_NEXT
     728   00:42B3  FE 04                   cp  4
     729   00:42B5  28 03                   jr  z,ESPSETUP_NEXT.2F
     730   00:42B7  21 C8 5E                ld  hl,WELCOME_CS5_NEXT
     731   00:42BA                      ESPSETUP_NEXT.2F:
     732   00:42BA  FD 67                   ld  iyh,a                       ; Save current conn status in iyh
     733   00:42BC  CD 86 4C                call    PRINTHL                 ; Print Status
     734   00:42BF  DD E5                   push    ix
     735   00:42C1  E1                      pop hl
     736   00:42C2  23                      inc hl                          ; HL has AP Name
     737   00:42C3  CD 90 4C                call    PRINTHLINE              ; Print AP Name
     738   00:42C6                      ESPSETUP_NEXT.1G:
     739   00:42C6  21 F2 5E                ld  hl,MMENU_S_NEXT
     740   00:42C9  CD 86 4C                call    PRINTHL                 ; Print Main Menu
     741   00:42CC                      MM_CURSOR_BLINK:
     742   00:42CC  CD 0D 43                call    MM_CURSOR_SW            ; Cursor On
     743   00:42CF                      CONN_CHG_LOOP:
     744   00:42CF  CD 9C 00                call    CHSNS
     745   00:42D2  20 13                   jr  nz,MM_WAIT_INPUT            ; If not zero, there is a key in buffer
     746   00:42D4                          ; Ok, there is not, we can check if connection status changed
     747   00:42D4  CD 21 43                call    GET_AP_STAT
     748   00:42D7  CA CF 42                jp  z,CONN_CHG_LOOP             ; Won't block in case of error
     749   00:42DA                          ; Success, so connection state is in IX+0
     750   00:42DA  DD 7E 00                ld  a,(ix+0)
     751   00:42DD  FD BC                   cp  iyh                         ; If same, zero
     752   00:42DF  28 EE                   jr  z,CONN_CHG_LOOP             ; Keep loop
     753   00:42E1  CD 0D 43                call    MM_CURSOR_SW            ; Cursor Off
     754   00:42E4  C3 7C 42                jp  ESPSETUP_NEXT               ; Changed, re-build menu
     755   00:42E7                      MM_WAIT_INPUT:
     756   00:42E7  CD 9F 00                call    CHGET
     757   00:42EA  FE 1B                   cp  #1b                         ; ESC?
     758   00:42EC  CA 30 42                jp  z,ESPSETUP.EXIT             ; When done, resume initialization
     759   00:42EF  FE 31                   cp  '1'                         ; Setup Nagle?
     760   00:42F1  CA E4 48                jp  z,SET_NAGLE
     761   00:42F4  FE 32                   cp  '2'                         ; Setup Wi-Fi On Period?
     762   00:42F6  CA 1E 48                jp  z,SET_WIFI_TIMEOUT
     763   00:42F9  FE 33                   cp  '3'                         ; Scan networks?
     764   00:42FB  CA 6E 45                jp  z,START_WIFI_SCAN
     765   00:42FE  FE 34                   cp  '4'                         ; Automatic Setting of Clock?
     766   00:4300  CA 8A 43                jp  z,START_CLK_AUTO
     767   00:4303  CD C0 00                call    BEEP                    ; Wrong Input, beep
     768   00:4306  CD 0D 43                call    MM_CURSOR_SW            ; Cursor Off
     769   00:4309  76                      halt
     770   00:430A  C3 CC 42                jp  MM_CURSOR_BLINK             ; And return, waiting another key
     771   00:430D                      MM_CURSOR_SW:                       ; Cursor workaround for CONN_CHG_LOOP
     772   00:430D  3E 1D                   ld  a,GOLEFT
     773   00:430F  CD A2 00                call    CHPUT
     774   00:4312  3E 01                   ld  a,1
     775   00:4314  32 A9 FC                ld  (CSRSW),a
     776   00:4317  3E 20                   ld  a,' '
     777   00:4319  CD A2 00                call    CHPUT                   ; Switch the cursor display mode
     778   00:431C  AF                      xor a
     779   00:431D  32 A9 FC                ld  (CSRSW),a
     780   00:4320  C9                      ret
     781   00:4321                      GET_AP_STAT:                        ; Use 'call GET_AP_STAT'
     782   00:4321                          CLEAR_UART
     782   00:4321  3E 14             >     ld  a,20
     782   00:4323  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     783   00:4326  3E 67                   ld  a,CMD_AP_STS
     784   00:4328                          SEND_DATA                       ; Get AP conn status and name
     784   00:4328  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     785   00:432B  21 3C 00                ld  hl,60                       ; Wait Up To 1s
     786   00:432E  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
     787   00:4332  DD 6B                   ld  ixl,e
     788   00:4334  DD 62                   ld  ixh,d                       ; Address in IX
     789   00:4336  C3 5E 4B                jp  WAIT_MENU_CMD_RESPONSE
     790   00:4339                      
     791   00:4339                      ;============================
     792   00:4339                      ;===  SETUP Menu Routines  ==
     793   00:4339                      ;===  Wi-Fi and Clock Menu ==
     794   00:4339                      ;============================
     795   00:4339                      CLK_MSX1_GO:
     796   00:4339  21 E1 60                ld  hl,MMENU_CLOCK_MSX1
     797   00:433C  CD 86 4C                call    PRINTHL                 ; Print Main Clock MSX1 message
     798   00:433F  CD 06 4A                call    ISCLKAUTO
     799   00:4342  DD 7E 00                ld  a,(ix+0)                    ; Auto Clock Current setting
     800   00:4345  FE 03                   cp  3                           ; If 3 adapter disabled
     801   00:4347  28 08                   jr  z,CLK_MSX1_ADAPTERDIS
     802   00:4349  21 75 61                ld  hl,MMENU_CLOCK_0
     803   00:434C  CD 86 4C                call    PRINTHL
     804   00:434F  18 06                   jr  CLK_MSX1_OPT
     805   00:4351                      CLK_MSX1_ADAPTERDIS:
     806   00:4351  21 BB 61                ld  hl,MMENU_CLOCK_3
     807   00:4354  CD 86 4C                call    PRINTHL
     808   00:4357                      CLK_MSX1_OPT:
     809   00:4357  21 CE 61                ld  hl,MMENU_CLOCK_OPT
     810   00:435A  CD 86 4C                call    PRINTHL
     811   00:435D                      CLK_MSX1_WAIT_OPT_INPUT:
     812   00:435D  CD 9F 00                call    CHGET
     813   00:4360  FE 1B                   cp  #1b                         ; ESC?
     814   00:4362  CA 54 42                jp  z,ESPSETUP                  ; Back to main menu
     815   00:4365  FE 30                   cp  '0'
     816   00:4367  CA 75 43                jp  z,CLK_MSX1_SEND_CMD
     817   00:436A  FE 33                   cp  '3'
     818   00:436C  CA 31 44                jp  z,CLK_AUTO_WAIT_GMT
     819   00:436F  CD C0 00                call    BEEP                    ; Wrong Input, beep
     820   00:4372  C3 5D 43                jp  CLK_MSX1_WAIT_OPT_INPUT     ; And return, waiting another key
     821   00:4375                      CLK_MSX1_SEND_CMD:
     822   00:4375  CD A2 00                call    CHPUT                   ; Print option
     823   00:4378  D6 30                   sub '0'                         ; Adjust format
     824   00:437A  DD 77 00                ld  (ix+0),a                    ; Save it
     825   00:437D  3E 0D                   ld  a,#0d
     826   00:437F  CD A2 00                call    CHPUT
     827   00:4382  3E 0A                   ld  a,#0a
     828   00:4384  CD A2 00                call    CHPUT
     829   00:4387  C3 28 45                jp  CLK_AUTO_GMT_CHK_DONE       ; And sending the command will be done there
     830   00:438A                      
     831   00:438A                      START_CLK_AUTO:
     832   00:438A  3E 34                   ld  a,'4'
     833   00:438C  CD A2 00                call    CHPUT
     834   00:438F  CD FF 49                call    WAIT_250MS_AND_THEN_CONTINUE
     835   00:4392  3A 2D 00                ld  a,(#002D)                   ; Check MSX Version
     836   00:4395  B7                      or  a
     837   00:4396  CA 39 43                jp  z,CLK_MSX1_GO               ; If zero, MSX1, so can just enable or disable adapter
     838   00:4399                      CLK_AUTO_GO:
     839   00:4399  21 81 5F                ld  hl,MMENU_CLOCK_MSX2
     840   00:439C  CD 86 4C                call    PRINTHL                 ; Print Main Clock MSX2 message
     841   00:439F  CD 06 4A                call    ISCLKAUTO
     842   00:43A2  DD 7E 00                ld  a,(ix+0)                    ; Auto Clock Current setting
     843   00:43A5  B7                      or  a                           ; If zero, off
     844   00:43A6  20 08                   jr  nz,CLK_AUTO_CHK1
     845   00:43A8  21 75 61                ld  hl,MMENU_CLOCK_0
     846   00:43AB  CD 86 4C                call    PRINTHL
     847   00:43AE  18 59                   jr  CLK_AUTO_GMT_OPT
     848   00:43B0                      CLK_AUTO_CHK1:
     849   00:43B0  3D                      dec a                           ; If 1, on and keep wifi on
     850   00:43B1  20 08                   jr  nz,CLK_AUTO_CHK2
     851   00:43B3  21 87 61                ld  hl,MMENU_CLOCK_1
     852   00:43B6  CD 86 4C                call    PRINTHL
     853   00:43B9  18 13                   jr  CLK_AUTO_GMT
     854   00:43BB                      CLK_AUTO_CHK2:
     855   00:43BB  3D                      dec a                           ; If 2, on and turn wifi off
     856   00:43BC  20 08                   jr  nz,CLK_AUTO_3
     857   00:43BE  21 A1 61                ld  hl,MMENU_CLOCK_2
     858   00:43C1  CD 86 4C                call    PRINTHL
     859   00:43C4  18 08                   jr  CLK_AUTO_GMT
     860   00:43C6                      CLK_AUTO_3:
     861   00:43C6  21 BB 61                ld  hl,MMENU_CLOCK_3
     862   00:43C9  CD 86 4C                call    PRINTHL
     863   00:43CC  18 3B                   jr  CLK_AUTO_GMT_OPT
     864   00:43CE                      CLK_AUTO_GMT:
     865   00:43CE  DD 66 01                ld  h,(ix+1)                    ; Save it for now
     866   00:43D1  DD 7E 01                ld  a,(ix+1)                    ; GMT current setting
     867   00:43D4  CB 7F                   bit 7,a                         ; If set, is -
     868   00:43D6  28 0B                   jr  z,CLK_AUTO_GMTP
     869   00:43D8  3E 2D                   ld  a,'-'
     870   00:43DA  CD A2 00                call    CHPUT
     871   00:43DD  DD CB 01 BE             res 7,(ix+1)                    ; Clear - indicator
     872   00:43E1  18 05                   jr  CLK_AUTO_GMTM
     873   00:43E3                      CLK_AUTO_GMTP:
     874   00:43E3  3E 2B                   ld  a,'+'
     875   00:43E5  CD A2 00                call    CHPUT
     876   00:43E8                      CLK_AUTO_GMTM:
     877   00:43E8  3E 09                   ld  a,9
     878   00:43EA  DD BE 01                cp  (ix+1)                      ; Greater than 9?
     879   00:43ED  30 0F                   jr  nc,CLK_AUTO_GMTD            ; If not, just print what is in A + '0'
     880   00:43EF  3E 31                   ld  a,'1'                       ; It is 1
     881   00:43F1  CD A2 00                call    CHPUT
     882   00:43F4  DD 7E 01                ld  a,(ix+1)
     883   00:43F7  C6 26                   add '0'-10                      ; Need to subtract 10 and add '0' to print
     884   00:43F9  CD A2 00                call    CHPUT
     885   00:43FC  18 0B                   jr  CLK_AUTO_GMT_OPT
     886   00:43FE                      CLK_AUTO_GMTD:
     887   00:43FE  3E 30                   ld  a,'0'
     888   00:4400  DD 86 01                add a,(ix+1)                    ; Our value
     889   00:4403  CD A2 00                call    CHPUT
     890   00:4406  DD 74 01                ld  (ix+1),h                    ; Restore original value
     891   00:4409                      CLK_AUTO_GMT_OPT:
     892   00:4409  21 CE 61                ld  hl,MMENU_CLOCK_OPT
     893   00:440C  CD 86 4C                call    PRINTHL
     894   00:440F                      CLK_AUTO_WAIT_OPT_INPUT:
     895   00:440F  CD 9F 00                call    CHGET
     896   00:4412  FE 1B                   cp  #1b                         ; ESC?
     897   00:4414  CA 54 42                jp  z,ESPSETUP                  ; Back to main menu
     898   00:4417  FE 30                   cp  '0'
     899   00:4419  CA 31 44                jp  z,CLK_AUTO_WAIT_GMT
     900   00:441C  FE 31                   cp  '1'
     901   00:441E  CA 31 44                jp  z,CLK_AUTO_WAIT_GMT
     902   00:4421  FE 32                   cp  '2'
     903   00:4423  CA 31 44                jp  z,CLK_AUTO_WAIT_GMT
     904   00:4426  FE 33                   cp  '3'
     905   00:4428  CA 31 44                jp  z,CLK_AUTO_WAIT_GMT
     906   00:442B  CD C0 00                call    BEEP                    ; Wrong Input, beep
     907   00:442E  C3 0F 44                jp  CLK_AUTO_WAIT_OPT_INPUT     ; And return, waiting another key
     908   00:4431                      CLK_AUTO_WAIT_GMT:
     909   00:4431  CD A2 00                call    CHPUT                   ; Print option
     910   00:4434  D6 30                   sub '0'                         ; Adjust format
     911   00:4436  DD 77 00                ld  (ix+0),a                    ; Save it
     912   00:4439  B7                      or  a
     913   00:443A  CA 28 45                jp  z,CLK_AUTO_GMT_CHK_DONE     ; And send the command if just disabling clock auto set
     914   00:443D  FE 03                   cp  3
     915   00:443F  CA 28 45                jp  z,CLK_AUTO_GMT_CHK_DONE     ; Or send the command if just disabling the adapter
     916   00:4442  21 F8 61                ld  hl,MMENU_GMT_OPT
     917   00:4445  CD 86 4C                call    PRINTHL
     918   00:4448  16 00                   ld  d,0                         ; # of digits entered
     919   00:444A  1E 00                   ld  e,0                         ; # of characters printed
     920   00:444C  DD 36 01 00             ld  (ix+1),0                    ; GMT 0
     921   00:4450                      CLK_AUTO_WAIT_GMT_INPUT:
     922   00:4450  CD 9F 00                call    CHGET
     923   00:4453  FE 1B                   cp  #1b                         ; ESC?
     924   00:4455  CA 54 42                jp  z,ESPSETUP                  ; Back to main menu
     925   00:4458  FE 0D                   cp  #0d                         ; ENTER?
     926   00:445A  CA A3 44                jp  z,CLK_AUTO_GMT_CHK_INPUT    ; Check if ok to send command
     927   00:445D  FE 08                   cp  #08                         ; Backspace?
     928   00:445F  CA 74 44                jp  z,CLK_AUTO_GMT_CHK_BS       ; Check if there is something to erase
     929   00:4462  FE 2D                   cp  '-'                         ; Negative value?
     930   00:4464  CA A3 44                jp  z,CLK_AUTO_GMT_CHK_INPUT
     931   00:4467  FE 30                   cp  '0'                         ; >=0?
     932   00:4469  DA 95 44                jp  c,CLK_AUTO_GMT_BAD_INPUT    ; If not, bad input
     933   00:446C  FE 3A                   cp  '9'+1                       ; <= 9
     934   00:446E  D2 95 44                jp  nc,CLK_AUTO_GMT_BAD_INPUT   ; If not, bad input
     935   00:4471  C3 A3 44                jp  CLK_AUTO_GMT_CHK_INPUT      ; Otherwise, validate digit
     936   00:4474                      CLK_AUTO_GMT_CHK_BS:
     937   00:4474  AF                      xor a
     938   00:4475  BB                      cp  e                           ; Anything on screen?
     939   00:4476  28 1D                   jr  z,CLK_AUTO_GMT_BAD_INPUT    ; Nothing to erase
     940   00:4478  1D                      dec e                           ; One less character on the screen
     941   00:4479  BA                      cp  d                           ; Any digit?
     942   00:447A  28 03                   jr  z,CLK_AUTO_GMT_CHK_BS_MIN   ; If not, just erase - sign
     943   00:447C                          ; There is, so it is one less digit
     944   00:447C  15                      dec d
     945   00:447D  18 04                   jr  CLK_AUTO_GMT_CHK_DIGIT
     946   00:447F                      CLK_AUTO_GMT_CHK_BS_MIN:
     947   00:447F  DD 36 01 00             ld  (ix+1),0                    ; Reset sign
     948   00:4483                      CLK_AUTO_GMT_CHK_DIGIT:
     949   00:4483  3E 08                   ld  a,8                         ; Backspace
     950   00:4485  CD A2 00                call    CHPUT                   ; Print it
     951   00:4488  3E 20                   ld  a,' '                       ; Space
     952   00:448A  CD A2 00                call    CHPUT                   ; Print it
     953   00:448D  3E 08                   ld  a,8                         ; Backspace
     954   00:448F  CD A2 00                call    CHPUT                   ; Print it
     955   00:4492  C3 50 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; Return
     956   00:4495                      CLK_AUTO_GMT_BAD_INPUT:
     957   00:4495                          ; Beep might use sub rom, and if so, all registers will be messed up, better save
     958   00:4495  C5                      push    bc
     959   00:4496  D5                      push    de
     960   00:4497  F5                      push    af
     961   00:4498  E5                      push    hl
     962   00:4499  CD C0 00                call    BEEP                    ; Wrong Input, beep
     963   00:449C  E1                      pop hl
     964   00:449D  F1                      pop af
     965   00:449E  D1                      pop de
     966   00:449F  C1                      pop bc
     967   00:44A0  C3 50 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; And return, waiting another key
     968   00:44A3                      CLK_AUTO_GMT_CHK_INPUT:
     969   00:44A3  4F                      ld  c,a                         ; Save in C for printing if needed
     970   00:44A4  FE 2D                   cp  '-'                         ; - sign?
     971   00:44A6  20 11                   jr  nz,CLK_AUTO_GMT_CHK_CR      ; If not, check if enter
     972   00:44A8                          ; - sign
     973   00:44A8  3E 00                   ld  a,0
     974   00:44AA  BB                      cp  e                           ; If not the first character, can't accept
     975   00:44AB  20 E8                   jr  nz,CLK_AUTO_GMT_BAD_INPUT
     976   00:44AD                          ; It is the first, so let's print it
     977   00:44AD  79                      ld  a,c
     978   00:44AE  CD A2 00                call    CHPUT
     979   00:44B1  DD 36 01 80             ld  (ix+1),0x80                 ; Set the - sign bit, for now rest is zero
     980   00:44B5  1C                      inc e                           ; Increase # of characters printed
     981   00:44B6  C3 50 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; Continue waiting input
     982   00:44B9                      CLK_AUTO_GMT_CHK_CR:
     983   00:44B9  FE 0D                   cp  #0d                         ; ENTER?
     984   00:44BB  20 0F                   jr  nz,CLK_AUTO_GMT_CHK_CD      ; If not, check if digit is valid
     985   00:44BD                          ; Enter
     986   00:44BD  3E 00                   ld  a,0
     987   00:44BF  BA                      cp  d                           ; Ok, at least one digit entered?
     988   00:44C0  28 D3                   jr  z,CLK_AUTO_GMT_BAD_INPUT    ; No, so, enter is no good now
     989   00:44C2                          ; It is, if it had a digit entered and did not send, it was 1, so...
     990   00:44C2  3E 01                   ld  a,1
     991   00:44C4  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
     992   00:44C7  DD 77 01                ld  (ix+1),a                    ; Save
     993   00:44CA  18 5C                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ok, ready to send
     994   00:44CC                      CLK_AUTO_GMT_CHK_CD:
     995   00:44CC                          ; Ok, it is a digit
     996   00:44CC  06 30                   ld  b,'0'
     997   00:44CE  90                      sub a,b                         ; A has digit value
     998   00:44CF  47                      ld  b,a                         ; Save in B
     999   00:44D0  3E 00                   ld  a,0
    1000   00:44D2  BA                      cp  d
    1001   00:44D3  20 1E                   jr  nz,CLK_AUTO_GMT_CHK_CSD     ; If not zero, it is second digit, so almost done
    1002   00:44D5                          ; 1st digit, let's check if it is other than 1, if it is, we are almost done
    1003   00:44D5  3E 01                   ld  a,1
    1004   00:44D7  B8                      cp  b
    1005   00:44D8  28 10                   jr  z,CLK_AUTO_GMT_CHK_CD.1     ; If it is 1, wait next digit or enter
    1006   00:44DA                          ; Not 1, so just adjust ix+1 and go
    1007   00:44DA  79                      ld  a,c
    1008   00:44DB  CD A2 00                call    CHPUT                   ; Print it
    1009   00:44DE  78                      ld  a,b
    1010   00:44DF  B7                      or  a
    1011   00:44E0  28 03                   jr  z,CLK_AUTO_SKIP_SIGN
    1012   00:44E2  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
    1013   00:44E5                      CLK_AUTO_SKIP_SIGN:
    1014   00:44E5  DD 77 01                ld  (ix+1),a                    ; Save
    1015   00:44E8  18 3E                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ok, ready to send
    1016   00:44EA                      CLK_AUTO_GMT_CHK_CD.1:
    1017   00:44EA  79                      ld  a,c
    1018   00:44EB  CD A2 00                call    CHPUT                   ; Print it
    1019   00:44EE  14                      inc d                           ; Digits entered now is 1
    1020   00:44EF  1C                      inc e                           ; Digits printed increased
    1021   00:44F0  C3 50 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; Continue waiting input
    1022   00:44F3                      CLK_AUTO_GMT_CHK_CSD:
    1023   00:44F3                          ; Second digit, easy... First was 1, now need to check if it is 0, 1 or 2, otherwise, bad entry
    1024   00:44F3  78                      ld  a,b
    1025   00:44F4  06 03                   ld  b,3
    1026   00:44F6  B8                      cp  b
    1027   00:44F7  D2 95 44                jp  nc,CLK_AUTO_GMT_BAD_INPUT   ; 3 or more, so, not valid
    1028   00:44FA  B7                      or  a                           ; Is it zero?
    1029   00:44FB  20 0E                   jr  nz,CLK_AUTO_GMT_CHK_CSD1    ; If not, check for 1
    1030   00:44FD                          ; It was zero
    1031   00:44FD  3E 0A                   ld  a,10                        ; So, 10
    1032   00:44FF  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
    1033   00:4502  DD 77 01                ld  (ix+1),a                    ; Save
    1034   00:4505  79                      ld  a,c
    1035   00:4506  CD A2 00                call    CHPUT                   ; Print it
    1036   00:4509  18 1D                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ready to
    1037   00:450B                      CLK_AUTO_GMT_CHK_CSD1:
    1038   00:450B  3D                      dec a                           ; Is it one?
    1039   00:450C  20 0E                   jr  nz,CLK_AUTO_GMT_CHK_CSD2
    1040   00:450E                          ; It was one
    1041   00:450E  3E 0B                   ld  a,11                        ; So, eleven
    1042   00:4510  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
    1043   00:4513  DD 77 01                ld  (ix+1),a                    ; Save
    1044   00:4516  79                      ld  a,c
    1045   00:4517  CD A2 00                call    CHPUT                   ; Print it
    1046   00:451A  18 0C                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ready to send
    1047   00:451C                      CLK_AUTO_GMT_CHK_CSD2:
    1048   00:451C                          ; It was two
    1049   00:451C  3E 0C                   ld  a,12                        ; So, twelve
    1050   00:451E  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
    1051   00:4521  DD 77 01                ld  (ix+1),a                    ; Save
    1052   00:4524  79                      ld  a,c
    1053   00:4525  CD A2 00                call    CHPUT                   ; Print it
    1054   00:4528                          ; And send command
    1055   00:4528                      CLK_AUTO_GMT_CHK_DONE:
    1056   00:4528  3E 0D                   ld  a,#0d
    1057   00:452A  CD A2 00                call    CHPUT
    1058   00:452D  3E 0A                   ld  a,#0a
    1059   00:452F  CD A2 00                call    CHPUT
    1060   00:4532  21 B9 67                ld  hl,STR_SENDING
    1061   00:4535  CD 86 4C                call    PRINTHL
    1062   00:4538                          CLEAR_UART
    1062   00:4538  3E 14             >     ld  a,20
    1062   00:453A  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1063   00:453D  3E 43                   ld  a,CMD_SET_ACLK_SETTINGS
    1064   00:453F                          SEND_DATA
    1064   00:453F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1065   00:4542  3E 00                   ld  a,0                         ; Size MSB is 0
    1066   00:4544                          SEND_DATA
    1066   00:4544  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1067   00:4547  3E 02                   ld  a,2                         ; Size LSB is 2
    1068   00:4549                          SEND_DATA
    1068   00:4549  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1069   00:454C  DD 7E 00                ld  a,(ix+0)                    ; Option
    1070   00:454F                          SEND_DATA
    1070   00:454F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1071   00:4552  DD 7E 01                ld  a,(ix+1)                    ; GMT
    1072   00:4555                          SEND_DATA
    1072   00:4555  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1073   00:4558  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1074   00:455B  3E 43                   ld  a,CMD_SET_ACLK_SETTINGS
    1075   00:455D  CD 21 4B                call    WAIT_MENU_QCMD_RESPONSE
    1076   00:4560  21 D4 67                ld  hl,STR_SENDING_OK
    1077   00:4563  20 03                   jr  nz,CLK_AUTO_GMT_CHK_RESULT
    1078   00:4565  21 51 68                ld  hl,STR_SENDING_FAIL
    1079   00:4568                      CLK_AUTO_GMT_CHK_RESULT:
    1080   00:4568  CD 86 4C                call    PRINTHL
    1081   00:456B  C3 F7 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1082   00:456E                      
    1083   00:456E                      ;============================
    1084   00:456E                      ;===  SETUP Menu Routines  ==
    1085   00:456E                      ;===    Wi-Fi Scan Menu    ==
    1086   00:456E                      ;============================
    1087   00:456E                      START_WIFI_SCAN:
    1088   00:456E  3E 33                   ld  a,'3'
    1089   00:4570  CD A2 00                call    CHPUT
    1090   00:4573  CD FF 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1091   00:4576                      START_WIFI_RESCAN:
    1092   00:4576  21 8D 62                ld  hl,MMENU_SCAN
    1093   00:4579  CD 86 4C                call    PRINTHL                 ; Print Main Scan message
    1094   00:457C  CD A4 49                call    STARTWIFISCAN           ; Request Wi-Fi Scan to start
    1095   00:457F  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1096   00:4583  DD 6B                   ld  ixl,e
    1097   00:4585  DD 62                   ld  ixh,d                       ; Address in IX
    1098   00:4587  11 14 00                ld  de,20                       ; At least 10s waiting scan to finish, retry 20 times waiting 0.5s between attempts
    1099   00:458A                      WIFI_SCAN_WAIT_END:
    1100   00:458A                          CLEAR_UART
    1100   00:458A  3E 14             >     ld  a,20
    1100   00:458C  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1101   00:458F  3E 73                   ld  a,CMD_SCAN_RESULTS
    1102   00:4591                          SEND_DATA
    1102   00:4591  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1103   00:4594  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1104   00:4597  CD EF 4B                call    WAIT_MENU_SCMD_RESPONSE
    1105   00:459A  C2 B2 45                jp  nz,WIFI_SCAN_SHOW_LIST      ; if success show the list
    1106   00:459D  78                      ld  a,b
    1107   00:459E  FE 02                   cp  2                           ; If 2, scan is done and nothing found
    1108   00:45A0  CA 0C 48                jp  z,WIFI_SCAN_NONETWORKS
    1109   00:45A3  2E 1E                   ld  l,30
    1110   00:45A5                      WIFI_SCAN_WAITHS:
    1111   00:45A5  76                      halt
    1112   00:45A6  2D                      dec l
    1113   00:45A7  20 FC                   jr  nz,WIFI_SCAN_WAITHS
    1114   00:45A9  1B                      dec de
    1115   00:45AA  7B                      ld  a,e
    1116   00:45AB  B2                      or  d
    1117   00:45AC  CA 15 48                jp  z,WIFI_SCAN_TIMEOUT
    1118   00:45AF  C3 8A 45                jp  WIFI_SCAN_WAIT_END
    1119   00:45B2                      WIFI_SCAN_SHOW_LIST:
    1120   00:45B2  57                      ld  d,a                         ; Save access point counter here
    1121   00:45B3  1E 00                   ld  e,0                         ; And here how many were printed
    1122   00:45B5  21 12 63                ld  hl,MMENU_SCANS
    1123   00:45B8  CD 86 4C                call    PRINTHL
    1124   00:45BB  DD E5                   push    ix
    1125   00:45BD  E1                      pop hl                          ; IX in HL
    1126   00:45BE                      WIFI_LIST_LOOP:
    1127   00:45BE  7B                      ld  a,e
    1128   00:45BF  C6 30                   add a,'0'                       ; Convert to number
    1129   00:45C1  CD A2 00                call    CHPUT
    1130   00:45C4  3E 20                   ld  a,' '                       ; Space
    1131   00:45C6  CD A2 00                call    CHPUT
    1132   00:45C9  3E 2D                   ld  a,'-'                       ; Dash
    1133   00:45CB  CD A2 00                call    CHPUT
    1134   00:45CE  3E 20                   ld  a,' '                       ; Space
    1135   00:45D0  CD A2 00                call    CHPUT
    1136   00:45D3  06 18                   ld  b,24                        ; Cuts AP names > 23 chars
    1137   00:45D5                      PRT_APNAMELP:
    1138   00:45D5  7E                      ld  a,(hl)
    1139   00:45D6  B7                      or  a
    1140   00:45D7  CA F1 45                jp  z,PRT_APENC
    1141   00:45DA  CD A2 00                call    CHPUT
    1142   00:45DD  23                      inc hl
    1143   00:45DE  10 F5                   djnz    PRT_APNAMELP
    1144   00:45E0  E5                      push    hl
    1145   00:45E1  21 A9 64                ld  hl,SCAN_TERMINATOR_CUT
    1146   00:45E4  CD 86 4C                call    PRINTHL
    1147   00:45E7  E1                      pop hl
    1148   00:45E8                      PRT_APNAMELP_CUT:
    1149   00:45E8  7E                      ld  a,(hl)
    1150   00:45E9  B7                      or  a
    1151   00:45EA  CA F1 45                jp  z,PRT_APENC
    1152   00:45ED  23                      inc hl
    1153   00:45EE  C3 E8 45                jp  PRT_APNAMELP_CUT
    1154   00:45F1                      PRT_APENC:
    1155   00:45F1  23                      inc hl
    1156   00:45F2  7E                      ld  a,(hl)
    1157   00:45F3  B7                      or  a
    1158   00:45F4  CA 02 46                jp  z,PRT_APNOTENC
    1159   00:45F7  E5                      push    hl
    1160   00:45F8  21 B7 64                ld  hl,SCAN_TERMINATOR_ENC
    1161   00:45FB  CD 86 4C                call    PRINTHL
    1162   00:45FE  E1                      pop hl
    1163   00:45FF  C3 0A 46                jp  PRT_AP_CHKLOOP
    1164   00:4602                      PRT_APNOTENC:
    1165   00:4602  E5                      push    hl
    1166   00:4603  21 B0 64                ld  hl,SCAN_TERMINATOR_OPEN
    1167   00:4606  CD 86 4C                call    PRINTHL
    1168   00:4609  E1                      pop hl
    1169   00:460A                      PRT_AP_CHKLOOP:
    1170   00:460A  23                      inc hl
    1171   00:460B  1C                      inc e
    1172   00:460C  3E 08                   ld  a,SCAN_MAX_PAGE_SIZE
    1173   00:460E  BB                      cp  e
    1174   00:460F  CA 1A 46                jp  z,APLIST_OVERFLOW
    1175   00:4612  15                      dec d
    1176   00:4613  C2 BE 45                jp  nz,WIFI_LIST_LOOP
    1177   00:4616  06 00                   ld  b,0                         ; Signal no more list data
    1178   00:4618  18 10                   jr  APLIST_NO_OVERFLOW
    1179   00:461A                      APLIST_OVERFLOW:
    1180   00:461A  15                      dec d                           ; Update remaining items
    1181   00:461B  AF                      xor a
    1182   00:461C  B2                      or  d                           ; Still has items?
    1183   00:461D  28 0B                   jr  z,APLIST_NO_OVERFLOW        ; No more items
    1184   00:461F  06 01                   ld  b,1                         ; Signal that there still is data pending to list in another page
    1185   00:4621  E5                      push    hl
    1186   00:4622  FD E1                   pop iy                          ; Save in IY the address to continue from
    1187   00:4624  4A                      ld  c,d                         ; And C has the remaining AP count
    1188   00:4625  21 3A 64                ld  hl,MMENU_SCANQM
    1189   00:4628  18 03                   jr  APLIST_NOFLW
    1190   00:462A                      APLIST_NO_OVERFLOW:
    1191   00:462A                          ; If here, current page has been printed
    1192   00:462A                          ; E has the maximum allowable AP number
    1193   00:462A                          ; B will indicate if there are more items for a next page
    1194   00:462A                          ; IY will hold the address of the following items
    1195   00:462A                          ; Let's ask which one to connect
    1196   00:462A  21 CF 63                ld  hl,MMENU_SCANQ
    1197   00:462D                      APLIST_NOFLW:
    1198   00:462D  CD 86 4C                call    PRINTHL                 ; Show message asking which network to connect
    1199   00:4630  3E 30                   ld  a,'0'
    1200   00:4632  83                      add a,e
    1201   00:4633  5F                      ld  e,a                         ; To make it easy in the selection screen
    1202   00:4634                      WIFI_SELECT_AP:
    1203   00:4634  CD 9F 00                call    CHGET
    1204   00:4637  FE 1B                   cp  #1b                         ; ESC?
    1205   00:4639  CA 54 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1206   00:463C  FE 20                   cp  #20                         ; Spacebar?
    1207   00:463E  CA 52 46                jp  z,WIFI_SELECT_SPACEBAR      ; Check if re-scan or next page
    1208   00:4641  FE 0D                   cp  CR                          ; ENTER?
    1209   00:4643  CA 5F 46                jp  z,WIFI_CONNECT_ME_CHOOSEN   ; Request AP Name and Password if needed
    1210   00:4646  FE 30                   cp  '0'                         ; Check if A is less than 0
    1211   00:4648  DA F6 47                jp  c,INPUT_WFSAP_BAD_INPUT     ; If it is, ignore
    1212   00:464B  BB                      cp  e                           ; Check if a is greater than what is in E
    1213   00:464C  D2 F6 47                jp  nc,INPUT_WFSAP_BAD_INPUT    ; If it is, ignore
    1214   00:464F  C3 E9 46                jp  WIFI_CONNECT_SELECTION_OK   ; Selection Ok if here
    1215   00:4652                      
    1216   00:4652                      WIFI_SELECT_SPACEBAR:
    1217   00:4652  AF                      xor a
    1218   00:4653  B2                      or  d                           ; D = AP counter
    1219   00:4654  CA 76 45                jp  z,START_WIFI_RESCAN         ; Rescan if no more items
    1220   00:4657                          ; Otherwise, more items, start at IY
    1221   00:4657  FD E5                   push    iy
    1222   00:4659  DD E1                   pop ix                          ; Restore the list from where we finished last time
    1223   00:465B  79                      ld  a,c                         ; Restore the remaining APs to list
    1224   00:465C  C3 B2 45                jp  WIFI_SCAN_SHOW_LIST         ; And show
    1225   00:465F                      
    1226   00:465F                      WIFI_CONNECT_ME_CHOOSEN:
    1227   00:465F  21 11 62                ld  hl,MMENU_MANUALENTRY
    1228   00:4662  CD 86 4C                call    PRINTHL                 ; Show message asking AP details....
    1229   00:4665                          ; IX has the AP list, we don't care, but that address is ours to use to handle SSID Entry
    1230   00:4665  DD E5                   push    ix
    1231   00:4667  E1                      pop hl                          ; HL has the address
    1232   00:4668  0E 00                   ld  c,0                         ; AP name size
    1233   00:466A                      WIFI_CONNECT_MANUAL_ENTRY:
    1234   00:466A  CD 9F 00                call    CHGET
    1235   00:466D  FE 1B                   cp  #1b                         ; ESC?
    1236   00:466F  CA 54 42                jp  z,ESPSETUP                  ; Back to main setup
    1237   00:4672  FE 08                   cp  #08                         ; Backspace?
    1238   00:4674  28 55                   jr  z,WIFI_CONNECT_ME_BS        ; Check if there is something to erase
    1239   00:4676  FE 0D                   cp  #0d                         ; ENTER?
    1240   00:4678  28 68                   jr  z,WIFI_ME_CHECK_INPUT       ; Check if ok
    1241   00:467A                          ; Otherwise it is a digit
    1242   00:467A  77                      ld  (hl),a
    1243   00:467B  79                      ld  a,c
    1244   00:467C  D6 20                   sub 32                          ; SSID maximum is 32 characters
    1245   00:467E  28 EA                   jr  z,WIFI_CONNECT_MANUAL_ENTRY
    1246   00:4680  7E                      ld  a,(hl)
    1247   00:4681  0C                      inc c
    1248   00:4682  23                      inc hl
    1249   00:4683  FE 20                   cp  32
    1250   00:4685  30 04                   jr  nc,WIFI_CONNECT_ME_CHKPRT2  ; Ok, not below space, but is it delete?
    1251   00:4687  3E 3F                   ld  a,'?'                       ; Prints a question mark
    1252   00:4689  18 06                   jr  WIFI_CONNECT_ME_CHKPRTD
    1253   00:468B                      WIFI_CONNECT_ME_CHKPRT2:
    1254   00:468B  FE 7F                   cp  #7f
    1255   00:468D  20 02                   jr  nz,WIFI_CONNECT_ME_CHKPRTD
    1256   00:468F  3E 3F                   ld  a,'?'                       ; Prints a question mark if it is delete
    1257   00:4691                      WIFI_CONNECT_ME_CHKPRTD:
    1258   00:4691  CD A2 00                call    CHPUT                   ; Print a char
    1259   00:4694  C3 6A 46                jp  WIFI_CONNECT_MANUAL_ENTRY
    1260   00:4697                      WIFI_CONNECT_ME_0_TERM:
    1261   00:4697  AF                      xor a
    1262   00:4698  77                      ld  (hl),a
    1263   00:4699  23                      inc hl
    1264   00:469A  E5                      push    hl                      ; Save it
    1265   00:469B  21 72 62                ld  hl,MENU_MANUALENTRY_PWD
    1266   00:469E  CD 86 4C                call    PRINTHL                 ; We are asking if password is needed
    1267   00:46A1  E1                      pop hl                          ; Restore it
    1268   00:46A2  CD 9F 00                call    CHGET                   ; Get key, if Y or y, needed, otherwise not
    1269   00:46A5  CB AF                   res 5,a                         ; Force upper case
    1270   00:46A7  FE 59                   cp  'Y'
    1271   00:46A9  28 08                   jr  z,WIFI_CONNECT_ME_PWD_Y     ; And tell using encryption
    1272   00:46AB  3E 6E                   ld  a,'n'
    1273   00:46AD  CD A2 00                call    CHPUT                   ; Overwrite what was typed with 'n'
    1274   00:46B0  AF                      xor a                           ; Ok, if here, no pwd, so no encryption
    1275   00:46B1  18 07                   jr  WIFI_CONNECT_ME_PWD
    1276   00:46B3                      WIFI_CONNECT_ME_PWD_Y:
    1277   00:46B3  3E 79                   ld  a,'y'
    1278   00:46B5  CD A2 00                call    CHPUT                   ; Print 'y'
    1279   00:46B8  3E 01                   ld  a,1                         ; Do not change flags, pwd needed
    1280   00:46BA                      WIFI_CONNECT_ME_PWD:
    1281   00:46BA  77                      ld  (hl),a                      ; Save if encryption is expected
    1282   00:46BB  DD E5                   push    ix
    1283   00:46BD  E1                      pop hl                          ; HL containing the beginning of SSID name
    1284   00:46BE  3E 0D                   ld  a,#0d
    1285   00:46C0  CD A2 00                call    CHPUT
    1286   00:46C3  3E 0A                   ld  a,#0a
    1287   00:46C5  CD A2 00                call    CHPUT
    1288   00:46C8  C3 0D 47                jp  WIFI_CONNECT_AP_PWDQ        ; And the rest is handled like if menu selected
    1289   00:46CB                      WIFI_CONNECT_ME_BS:
    1290   00:46CB  AF                      xor a
    1291   00:46CC  B9                      cp  c                           ; Has any data to delete?
    1292   00:46CD  28 9B                   jr  z,WIFI_CONNECT_MANUAL_ENTRY ; No
    1293   00:46CF                          ; Yes
    1294   00:46CF  2B                      dec hl                          ; Decrement pointer
    1295   00:46D0  0D                      dec c                           ; Decrement counter
    1296   00:46D1  3E 08                   ld  a,8                         ; Backspace
    1297   00:46D3  CD A2 00                call    CHPUT                   ; Print it
    1298   00:46D6  3E 20                   ld  a,' '                       ; Space
    1299   00:46D8  CD A2 00                call    CHPUT                   ; Print it
    1300   00:46DB  3E 08                   ld  a,8                         ; Backspace
    1301   00:46DD  CD A2 00                call    CHPUT                   ; Print it
    1302   00:46E0  18 88                   jr  WIFI_CONNECT_MANUAL_ENTRY   ; Return
    1303   00:46E2                      WIFI_ME_CHECK_INPUT:
    1304   00:46E2  AF                      xor a
    1305   00:46E3  B9                      cp  c                           ; Has received any data?
    1306   00:46E4  28 84                   jr  z,WIFI_CONNECT_MANUAL_ENTRY ; No
    1307   00:46E6  C3 97 46                jp  WIFI_CONNECT_ME_0_TERM      ; Yes, so handle SSID input termination
    1308   00:46E9                      
    1309   00:46E9                      WIFI_CONNECT_SELECTION_OK:
    1310   00:46E9  CD A2 00                call    CHPUT                   ; Valid input, print it
    1311   00:46EC  1E 30                   ld  e,'0'
    1312   00:46EE  93                      sub a,e                         ; Get in decimal
    1313   00:46EF  5F                      ld  e,a                         ; Back in E
    1314   00:46F0                          ; IX has the AP list, A which one has been selected, now our routine will do it
    1315   00:46F0  3E 0D                   ld  a,#0d
    1316   00:46F2  CD A2 00                call    CHPUT
    1317   00:46F5  3E 0A                   ld  a,#0a
    1318   00:46F7  CD A2 00                call    CHPUT
    1319   00:46FA  DD E5                   push    ix
    1320   00:46FC  E1                      pop hl                          ; put IX in HL
    1321   00:46FD                      WIFI_CONNECT_AP_SRCH:
    1322   00:46FD  7B                      ld  a,e
    1323   00:46FE  B7                      or  a
    1324   00:46FF                      WIFI_CONNECT_AP_SRCH.1:
    1325   00:46FF  CA 0D 47                jp  z,WIFI_CONNECT_AP_PWDQ
    1326   00:4702  7E                      ld  a,(hl)
    1327   00:4703  23                      inc hl
    1328   00:4704  B7                      or  a
    1329   00:4705  C2 FF 46                jp  nz,WIFI_CONNECT_AP_SRCH.1   ; Find string terminator
    1330   00:4708                          ; Found, jump encryption byte
    1331   00:4708  23                      inc hl
    1332   00:4709  1D                      dec e                           ; Decrement selection, if 0 we are done
    1333   00:470A  C2 FF 46                jp  nz,WIFI_CONNECT_AP_SRCH.1
    1334   00:470D                      WIFI_CONNECT_AP_PWDQ:
    1335   00:470D                          ; HL has the address of AP name string
    1336   00:470D  54                      ld  d,h
    1337   00:470E  5D                      ld  e,l                         ; Save copy in D
    1338   00:470F  01 00 00                ld  bc,0                        ; BC will have the ap connection data length
    1339   00:4712                      WIFI_CONNECT_APSIZE:
    1340   00:4712  03                      inc bc
    1341   00:4713  1A                      ld  a,(de)
    1342   00:4714  13                      inc de
    1343   00:4715  B7                      or  a
    1344   00:4716  C2 12 47                jp  nz,WIFI_CONNECT_APSIZE      ; Count size, including zero terminator
    1345   00:4719                          ; Check for encryption
    1346   00:4719  1A                      ld  a,(de)
    1347   00:471A  B7                      or  a
    1348   00:471B  CA AC 47                jp  z,WIFI_CONNECT_SENDCMD      ; If no password requested, good to go
    1349   00:471E                          ; Shoot, need to request password, well, let's do it
    1350   00:471E  E5                      push    hl                      ; Save HL
    1351   00:471F  21 8C 63                ld  hl,MMENU_ASKPWD
    1352   00:4722  CD 86 4C                call    PRINTHL                 ; Inform that user need to input PWD
    1353   00:4725  E1                      pop hl                          ; Restore HL
    1354   00:4726  FD 21 00 00             ld  iy,0                        ; IY will help in backspacing
    1355   00:472A  DD 26 01                ld  ixh,1                       ; Start hidden
    1356   00:472D                      WIFI_CONNECT_RCV_PWD:
    1357   00:472D  CD 9F 00                call    CHGET
    1358   00:4730  FE 1B                   cp  #1b                         ; ESC?
    1359   00:4732  CA 54 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1360   00:4735  FE 08                   cp  #08                         ; Backspace?
    1361   00:4737  CA 88 47                jp  z,WIFI_CONNECT_RCV_PWD_BS   ; Check if there is something to erase
    1362   00:473A  FE 0D                   cp  #0d                         ; ENTER?
    1363   00:473C  CA A5 47                jp  z,WIFI_PWD_CHECK_INPUT      ; Check if ok
    1364   00:473F  FE 7F                   cp  #7f                         ; Delete?
    1365   00:4741  CA 74 47                jp  z,WIFI_CONNECT_RCV_PWDH     ; Change password from clear to hidden or vice versa
    1366   00:4744                      WIFI_CONNECT_RCV_PWD_STR:
    1367   00:4744                          ; Ok, so it is a digit and store
    1368   00:4744  12                      ld  (de),a
    1369   00:4745  FD 7D                   ld  a,iyl
    1370   00:4747  D6 3F                   sub 63                          ; 63 chars password limit (WPA2 encryption)
    1371   00:4749  28 E2                   jr  z,WIFI_CONNECT_RCV_PWD
    1372   00:474B  1A                      ld  a,(de)
    1373   00:474C  03                      inc bc
    1374   00:474D  13                      inc de
    1375   00:474E  FD 23                   inc iy                          ; Increment counters and pointer
    1376   00:4750  F5                      push    af                      ; Save A
    1377   00:4751  DD 7C                   ld  a,ixh
    1378   00:4753  B7                      or  a                           ; If zero, print char, otherwise print *
    1379   00:4754  28 09                   jr  z,WIFI_CONNECT_RCV_PWD_CHAR
    1380   00:4756  F1                      pop af
    1381   00:4757  3E 2A                   ld  a,'*'                       ; Print * and keep password hidden
    1382   00:4759  CD A2 00                call    CHPUT
    1383   00:475C  C3 2D 47                jp  WIFI_CONNECT_RCV_PWD        ; And back to receiving digits
    1384   00:475F                      WIFI_CONNECT_RCV_PWD_CHAR:
    1385   00:475F  F1                      pop af
    1386   00:4760  FE 20                   cp  32
    1387   00:4762  30 04                   jr  nc,WIFI_CONNECT_RCV_CHKPRT2 ; Ok, not below space, but is it delete?
    1388   00:4764  3E 3F                   ld  a,'?'                       ; Prints a question mark
    1389   00:4766  18 06                   jr  WIFI_CONNECT_RCV_CHKPRTD
    1390   00:4768                      WIFI_CONNECT_RCV_CHKPRT2:
    1391   00:4768  FE 7F                   cp  #7f
    1392   00:476A  20 02                   jr  nz,WIFI_CONNECT_RCV_CHKPRTD
    1393   00:476C  3E 3F                   ld  a,'?'                       ; Prints a question mark if it is delete
    1394   00:476E                      WIFI_CONNECT_RCV_CHKPRTD:
    1395   00:476E  CD A2 00                call    CHPUT                   ; Print a char
    1396   00:4771  C3 2D 47                jp  WIFI_CONNECT_RCV_PWD        ; And back to receiving digits
    1397   00:4774                      
    1398   00:4774                      WIFI_CONNECT_RCV_PWDH:
    1399   00:4774  FD 7D                   ld  a,iyl
    1400   00:4776  FD B4                   or  iyh
    1401   00:4778  C2 44 47                jp  nz,WIFI_CONNECT_RCV_PWD_STR ; If digits entered, can't change password behavior, so it is a pass phrase char
    1402   00:477B  AF                      xor a
    1403   00:477C  DD B4                   or  ixh
    1404   00:477E  DD 26 01                ld  ixh,1
    1405   00:4781  28 AA                   jr  z,WIFI_CONNECT_RCV_PWD      ; Return if it was 0
    1406   00:4783  DD 26 00                ld  ixh,0
    1407   00:4786  28 A5                   jr  z,WIFI_CONNECT_RCV_PWD      ; Otherwise set to 0 and return
    1408   00:4788                      
    1409   00:4788                      WIFI_CONNECT_RCV_PWD_BS:
    1410   00:4788  FD 7D                   ld  a,iyl
    1411   00:478A  FD B4                   or  iyh
    1412   00:478C  CA 2D 47                jp  z,WIFI_CONNECT_RCV_PWD      ; If no digits entered, nothing to erase
    1413   00:478F  FD 2B                   dec iy                          ; Decrement counter
    1414   00:4791  0B                      dec bc                          ; Decrement counter
    1415   00:4792  1B                      dec de                          ; Decrement pointer
    1416   00:4793  3E 08                   ld  a,8                         ; Backspace
    1417   00:4795  CD A2 00                call    CHPUT                   ; Print it
    1418   00:4798  3E 20                   ld  a,' '                       ; Space
    1419   00:479A  CD A2 00                call    CHPUT                   ; Print it
    1420   00:479D  3E 08                   ld  a,8                         ; Backspace
    1421   00:479F  CD A2 00                call    CHPUT                   ; Print it
    1422   00:47A2  C3 2D 47                jp  WIFI_CONNECT_RCV_PWD        ; Return
    1423   00:47A5                      
    1424   00:47A5                      WIFI_PWD_CHECK_INPUT:
    1425   00:47A5  FD 7D                   ld  a,iyl
    1426   00:47A7  FD B4                   or  iyh
    1427   00:47A9  CA 2D 47                jp  z,WIFI_CONNECT_RCV_PWD      ; If no digits entered, no password to send
    1428   00:47AC                          ; Otherwise done and ready to send
    1429   00:47AC                      WIFI_CONNECT_SENDCMD:
    1430   00:47AC  CD FF 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1431   00:47AF  E5                      push    hl
    1432   00:47B0  21 48 63                ld  HL,MMENU_CONNECTING
    1433   00:47B3  CD 86 4C                call    PRINTHL
    1434   00:47B6  E1                      pop hl
    1435   00:47B7                          ; Print AP name
    1436   00:47B7  E5                      push    hl
    1437   00:47B8  CD 90 4C                call    PRINTHLINE              ; Print AP Name
    1438   00:47BB  E1                      pop hl
    1439   00:47BC                          ; HL has the address of our data, BC the data size, so it is just needed to send the command
    1440   00:47BC                          CLEAR_UART
    1440   00:47BC  3E 14             >     ld  a,20
    1440   00:47BE  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1441   00:47C1  3E 41                   ld  a,CMD_WIFI_CONNECT
    1442   00:47C3                          SEND_DATA
    1442   00:47C3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1443   00:47C6  78                      ld  a,b                         ; Size MSB is in B
    1444   00:47C7                          SEND_DATA
    1444   00:47C7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1445   00:47CA  79                      ld  a,c                         ; Size LSB is in c
    1446   00:47CB                          SEND_DATA
    1446   00:47CB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1447   00:47CE                      WIFI_CONNECT_SENDCMDLP:
    1448   00:47CE  7E                      ld  a,(hl)
    1449   00:47CF                          SEND_DATA
    1449   00:47CF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1450   00:47D2  23                      inc hl
    1451   00:47D3  0B                      dec bc
    1452   00:47D4  78                      ld  a,b
    1453   00:47D5  B1                      or  c
    1454   00:47D6  C2 CE 47                jp  nz,WIFI_CONNECT_SENDCMDLP
    1455   00:47D9  21 58 02                ld  hl,600                      ; Wait Up To 10s
    1456   00:47DC  3E 41                   ld  a,CMD_WIFI_CONNECT          ; Our command
    1457   00:47DE  CD 21 4B                call    WAIT_MENU_QCMD_RESPONSE
    1458   00:47E1  CA ED 47                jp  z,WIFI_CONNECT_FAIL
    1459   00:47E4  21 ED 67                ld  hl,STR_SENDING_OK_JN        ; Success
    1460   00:47E7  CD 86 4C                call    PRINTHL
    1461   00:47EA  C3 F7 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1462   00:47ED                      WIFI_CONNECT_FAIL:
    1463   00:47ED  21 0F 68                ld  hl,STR_SENDING_NOK_JN       ; Failure
    1464   00:47F0  CD 86 4C                call    PRINTHL
    1465   00:47F3  C3 F3 49                jp  WAIT_4S_AND_THEN_MAINMENU
    1466   00:47F6                      
    1467   00:47F6                      INPUT_WFSAP_BAD_INPUT:
    1468   00:47F6  C5                      push    bc
    1469   00:47F7  D5                      push    de
    1470   00:47F8  F5                      push    af
    1471   00:47F9  E5                      push    hl
    1472   00:47FA  DD E5                   push    ix
    1473   00:47FC  FD E5                   push    iy
    1474   00:47FE  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1475   00:4801  FD E1                   pop iy
    1476   00:4803  DD E1                   pop ix
    1477   00:4805  E1                      pop hl
    1478   00:4806  F1                      pop af
    1479   00:4807  D1                      pop de
    1480   00:4808  C1                      pop bc
    1481   00:4809  C3 34 46                jp WIFI_SELECT_AP               ; Return
    1482   00:480C                      
    1483   00:480C                      WIFI_SCAN_NONETWORKS:
    1484   00:480C  21 FB 62                ld  hl,MMENU_SCANN
    1485   00:480F  CD 86 4C                call    PRINTHL
    1486   00:4812  C3 F3 49                jp  WAIT_4S_AND_THEN_MAINMENU
    1487   00:4815                      
    1488   00:4815                      WIFI_SCAN_TIMEOUT:
    1489   00:4815  21 DB 62                ld  hl,MMENU_SCANF
    1490   00:4818  CD 86 4C                call    PRINTHL
    1491   00:481B  C3 F3 49                jp  WAIT_4S_AND_THEN_MAINMENU
    1492   00:481E                      
    1493   00:481E                      SET_WIFI_TIMEOUT:
    1494   00:481E  3E 32                   ld  a,'2'
    1495   00:4820  CD A2 00                call    CHPUT
    1496   00:4823  CD FF 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1497   00:4826  21 BE 64                ld  hl,MMENU_TIMEOUT
    1498   00:4829  CD 86 4C                call    PRINTHL                 ; Print Main Timeout message
    1499   00:482C  CD 70 4A                call    CHECKTIMEOUT            ; TimeOut is on or off?
    1500   00:482F  CA 47 48                jp  z,WIFI_SET_ALWAYS_ON        ; If 0, always on
    1501   00:4832                          ; Otherwise there is a timeout
    1502   00:4832  E5                      push    hl
    1503   00:4833  21 F5 65                ld hl,MMENU_TIMEOUT_NOTALWAYSON1
    1504   00:4836  CD 86 4C                call    PRINTHL
    1505   00:4839  E1                      pop hl
    1506   00:483A  CD 86 4C                call    PRINTHL
    1507   00:483D  21 0B 66                ld hl,MMENU_TIMEOUT_NOTALWAYSON2
    1508   00:4840  CD 86 4C                call    PRINTHL
    1509   00:4843  16 00                   ld  d,0                         ; Count digits
    1510   00:4845  18 10                   jr  INPUT_TIMEOUT
    1511   00:4847                      WIFI_SET_ALWAYS_ON:
    1512   00:4847  21 A0 65                ld  hl,MMENU_TIMEOUT_ALWAYSON
    1513   00:484A  CD 86 4C                call    PRINTHL
    1514   00:484D  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1515   00:4851  DD 6B                   ld  ixl,e
    1516   00:4853  DD 62                   ld  ixh,d                       ; Address in IX
    1517   00:4855  16 00                   ld  d,0                         ; Count digits
    1518   00:4857                      INPUT_TIMEOUT:
    1519   00:4857  CD 9F 00                call    CHGET
    1520   00:485A  FE 1B                   cp  #1b                         ; ESC?
    1521   00:485C  CA 54 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1522   00:485F  FE 0D                   cp  #0d                         ; ENTER?
    1523   00:4861  CA A5 48                jp  z,SET_WIFI_CHECK_INPUT      ; Check if ok
    1524   00:4864  FE 08                   cp  #08                         ; Backspace?
    1525   00:4866  CA 8B 48                jp  z,SET_WIFI_BS_INPUT         ; Check if there is something to erase
    1526   00:4869  FE 30                   cp  '0'                         ; Check if A is less than 0
    1527   00:486B  DA 85 48                jp  c,INPUT_TIMEOUT_BAD_INPUT   ; if it is, ignore
    1528   00:486E  FE 3A                   cp  '9'+1                       ; Check if a is greater than  9
    1529   00:4870  D2 85 48                jp  nc,INPUT_TIMEOUT_BAD_INPUT  ; If it is, ignore
    1530   00:4873  DD 77 00                ld  (ix+0),a                    ; Save it
    1531   00:4876  CD A2 00                call    CHPUT                   ; It is valid, so print it
    1532   00:4879  14                      inc d                           ; Increment digit count
    1533   00:487A  DD 23                   inc ix                          ; Increment pointer
    1534   00:487C  3E 03                   ld  a,3
    1535   00:487E  BA                      cp  d
    1536   00:487F  CA A5 48                jp  z,SET_WIFI_CHECK_INPUT      ; All we can do is accept up to 3 digits, check if ok
    1537   00:4882  C3 57 48                jp  INPUT_TIMEOUT               ; Not done yet, so continue
    1538   00:4885                      
    1539   00:4885                      INPUT_TIMEOUT_BAD_INPUT:
    1540   00:4885  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1541   00:4888  C3 57 48                jp INPUT_TIMEOUT                ; Return
    1542   00:488B                      
    1543   00:488B                      SET_WIFI_BS_INPUT:
    1544   00:488B  AF                      xor a
    1545   00:488C  B2                      or  d                           ; Counter has any digit?
    1546   00:488D  CA 57 48                jp  z,INPUT_TIMEOUT             ; Nope, so just continue
    1547   00:4890  15                      dec d                           ; Decrement counter
    1548   00:4891  DD 2B                   dec ix                          ; Decrement pointer
    1549   00:4893  3E 08                   ld  a,8                         ; Backspace
    1550   00:4895  CD A2 00                call    CHPUT                   ; Print it
    1551   00:4898  3E 20                   ld  a,' '                       ; Space
    1552   00:489A  CD A2 00                call    CHPUT                   ; Print it
    1553   00:489D  3E 08                   ld  a,8                         ; Backspace
    1554   00:489F  CD A2 00                call    CHPUT                   ; Print it
    1555   00:48A2  C3 57 48                jp  INPUT_TIMEOUT               ; Return
    1556   00:48A5                      
    1557   00:48A5                      SET_WIFI_CHECK_INPUT:
    1558   00:48A5  AF                      xor a
    1559   00:48A6  B2                      or  d                           ; Counter has any digits
    1560   00:48A7  CA 57 48                jp  z,INPUT_TIMEOUT             ; Nope, so just continue
    1561   00:48AA                          ; IX is pointing one position after last digit, so revert
    1562   00:48AA  DD 2B                   dec ix
    1563   00:48AC  DD 7E 00                ld  a,(ix+0)                    ; Digit in A
    1564   00:48AF  D6 30                   sub '0'                         ; Convert it to decimal
    1565   00:48B1  26 00                   ld  h,0                         ; First digit, so H is 0
    1566   00:48B3  6F                      ld  l,a                         ; And L has the digit
    1567   00:48B4  15                      dec d                           ; If digits finished, just set
    1568   00:48B5  CA E1 48                jp  z,SET_WIFI_EXECUTE_SET_COMMAND
    1569   00:48B8  DD 2B                   dec ix
    1570   00:48BA  DD 7E 00                ld  a,(ix+0)                    ; Digit in A
    1571   00:48BD  D6 30                   sub '0'                         ; Convert it to decimal
    1572   00:48BF  87                      add a,a                         ; A*2
    1573   00:48C0  4F                      ld  c,a                         ; A*2 in C
    1574   00:48C1  87                      add a,a                         ; A*4
    1575   00:48C2  87                      add a,a                         ; A*8
    1576   00:48C3  81                      add a,c                         ; A*10
    1577   00:48C4                          ; Up to here, we can get 90 + 9, 99, won't go to H anyway, just add to L
    1578   00:48C4  85                      add a,l                         ; L has the first digit
    1579   00:48C5  6F                      ld  l,a                         ; And now L has the two digits
    1580   00:48C6  15                      dec d                           ; If digits finished, just set
    1581   00:48C7  CA E1 48                jp  z,SET_WIFI_EXECUTE_SET_COMMAND
    1582   00:48CA  DD 2B                   dec ix
    1583   00:48CC  DD 7E 00                ld  a,(ix+0)                    ; Digit in A
    1584   00:48CF  D6 30                   sub '0'                         ; Convert it to decimal
    1585   00:48D1  87                      add a,a                         ; A*2
    1586   00:48D2  4F                      ld  c,a                         ; A*2 in C
    1587   00:48D3  87                      add a,a                         ; A*4
    1588   00:48D4  87                      add a,a                         ; A*8
    1589   00:48D5  81                      add a,c                         ; A*10
    1590   00:48D6  EB                      ex  de,hl                       ; Get the two digits results in de
    1591   00:48D7  6F                      ld  l,a
    1592   00:48D8  26 00                   ld  h,0                         ; HL = A*10
    1593   00:48DA  29                      add hl,hl                       ; HL = A*20
    1594   00:48DB  4D                      ld  c,l
    1595   00:48DC  44                      ld  b,h                         ; BC = A*20
    1596   00:48DD  29                      add hl,hl                       ; HL = A*40
    1597   00:48DE  29                      add hl,hl                       ; HL = A*80
    1598   00:48DF  09                      add hl,bc                       ; HL = A*100
    1599   00:48E0  19                      add hl,de                       ; HL = three digits result
    1600   00:48E1                          ; This was the last digit, up to three
    1601   00:48E1                      SET_WIFI_EXECUTE_SET_COMMAND:
    1602   00:48E1  C3 33 49                jp  SET_ESP_WIFI_TIMEOUT        ; And set and done
    1603   00:48E4                      
    1604   00:48E4                      ;============================
    1605   00:48E4                      ;===  SETUP Menu Routines  ==
    1606   00:48E4                      ;===      NAGLE Menu       ==
    1607   00:48E4                      ;============================
    1608   00:48E4                      SET_NAGLE:
    1609   00:48E4  3E 31                   ld  a,'1'
    1610   00:48E6  CD A2 00                call    CHPUT
    1611   00:48E9  CD FF 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1612   00:48EC  21 43 66                ld  hl,MMENU_NAGLE
    1613   00:48EF  CD 86 4C                call    PRINTHL                 ; Print Main Nagle message
    1614   00:48F2  CD 22 4A                call    CHECKNAGLE              ; Nagle is on or off?
    1615   00:48F5  20 1E                   jr  nz,NAGLE_IS_ON              ;
    1616   00:48F7  21 78 67                ld  hl,MMENU_NAGLE_OFF          ; Show the menu telling nagle is off
    1617   00:48FA  CD 86 4C                call    PRINTHL                 ; Print options
    1618   00:48FD                      SET_NAGLE_WI_ON:
    1619   00:48FD  CD 9F 00                call    CHGET
    1620   00:4900  FE 1B                   cp  #1b                         ; ESC?
    1621   00:4902  CA 54 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1622   00:4905  FE 4F                   cp  'O'                         ; Toggle Nagle On
    1623   00:4907  CA C2 49                jp  z,SET_NAGLE_ON              ;
    1624   00:490A  FE 6F                   cp  'o'                         ; Toggle Nagle On
    1625   00:490C  CA C2 49                jp  z,SET_NAGLE_ON              ;
    1626   00:490F  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1627   00:4912  C3 FD 48                jp  SET_NAGLE_WI_ON             ; And return waiting key
    1628   00:4915                      
    1629   00:4915                      NAGLE_IS_ON:
    1630   00:4915  21 38 67                ld  hl,MMENU_NAGLE_ON           ; Show the menu telling nagle is on
    1631   00:4918  CD 86 4C                call    PRINTHL                 ; Print options
    1632   00:491B                      SET_NAGLE_WI_OFF:
    1633   00:491B  CD 9F 00                call    CHGET
    1634   00:491E  FE 1B                   cp  #1b                         ; ESC?
    1635   00:4920  CA 54 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1636   00:4923  FE 4F                   cp  'O'                         ; Toggle Nagle Off
    1637   00:4925  CA 73 49                jp  z,SET_NAGLE_OFF             ;
    1638   00:4928  FE 6F                   cp  'o'                         ; Toggle Nagle Off
    1639   00:492A  CA 73 49                jp  z,SET_NAGLE_OFF             ;
    1640   00:492D  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1641   00:4930  C3 1B 49                jp  SET_NAGLE_WI_OFF            ; And return waiting key
    1642   00:4933                      
    1643   00:4933                      ;============================
    1644   00:4933                      ;===  SETUP Menu Routines  ==
    1645   00:4933                      ;===  Auxiliary Functions  ==
    1646   00:4933                      ;============================
    1647   00:4933                      SET_ESP_WIFI_TIMEOUT:
    1648   00:4933  EB                      ex  de,hl
    1649   00:4934  3E 0D                   ld  a,#0d
    1650   00:4936  CD A2 00                call    CHPUT
    1651   00:4939  3E 0A                   ld  a,#0a
    1652   00:493B  CD A2 00                call    CHPUT
    1653   00:493E  21 B9 67                ld  hl,STR_SENDING              ; Indicate it is sending a command
    1654   00:4941  CD 86 4C                call    PRINTHL
    1655   00:4944                          CLEAR_UART
    1655   00:4944  3E 14             >     ld  a,20
    1655   00:4946  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1656   00:4949  3E 54                   ld  a,CMD_TIMER_SET
    1657   00:494B                          SEND_DATA
    1657   00:494B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1658   00:494E  AF                      xor a                           ; Size MSB is 0
    1659   00:494F                          SEND_DATA
    1659   00:494F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1660   00:4952  3E 02                   ld  a,2                         ; Size LSB is 2
    1661   00:4954                          SEND_DATA
    1661   00:4954  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1662   00:4957  7A                      ld  a,d                         ; Timeout MSB
    1663   00:4958                          SEND_DATA
    1663   00:4958  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1664   00:495B  7B                      ld  a,e                         ; Timeout LSB
    1665   00:495C                          SEND_DATA
    1665   00:495C  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1666   00:495F  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1667   00:4962  3E 54                   ld  a,CMD_TIMER_SET             ; Our command
    1668   00:4964  CD 21 4B                call    WAIT_MENU_QCMD_RESPONSE
    1669   00:4967  CA 18 4B                jp  z,MENU_BAD_END
    1670   00:496A  21 D4 67                ld  hl,STR_SENDING_OK           ; Success
    1671   00:496D  CD 86 4C                call    PRINTHL
    1672   00:4970  C3 F7 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1673   00:4973                      
    1674   00:4973                      SET_NAGLE_OFF:
    1675   00:4973  3E 4F                   ld  a,'O'
    1676   00:4975  CD A2 00                call    CHPUT
    1677   00:4978  3E 0D                   ld  a,#0d
    1678   00:497A  CD A2 00                call    CHPUT
    1679   00:497D  3E 0A                   ld  a,#0a
    1680   00:497F  CD A2 00                call    CHPUT
    1681   00:4982  21 B9 67                ld  hl,STR_SENDING              ; Indicate it is sending a command
    1682   00:4985  CD 86 4C                call    PRINTHL
    1683   00:4988                          CLEAR_UART
    1683   00:4988  3E 14             >     ld  a,20
    1683   00:498A  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1684   00:498D  3E 4E                   ld  a,CMD_NAGLE_OFF
    1685   00:498F                          SEND_DATA
    1685   00:498F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1686   00:4992  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1687   00:4995  CD 21 4B                call    WAIT_MENU_QCMD_RESPONSE
    1688   00:4998  CA 18 4B                jp  z,MENU_BAD_END
    1689   00:499B  21 D4 67                ld  hl,STR_SENDING_OK           ; Success
    1690   00:499E  CD 86 4C                call    PRINTHL
    1691   00:49A1  C3 F7 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1692   00:49A4                      
    1693   00:49A4                      STARTWIFISCAN:
    1694   00:49A4                          CLEAR_UART
    1694   00:49A4  3E 14             >     ld  a,20
    1694   00:49A6  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1695   00:49A9  3E 53                   ld  a,CMD_SCAN_START
    1696   00:49AB                          SEND_DATA
    1696   00:49AB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1697   00:49AE  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1698   00:49B1  CD 21 4B                call    WAIT_MENU_QCMD_RESPONSE
    1699   00:49B4  C0                      ret nz                          ; If success return
    1700   00:49B5  3E 0D                   ld  a,CR
    1701   00:49B7  CD A2 00                call    CHPUT
    1702   00:49BA  3E 0A                   ld  a,LF
    1703   00:49BC  CD A2 00                call    CHPUT
    1704   00:49BF  C3 17 4B                jp  MENU_SUB_BAD_END            ; If error, nothing much to do, main menu
    1705   00:49C2                      
    1706   00:49C2                      SET_NAGLE_ON:
    1707   00:49C2  3E 4F                   ld  a,'O'
    1708   00:49C4  CD A2 00                call    CHPUT
    1709   00:49C7  3E 0D                   ld  a,#0d
    1710   00:49C9  CD A2 00                call    CHPUT
    1711   00:49CC  3E 0A                   ld  a,#0a
    1712   00:49CE  CD A2 00                call    CHPUT
    1713   00:49D1  21 B9 67                ld  hl,STR_SENDING              ; Indicate it is sending a command
    1714   00:49D4  CD 86 4C                call    PRINTHL
    1715   00:49D7                          CLEAR_UART
    1715   00:49D7  3E 14             >     ld  a,20
    1715   00:49D9  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1716   00:49DC  3E 44                   ld  a,CMD_NAGLE_ON
    1717   00:49DE                          SEND_DATA
    1717   00:49DE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1718   00:49E1  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1719   00:49E4  CD 21 4B                call    WAIT_MENU_QCMD_RESPONSE
    1720   00:49E7  CA 18 4B                jp  z,MENU_BAD_END
    1721   00:49EA  21 D4 67                ld  hl,STR_SENDING_OK           ; Success
    1722   00:49ED  CD 86 4C                call    PRINTHL
    1723   00:49F0  C3 F7 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1724   00:49F3                      
    1725   00:49F3                      WAIT_4S_AND_THEN_MAINMENU:
    1726   00:49F3  3E F0                   ld  a,240                       ; Wait 4 seconds with message on screen
    1727   00:49F5  18 02                   jr  WAIT_AND_THEN_MAINMENU
    1728   00:49F7                      WAIT_2S_AND_THEN_MAINMENU:
    1729   00:49F7  3E 78                   ld  a,120                       ; Wait 2 seconds with message on screen
    1730   00:49F9                      WAIT_AND_THEN_MAINMENU:
    1731   00:49F9  CD 01 4A                call    WAIT_BEFORE_CONTINUING
    1732   00:49FC  C3 54 42                jp  ESPSETUP                    ; When done, back to main setup
    1733   00:49FF                      WAIT_250MS_AND_THEN_CONTINUE:
    1734   00:49FF  3E 0F                   ld  a,15                        ; Wait 250 ms then continue
    1735   00:4A01                      WAIT_BEFORE_CONTINUING:
    1736   00:4A01  76                      halt
    1737   00:4A02  3D                      dec a
    1738   00:4A03                          ; If not zero, our time out has not elapsed
    1739   00:4A03  20 FC                   jr  nz,WAIT_BEFORE_CONTINUING
    1740   00:4A05  C9                      ret                             ; Time out and continue
    1741   00:4A06                      
    1742   00:4A06                      ; Check Auto Clock
    1743   00:4A06                      ISCLKAUTO:
    1744   00:4A06                          CLEAR_UART
    1744   00:4A06  3E 14             >     ld  a,20
    1744   00:4A08  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1745   00:4A0B  3E 63                   ld  a,CMD_QUERY_ACLK_SETTINGS
    1746   00:4A0D                          SEND_DATA
    1746   00:4A0D  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1747   00:4A10  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1748   00:4A13  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1749   00:4A17  DD 6B                   ld  ixl,e
    1750   00:4A19  DD 62                   ld  ixh,d                       ; address in IX
    1751   00:4A1B  CD 5E 4B                call    WAIT_MENU_CMD_RESPONSE
    1752   00:4A1E  CA 17 4B                jp  z,MENU_SUB_BAD_END
    1753   00:4A21                          ; Response received, IX+0 and IX+1 has Auto Clock and GMT, A
    1754   00:4A21  C9                      ret
    1755   00:4A22                      
    1756   00:4A22                      ; Check what is the current NAGLE setting
    1757   00:4A22                      CHECKNAGLE:
    1758   00:4A22                          CLEAR_UART
    1758   00:4A22  3E 14             >     ld  a,20
    1758   00:4A24  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1759   00:4A27  3E 51                   ld  a,CMD_QUERY_ESP_SETTINGS
    1760   00:4A29                          SEND_DATA
    1760   00:4A29  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1761   00:4A2C  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1762   00:4A2F  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1763   00:4A33  DD 6B                   ld  ixl,e
    1764   00:4A35  DD 62                   ld  ixh,d                       ; Address in IX
    1765   00:4A37  CD 5E 4B                call    WAIT_MENU_CMD_RESPONSE
    1766   00:4A3A  CA 17 4B                jp  z,MENU_SUB_BAD_END
    1767   00:4A3D                          ; Response received, nagle is the first one, ON: or OFF:
    1768   00:4A3D  3E 4F                   ld  a,'O'
    1769   00:4A3F  DD BE 00                cp  (ix+0)
    1770   00:4A42  C2 17 4B                jp  nz,MENU_SUB_BAD_END
    1771   00:4A45  3E 4E                   ld  a,'N'
    1772   00:4A47  DD BE 01                cp  (ix+1)
    1773   00:4A4A  C2 57 4A                jp  nz,CHECK_NAGLE_OFF
    1774   00:4A4D  3E 3A                   ld  a,':'
    1775   00:4A4F  DD BE 02                cp  (ix+2)
    1776   00:4A52  C2 17 4B                jp  nz,MENU_SUB_BAD_END
    1777   00:4A55  B7                      or  a                           ; It will make it NZ
    1778   00:4A56  C9                      ret
    1779   00:4A57                      CHECK_NAGLE_OFF:
    1780   00:4A57  3E 46                   ld  a,'F'
    1781   00:4A59  DD BE 01                cp  (ix+1)
    1782   00:4A5C  C2 17 4B                jp  nz,MENU_SUB_BAD_END
    1783   00:4A5F  3E 46                   ld  a,'F'
    1784   00:4A61  DD BE 02                cp  (ix+2)
    1785   00:4A64  C2 17 4B                jp  nz,MENU_SUB_BAD_END
    1786   00:4A67  3E 3A                   ld  a,':'
    1787   00:4A69  DD BE 03                cp  (ix+3)
    1788   00:4A6C  C2 17 4B                jp  nz,MENU_SUB_BAD_END
    1789   00:4A6F                          ; Already has zero, so just ret
    1790   00:4A6F  C9                      ret
    1791   00:4A70                      
    1792   00:4A70                      ; Check what is the current TIMEOUT setting, return 0 if always on, otherwise there is a timeout
    1793   00:4A70                      ; Will return a zero terminated string @ HL that can be printed
    1794   00:4A70                      ; Will return the value in DE
    1795   00:4A70                      CHECKTIMEOUT:
    1796   00:4A70                          CLEAR_UART
    1796   00:4A70  3E 14             >     ld  a,20
    1796   00:4A72  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1797   00:4A75  3E 51                   ld  a,CMD_QUERY_ESP_SETTINGS
    1798   00:4A77                          SEND_DATA
    1798   00:4A77  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1799   00:4A7A  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1800   00:4A7D  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1801   00:4A81  DD 6B                   ld  ixl,e
    1802   00:4A83  DD 62                   ld  ixh,d                       ; Address in IX
    1803   00:4A85  CD 5E 4B                call    WAIT_MENU_CMD_RESPONSE
    1804   00:4A88  CA 17 4B                jp  z,MENU_SUB_BAD_END
    1805   00:4A8B                          ; Response received, nagle is the first one, ON: or OFF:
    1806   00:4A8B  3E 3A                   ld  a,':'
    1807   00:4A8D  DD 23                   inc ix
    1808   00:4A8F  DD 23                   inc ix                          ; Nagle response is two or three bytes long, let's check
    1809   00:4A91  0B                      dec bc
    1810   00:4A92  0B                      dec bc                          ; Remaining bytes
    1811   00:4A93  DD BE 00                cp  (ix+0)
    1812   00:4A96  CA A2 4A                jp  z,CHECKTIMEOUT.1
    1813   00:4A99  DD 23                   inc ix
    1814   00:4A9B  0B                      dec bc                          ; Remaining bytes
    1815   00:4A9C  DD BE 00                cp  (ix+0)
    1816   00:4A9F  C2 17 4B                jp  nz,MENU_SUB_BAD_END         ; If not here, sorry to say it is an error
    1817   00:4AA2                      CHECKTIMEOUT.1:
    1818   00:4AA2  78                      ld  a,b
    1819   00:4AA3  B1                      or  c                           ; All data read?
    1820   00:4AA4  CA 17 4B                jp  z,MENU_SUB_BAD_END          ; If so, sorry to say it is an error
    1821   00:4AA7  DD 23                   inc ix                          ; At the first digit
    1822   00:4AA9  0B                      dec bc                          ; Remaining bytes
    1823   00:4AAA  78                      ld  a,b
    1824   00:4AAB  B1                      or  c                           ; All data read?
    1825   00:4AAC  CA 17 4B                jp  z,MENU_SUB_BAD_END          ; If so, sorry to say it is an error
    1826   00:4AAF  DD E5                   push    ix                      ; This is the start of the string, save it
    1827   00:4AB1  26 00                   ld  h,0                         ; No digit so far
    1828   00:4AB3                          ; It can have up to three digits
    1829   00:4AB3                      CHECKTIMEOUT.2:
    1830   00:4AB3  3E 3A                   ld  a,':'
    1831   00:4AB5  DD BE 00                cp  (ix+0)                      ; Check if it is the separator
    1832   00:4AB8  CA D9 4A                jp  z,CHECKTIMEOUT.3            ; If it is routine will follow through
    1833   00:4ABB  DD 7E 00                ld  a,(ix+0)                    ; Get the supposed digit in A
    1834   00:4ABE  2E 3A                   ld  l,'9'+1
    1835   00:4AC0  BD                      cp  l
    1836   00:4AC1  D2 16 4B                jp  nc,MENU_SUB_BAD_END_1S      ; If more than '9', sorry to say it is an error
    1837   00:4AC4  2E 30                   ld  l,'0'
    1838   00:4AC6  BD                      cp  l
    1839   00:4AC7  DA 16 4B                jp  c,MENU_SUB_BAD_END_1S       ; If less than '0', sorry to say it is an error
    1840   00:4ACA  24                      inc h                           ; It is not, so it is a digit
    1841   00:4ACB  3E 03                   ld  a,3
    1842   00:4ACD  BC                      cp  h
    1843   00:4ACE  DA 16 4B                jp  c,MENU_SUB_BAD_END_1S       ; If more than three digits, sorry to say it is an error
    1844   00:4AD1  DD 23                   inc ix                          ; Increase pointer
    1845   00:4AD3  0B                      dec bc                          ; Decrease remaining
    1846   00:4AD4  78                      ld  a,b
    1847   00:4AD5  B1                      or  c                           ; All data read?
    1848   00:4AD6  C2 B3 4A                jp  nz,CHECKTIMEOUT.2           ; Not, so rinse and repeat
    1849   00:4AD9                      CHECKTIMEOUT.3:
    1850   00:4AD9  DD 36 00 00             ld  (ix+0),0                    ; Null terminate string value
    1851   00:4ADD  DD 2B                   dec ix
    1852   00:4ADF  DD 7E 00                ld  a,(ix+0)                    ; 1st Digit in A
    1853   00:4AE2  D6 30                   sub '0'                         ; Convert it to decimal value
    1854   00:4AE4  5F                      ld  e,a
    1855   00:4AE5  16 00                   ld  d,0                         ; DE has first digit
    1856   00:4AE7  25                      dec h                           ; Decrement digit counter
    1857   00:4AE8  28 28                   jr  z,CHECKTIMEOUT.END          ; If all digits, done
    1858   00:4AEA                          ; Now second digit, multiply it by 10 and add to E, even if 90 + 9, still fits E
    1859   00:4AEA  DD 2B                   dec ix
    1860   00:4AEC  DD 7E 00                ld  a,(ix+0)                    ; 2nd Digit
    1861   00:4AEF  D6 30                   sub '0'                         ; Convert it to decimal value
    1862   00:4AF1  87                      add a,a                         ; A has *2
    1863   00:4AF2  4F                      ld  c,a                         ; C has *2
    1864   00:4AF3  87                      add a,a                         ; A has *4
    1865   00:4AF4  87                      add a,a                         ; A has *8
    1866   00:4AF5  81                      add a,c                         ; A has *10
    1867   00:4AF6  83                      add a,e                         ; A has two digits result
    1868   00:4AF7  5F                      ld  e,a                         ; Back to E, DE has two digits results
    1869   00:4AF8  25                      dec h                           ; Decrement digit counter
    1870   00:4AF9  28 17                   jr  z,CHECKTIMEOUT.END          ; If all digits, done
    1871   00:4AFB                          ; Now Third digit, multiply it by 100 and add to DE
    1872   00:4AFB  DD 2B                   dec ix
    1873   00:4AFD  DD 7E 00                ld  a,(ix+0)                    ; 3rd Digit
    1874   00:4B00  D6 30                   sub '0'                         ; Convert it to decimal value
    1875   00:4B02  87                      add a,a                         ; A has *2
    1876   00:4B03  4F                      ld  c,a                         ; C has *2
    1877   00:4B04  87                      add a,a                         ; A has *4
    1878   00:4B05  87                      add a,a                         ; A has *8
    1879   00:4B06  81                      add a,c                         ; A has *10
    1880   00:4B07  26 00                   ld  h,0
    1881   00:4B09  6F                      ld  l,a                         ; HL has *10
    1882   00:4B0A  29                      add hl,hl                       ; HL has *20
    1883   00:4B0B  44                      ld  b,h
    1884   00:4B0C  4D                      ld  c,l                         ; BC has *20
    1885   00:4B0D  29                      add hl,hl                       ; HL has *40
    1886   00:4B0E  29                      add hl,hl                       ; HL has *80
    1887   00:4B0F  09                      add hl,bc                       ; HL has *100
    1888   00:4B10  19                      add hl,de                       ; HL has three digit value
    1889   00:4B11  EB                      ex  de,hl                       ; now in DE
    1890   00:4B12                      CHECKTIMEOUT.END:
    1891   00:4B12  E1                      pop hl                          ; Restore address of string version of time count
    1892   00:4B13  7A                      ld  a,d
    1893   00:4B14  B3                      or  e                           ; Set zero flag according to the time out set
    1894   00:4B15  C9                      ret
    1895   00:4B16                      
    1896   00:4B16                      MENU_SUB_BAD_END_1S:
    1897   00:4B16  F1                      pop af                          ; 1 register was stacked, pop it
    1898   00:4B17                      MENU_SUB_BAD_END:
    1899   00:4B17  F1                      pop af                          ; It was a sub, so clear stack
    1900   00:4B18                      MENU_BAD_END:
    1901   00:4B18  21 51 68                ld  hl,STR_SENDING_FAIL         ; error message
    1902   00:4B1B  CD 86 4C                call    PRINTHL
    1903   00:4B1E  C3 F7 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1904   00:4B21                      
    1905   00:4B21                      ; WAIT an ESP quick command Response
    1906   00:4B21                      ; Inputs:
    1907   00:4B21                      ; A -> Command Code
    1908   00:4B21                      ; HL -> Timeout
    1909   00:4B21                      ;
    1910   00:4B21                      ; Returns:
    1911   00:4B21                      ; Flag Z is zero if failure, non zero if success
    1912   00:4B21                      ;
    1913   00:4B21                      ; Affect:
    1914   00:4B21                      ; AF and HL
    1915   00:4B21                      ;
    1916   00:4B21                      WAIT_MENU_QCMD_RESPONSE:
    1917   00:4B21  D5                      push    de
    1918   00:4B22  57                      ld  d,a                         ; Command to wait in D
    1919   00:4B23                      WAIT_MENU_QCMD_RESPONSE_ST1:
    1920   00:4B23                          LOAD_STS_PORT_IN_A
    1920   00:4B23  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1921   00:4B26  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    1922   00:4B28  C2 58 4B                jp  nz,WAIT_MENU_QCMD_RESPONSE_END_NOK
    1923   00:4B2B  CB 47                   bit 0,a                         ; If nz has data
    1924   00:4B2D  20 08                   jr  nz,WAIT_MENU_QCMD_RESPONSE_ST1.1
    1925   00:4B2F  CD 80 4C                call    HLTIMEOUT
    1926   00:4B32  20 EF                   jr  nz,WAIT_MENU_QCMD_RESPONSE_ST1
    1927   00:4B34  C3 56 4B                jp  WAIT_MENU_QCMD_RESPONSE_END ; If time out waiting, return
    1928   00:4B37                      WAIT_MENU_QCMD_RESPONSE_ST1.1:
    1929   00:4B37                          ; nz, check the data
    1930   00:4B37                          RECEIVE_DATA
    1930   00:4B37  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1931   00:4B3A  BA                      cp  d                           ; Is response of our command?
    1932   00:4B3B  20 E6                   jr  nz,WAIT_MENU_QCMD_RESPONSE_ST1
    1933   00:4B3D                          ; Now get return code, if return code other than 0, it is failure, otherwise success
    1934   00:4B3D                      WAIT_MENU_QCMD_RESPONSE_RC:
    1935   00:4B3D                          CHECK_DATA
    1935   00:4B3D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1935   00:4B40  CB 47             >     bit 0,a
    1936   00:4B42  20 08                   jr  nz,WAIT_MENU_QCMD_RESPONSE_RC.1
    1937   00:4B44  CD 80 4C                call    HLTIMEOUT
    1938   00:4B47  20 F4                   jr  nz,WAIT_MENU_QCMD_RESPONSE_RC
    1939   00:4B49  C3 56 4B                jp  WAIT_MENU_QCMD_RESPONSE_END ; If time-out waiting, return
    1940   00:4B4C                      WAIT_MENU_QCMD_RESPONSE_RC.1:
    1941   00:4B4C                          RECEIVE_DATA
    1941   00:4B4C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1942   00:4B4F  B7                      or  a                           ; 0?
    1943   00:4B50                          ; If not, done
    1944   00:4B50  C2 58 4B                jp  nz,WAIT_MENU_QCMD_RESPONSE_END_NOK
    1945   00:4B53                      WAIT_MENU_QCMD_RESPONSE_END_OK:
    1946   00:4B53  3E 01                   ld  a,1
    1947   00:4B55  B7                      or  a                           ; NZ to indicate success
    1948   00:4B56                      WAIT_MENU_QCMD_RESPONSE_END:
    1949   00:4B56  D1                      pop de
    1950   00:4B57  C9                      ret
    1951   00:4B58                      WAIT_MENU_QCMD_RESPONSE_END_NOK:
    1952   00:4B58  21 00 00                ld  hl,0
    1953   00:4B5B  AF                      xor a
    1954   00:4B5C  D1                      pop de
    1955   00:4B5D  C9                      ret
    1956   00:4B5E                      
    1957   00:4B5E                      ; WAIT an ESP regular command Response
    1958   00:4B5E                      ; Inputs:
    1959   00:4B5E                      ; A -> Command Code
    1960   00:4B5E                      ; HL -> Timeout
    1961   00:4B5E                      ; IX -> Where to store response
    1962   00:4B5E                      ;
    1963   00:4B5E                      ; Returns:
    1964   00:4B5E                      ; Flag Z is zero if failure, non zero if success
    1965   00:4B5E                      ; BC is the response size
    1966   00:4B5E                      ;
    1967   00:4B5E                      ; Affect:
    1968   00:4B5E                      ; AF , BC and HL
    1969   00:4B5E                      WAIT_MENU_CMD_RESPONSE:
    1970   00:4B5E  D5                      push    de
    1971   00:4B5F  DD E5                   push    ix
    1972   00:4B61  57                      ld  d,a                         ; Command to wait in D
    1973   00:4B62                      WAIT_MENU_CMD_RESPONSE_ST1:
    1974   00:4B62                          LOAD_STS_PORT_IN_A
    1974   00:4B62  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1975   00:4B65  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    1976   00:4B67  C2 E6 4B                jp  nz,WAIT_MENU_CMD_RESPONSE_END_NOK
    1977   00:4B6A  CB 47                   bit 0,a                         ; If nz has data
    1978   00:4B6C  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST1.1
    1979   00:4B6E  CD 80 4C                call    HLTIMEOUT
    1980   00:4B71  20 EF                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST1
    1981   00:4B73  C3 E0 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    1982   00:4B76                      WAIT_MENU_CMD_RESPONSE_ST1.1:
    1983   00:4B76                          ; nz, check the data
    1984   00:4B76                          RECEIVE_DATA
    1984   00:4B76  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1985   00:4B79  BA                      cp  d                           ; Is response of our command?
    1986   00:4B7A  20 E6                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST1
    1987   00:4B7C                          ; Now get return code, if return code other than 0, it is finished
    1988   00:4B7C                      WAIT_MENU_CMD_RESPONSE_RC:
    1989   00:4B7C                          CHECK_DATA
    1989   00:4B7C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1989   00:4B7F  CB 47             >     bit 0,a
    1990   00:4B81  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_RC.1
    1991   00:4B83  CD 80 4C                call    HLTIMEOUT
    1992   00:4B86  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_RC
    1993   00:4B88  C3 E0 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    1994   00:4B8B                      WAIT_MENU_CMD_RESPONSE_RC.1:
    1995   00:4B8B                          RECEIVE_DATA
    1995   00:4B8B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1996   00:4B8E  B7                      or  a                           ; 0?
    1997   00:4B8F                          ; If not, done
    1998   00:4B8F  C2 E6 4B                jp  nz,WAIT_MENU_CMD_RESPONSE_END_NOK
    1999   00:4B92                          ; Next two bytes are size bytes, save it to BC
    2000   00:4B92                      WAIT_MENU_CMD_RESPONSE_ST2A:
    2001   00:4B92                          CHECK_DATA
    2001   00:4B92  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2001   00:4B95  CB 47             >     bit 0,a
    2002   00:4B97  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2A.1
    2003   00:4B99  CD 80 4C                call    HLTIMEOUT
    2004   00:4B9C  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2A
    2005   00:4B9E  C3 E0 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    2006   00:4BA1                      WAIT_MENU_CMD_RESPONSE_ST2A.1:
    2007   00:4BA1                          RECEIVE_DATA
    2007   00:4BA1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2008   00:4BA4  47                      ld  b,a
    2009   00:4BA5                      WAIT_MENU_CMD_RESPONSE_ST2B:
    2010   00:4BA5                          CHECK_DATA
    2010   00:4BA5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2010   00:4BA8  CB 47             >     bit 0,a
    2011   00:4BAA  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2B.1
    2012   00:4BAC  CD 80 4C                call    HLTIMEOUT
    2013   00:4BAF  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2B
    2014   00:4BB1  C3 E0 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    2015   00:4BB4                      WAIT_MENU_CMD_RESPONSE_ST2B.1:
    2016   00:4BB4                          RECEIVE_DATA
    2016   00:4BB4  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2017   00:4BB7  4F                      ld  c,a
    2018   00:4BB8  B0                      or  b                           ; Zero size in response?
    2019   00:4BB9  28 1E                   jr  z,WAIT_MENU_CMD_RESPONSE_END_OK
    2020   00:4BBB  50                      ld  d,b
    2021   00:4BBC  59                      ld  e,c                         ; Copy to DE
    2022   00:4BBD                          ; Now loop getting the data until received everything or time-out
    2023   00:4BBD                      WAIT_MENU_CMD_RESPONSE_GET_DATA:
    2024   00:4BBD                          CHECK_DATA
    2024   00:4BBD  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2024   00:4BC0  CB 47             >     bit 0,a
    2025   00:4BC2  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_GET_DATA.1
    2026   00:4BC4  CD 80 4C                call    HLTIMEOUT
    2027   00:4BC7  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_GET_DATA
    2028   00:4BC9  C3 E0 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    2029   00:4BCC                      WAIT_MENU_CMD_RESPONSE_GET_DATA.1:
    2030   00:4BCC                          RECEIVE_DATA            ; Get data
    2030   00:4BCC  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2031   00:4BCF  DD 77 00                ld  (ix+0),a                    ; Put it in the buffer
    2032   00:4BD2  DD 23                   inc ix                          ; Increment pointer
    2033   00:4BD4  1B                      dec de                          ; Decrement counter
    2034   00:4BD5  7A                      ld  a,d
    2035   00:4BD6  B3                      or  e                           ; Is counter 0?
    2036   00:4BD7  20 E4                   jr  nz,WAIT_MENU_CMD_RESPONSE_GET_DATA
    2037   00:4BD9                      WAIT_MENU_CMD_RESPONSE_END_OK:
    2038   00:4BD9  3E 01                   ld  a,1
    2039   00:4BDB  B7                      or  a                           ; NZ to indicate success
    2040   00:4BDC  DD E1                   pop ix
    2041   00:4BDE  D1                      pop de
    2042   00:4BDF  C9                      ret
    2043   00:4BE0                      WAIT_MENU_CMD_RESPONSE_END:
    2044   00:4BE0  06 FF                   ld  b,#FF
    2045   00:4BE2  DD E1                   pop ix
    2046   00:4BE4  D1                      pop de
    2047   00:4BE5  C9                      ret
    2048   00:4BE6                      WAIT_MENU_CMD_RESPONSE_END_NOK:
    2049   00:4BE6  21 00 00                ld  hl,0
    2050   00:4BE9  47                      ld  b,a                         ; Get result in B, 0xFF for time-out, otherwise was an error return code
    2051   00:4BEA  AF                      xor a
    2052   00:4BEB  DD E1                   pop ix
    2053   00:4BED  D1                      pop de
    2054   00:4BEE  C9                      ret
    2055   00:4BEF                      
    2056   00:4BEF                      ; WAIT an ESP Wi-Fi Scan command Response
    2057   00:4BEF                      ; Inputs:
    2058   00:4BEF                      ; A -> Command Code
    2059   00:4BEF                      ; HL -> Timeout
    2060   00:4BEF                      ; IX -> Where to store response
    2061   00:4BEF                      ;
    2062   00:4BEF                      ; Returns:
    2063   00:4BEF                      ; Flag Z is zero if failure, non zero if success
    2064   00:4BEF                      ; A is the number of access points scanned
    2065   00:4BEF                      ;
    2066   00:4BEF                      ; Response is stored as:
    2067   00:4BEF                      ; Access Point SSID zero terminated and after first 0
    2068   00:4BEF                      ; 0 if Open otherwise requires a password to join
    2069   00:4BEF                      ; And this repeats...
    2070   00:4BEF                      ;
    2071   00:4BEF                      ; Affect:
    2072   00:4BEF                      ; AF , BC and HL
    2073   00:4BEF                      ;
    2074   00:4BEF                      WAIT_MENU_SCMD_RESPONSE:
    2075   00:4BEF  D5                      push    de
    2076   00:4BF0  DD E5                   push    ix
    2077   00:4BF2  57                      ld  d,a                         ; Command to wait in D
    2078   00:4BF3                      WAIT_MENU_SCMD_RESPONSE_ST1:
    2079   00:4BF3                          LOAD_STS_PORT_IN_A
    2079   00:4BF3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2080   00:4BF6  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    2081   00:4BF8  C2 77 4C                jp  nz,WAIT_MENU_SCMD_RESPONSE_END_NOK
    2082   00:4BFB  CB 47                   bit 0,a                         ; If nz has data
    2083   00:4BFD  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST1.1
    2084   00:4BFF  CD 80 4C                call    HLTIMEOUT
    2085   00:4C02  20 EF                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST1
    2086   00:4C04  C3 73 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2087   00:4C07                      WAIT_MENU_SCMD_RESPONSE_ST1.1:
    2088   00:4C07                          ; nz, check the data
    2089   00:4C07                          RECEIVE_DATA
    2089   00:4C07  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2090   00:4C0A  BA                      cp  d                           ; Is response of our command?
    2091   00:4C0B  20 E6                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST1
    2092   00:4C0D                          ; Now get return code, if return code other than 0, it is finished
    2093   00:4C0D                      WAIT_MENU_SCMD_RESPONSE_RC:
    2094   00:4C0D                          CHECK_DATA
    2094   00:4C0D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2094   00:4C10  CB 47             >     bit 0,a
    2095   00:4C12  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_RC.1
    2096   00:4C14  CD 80 4C                call    HLTIMEOUT
    2097   00:4C17  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_RC
    2098   00:4C19  C3 73 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2099   00:4C1C                      WAIT_MENU_SCMD_RESPONSE_RC.1:
    2100   00:4C1C                          RECEIVE_DATA
    2100   00:4C1C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2101   00:4C1F  B7                      or  a                           ; 0?
    2102   00:4C20                          ; If not, done
    2103   00:4C20  C2 77 4C                jp  nz,WAIT_MENU_SCMD_RESPONSE_END_NOK
    2104   00:4C23                          ; Next byte is how many access points are available
    2105   00:4C23                      WAIT_MENU_SCMD_RESPONSE_ST2A:
    2106   00:4C23                          CHECK_DATA
    2106   00:4C23  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2106   00:4C26  CB 47             >     bit 0,a
    2107   00:4C28  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2A.1
    2108   00:4C2A  CD 80 4C                call    HLTIMEOUT
    2109   00:4C2D  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2A
    2110   00:4C2F  C3 73 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2111   00:4C32                      WAIT_MENU_SCMD_RESPONSE_ST2A.1:
    2112   00:4C32                          RECEIVE_DATA
    2112   00:4C32  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2113   00:4C35  47                      ld  b,a                         ; Save in B
    2114   00:4C36  4F                      ld  c,a                         ; And C as well
    2115   00:4C37                          ; Now should loop this until c is 0, c will control access point received count
    2116   00:4C37                      WAIT_MENU_SCMD_RESPONSE_ST2B:
    2117   00:4C37                          CHECK_DATA
    2117   00:4C37  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2117   00:4C3A  CB 47             >     bit 0,a
    2118   00:4C3C  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B.1
    2119   00:4C3E  CD 80 4C                call    HLTIMEOUT
    2120   00:4C41  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B
    2121   00:4C43  C3 73 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2122   00:4C46                      WAIT_MENU_SCMD_RESPONSE_ST2B.1:
    2123   00:4C46                          RECEIVE_DATA
    2123   00:4C46  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2124   00:4C49  DD 77 00                ld  (ix+0),a
    2125   00:4C4C  DD 23                   inc ix                          ; Increment pointer
    2126   00:4C4E  B7                      or  a                           ; Terminator of AP Name?
    2127   00:4C4F  20 E6                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B
    2128   00:4C51                          ; Get encryption
    2129   00:4C51                      WAIT_MENU_SCMD_RESPONSE_GET_ENC:
    2130   00:4C51                          CHECK_DATA
    2130   00:4C51  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2130   00:4C54  CB 47             >     bit 0,a
    2131   00:4C56  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_GET_ENC.1
    2132   00:4C58  CD 80 4C                call    HLTIMEOUT
    2133   00:4C5B  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_GET_ENC
    2134   00:4C5D  C3 73 4C                jp  WAIT_MENU_SCMD_RESPONSE_END  ; If time out waiting, return
    2135   00:4C60                      WAIT_MENU_SCMD_RESPONSE_GET_ENC.1:
    2136   00:4C60                          RECEIVE_DATA            ; Get data
    2136   00:4C60  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2137   00:4C63  D6 4F                   sub 'O'                         ; If O, open, will be 0, otherwise, will be notzero
    2138   00:4C65  DD 77 00                ld  (ix+0),a                    ; Put it in the buffer
    2139   00:4C68  DD 23                   inc ix                          ; Increment pointer
    2140   00:4C6A  0D                      dec c                           ; Decrement counter
    2141   00:4C6B  AF                      xor a
    2142   00:4C6C  B1                      or  c                           ; Is counter 0?
    2143   00:4C6D                          ; If not continue getting more SSIDs
    2144   00:4C6D  20 C8                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B
    2145   00:4C6F                          ; It is zero, so, done
    2146   00:4C6F                      WAIT_MENU_SCMD_RESPONSE_END_OK:
    2147   00:4C6F  3E 01                   ld  a,1
    2148   00:4C71  B7                      or  a                           ; NZ to indicate success
    2149   00:4C72  78                      ld  a,b                         ; Number of APs in A
    2150   00:4C73                      WAIT_MENU_SCMD_RESPONSE_END:
    2151   00:4C73  DD E1                   pop ix
    2152   00:4C75  D1                      pop de
    2153   00:4C76  C9                      ret
    2154   00:4C77                      WAIT_MENU_SCMD_RESPONSE_END_NOK:
    2155   00:4C77  21 00 00                ld  hl,0
    2156   00:4C7A  47                      ld  b,a                         ; Return code in B
    2157   00:4C7B  AF                      xor a
    2158   00:4C7C  DD E1                   pop ix
    2159   00:4C7E  D1                      pop de
    2160   00:4C7F  C9                      ret
    2161   00:4C80                      
    2162   00:4C80                      ; This routine will check if HL is 0, if it is, will return immediatelly
    2163   00:4C80                      ; If it is not, will decrease HL value and halt (wait one interrupt)
    2164   00:4C80                      HLTIMEOUT:
    2165   00:4C80  7C                      ld  a,h
    2166   00:4C81  B5                      or  l
    2167   00:4C82  C8                      ret z
    2168   00:4C83  2B                      dec hl
    2169   00:4C84  76                      halt
    2170   00:4C85  C9                      ret
    2171   00:4C86                      
    2172   00:4C86                      ; Routine to print the string addressed by HL
    2173   00:4C86                      PRINTHL:
    2174   00:4C86  7E                      ld  a,(hl)
    2175   00:4C87  B7                      or  a
    2176   00:4C88  C8                      ret z                           ; When string is finished, done!
    2177   00:4C89  CD A2 00                call    CHPUT
    2178   00:4C8C  23                      inc hl
    2179   00:4C8D  C3 86 4C                jp  PRINTHL
    2180   00:4C90                      
    2181   00:4C90                      ; Routine to print the string addressed by HL on a line, if exceeding it, ends with ..
    2182   00:4C90                      PRINTHLINE:
    2183   00:4C90  C5                      push    bc
    2184   00:4C91  06 18                   ld  b,24
    2185   00:4C93                      PHLINEL:
    2186   00:4C93  7E                      ld  a,(hl)
    2187   00:4C94  B7                      or  a
    2188   00:4C95  28 1F                   jr  z,PHLINESPC                 ; When string is finished, done!
    2189   00:4C97  CD A2 00                call    CHPUT
    2190   00:4C9A  23                      inc hl
    2191   00:4C9B  10 F6                   djnz    PHLINEL
    2192   00:4C9D  3E 1D                   ld  a,GOLEFT
    2193   00:4C9F  CD A2 00                call    CHPUT
    2194   00:4CA2  CD A2 00                call    CHPUT
    2195   00:4CA5  3E 01                   ld  a,1
    2196   00:4CA7  CD A2 00                call    CHPUT
    2197   00:4CAA  3E 5B                   ld  a,91
    2198   00:4CAC  CD A2 00                call    CHPUT
    2199   00:4CAF  3E 20                   ld  a,' '
    2200   00:4CB1  CD A2 00                call    CHPUT
    2201   00:4CB4  18 07                   jr  PHLINELR
    2202   00:4CB6                      PHLINESPC:
    2203   00:4CB6  3E 20                   ld  a,' '
    2204   00:4CB8  CD A2 00                call    CHPUT
    2205   00:4CBB  10 F9                   djnz    PHLINESPC
    2206   00:4CBD                      PHLINELR:
    2207   00:4CBD  3E 1D                   ld  a,GOLEFT
    2208   00:4CBF  CD A2 00                call    CHPUT
    2209   00:4CC2  CD A2 00                call    CHPUT
    2210   00:4CC5  C1                      pop bc
    2211   00:4CC6  C9                      ret
    2212   00:4CC7                      
    2213   00:4CC7                      ;===============================
    2214   00:4CC7                      ;===  HTIM_I hook execution  ===
    2215   00:4CC7                      ;===============================
    2216   00:4CC7                      DO_HTIMI:
    2217   00:4CC7  F5                      push    af                      ; HTIM hook -> need to keep A value
    2218   00:4CC8  CD FE 59                call    GETCOUNTER              ; Counter in hl
    2219   00:4CCB  7D                      ld  a,l
    2220   00:4CCC  B4                      or  h                           ; In this operation, check if HL is o
    2221   00:4CCD  28 04                   jr  z,DO_HTIMI_END              ; If it is, nothing to do
    2222   00:4CCF  2B                      dec hl                          ; Otherwise decrement it
    2223   00:4CD0  CD 0D 5A                call    SETCOUNTER              ; And save it
    2224   00:4CD3                      DO_HTIMI_END:
    2225   00:4CD3  CD 6D 59                call    GETSLT
    2226   00:4CD6                          ; Slot in A, now get the address of our counter
    2227   00:4CD6  CD F6 59                call    GETMEMPOINTER
    2228   00:4CD9                          ; HL has the address of our memory area, and there is where we should jump
    2229   00:4CD9  F1                      pop af                          ; Restore original A value
    2230   00:4CDA  E9                      jp  (hl)
    2231   00:4CDB                      
    2232   00:4CDB                      ;===============================
    2233   00:4CDB                      ;===  EXTBIO hook execution  ===
    2234   00:4CDB                      ;===============================
    2235   00:4CDB                      DO_EXTBIO:
    2236   00:4CDB  E5                      push    hl
    2237   00:4CDC  C5                      push    bc
    2238   00:4CDD  F5                      push    af
    2239   00:4CDE  7A                      ld  a,d
    2240   00:4CDF  FE 22                   cp  #22
    2241   00:4CE1  20 43                   jr  nz,JUMP_OLD
    2242   00:4CE3  BB                      cp  e
    2243   00:4CE4  20 40                   jr  nz,JUMP_OLD
    2244   00:4CE6                      
    2245   00:4CE6                          ; Check API ID
    2246   00:4CE6  21 B7 69                ld  hl,UNAPI_ID
    2247   00:4CE9  11 47 F8                ld  de,ARG
    2248   00:4CEC                      LOOP:
    2249   00:4CEC  1A                      ld  a,(de)
    2250   00:4CED  CD 48 5B                call    TOUPPER
    2251   00:4CF0  BE                      cp  (hl)
    2252   00:4CF1  20 30                   jr  nz,JUMP_OLD2
    2253   00:4CF3  23                      inc hl
    2254   00:4CF4  13                      inc de
    2255   00:4CF5  B7                      or  a
    2256   00:4CF6  20 F4                   jr  nz,LOOP
    2257   00:4CF8                      
    2258   00:4CF8                          ; A=255: Jump to old hook
    2259   00:4CF8                      
    2260   00:4CF8  F1                      pop af
    2261   00:4CF9  F5                      push    af
    2262   00:4CFA  3C                      inc a
    2263   00:4CFB  28 26                   jr  z,JUMP_OLD2
    2264   00:4CFD                      
    2265   00:4CFD                          ; A=0: B=B+1 and jump to old hook
    2266   00:4CFD                      
    2267   00:4CFD  CD 6D 59                call    GETSLT
    2268   00:4D00  CD C6 59                call    GETWRK
    2269   00:4D03  F1                      pop af
    2270   00:4D04  C1                      pop bc
    2271   00:4D05  B7                      or  a
    2272   00:4D06  20 06                   jr  nz,DO_EXTBIO2
    2273   00:4D08  04                      inc b
    2274   00:4D09  E3                      ex  (sp),hl
    2275   00:4D0A  11 22 22                ld  de,#2222
    2276   00:4D0D  C9                      ret
    2277   00:4D0E                      
    2278   00:4D0E                      DO_EXTBIO2:
    2279   00:4D0E                          ; A=1: Return A=Slot, B=Segment, HL=UNAPI entry address
    2280   00:4D0E                      
    2281   00:4D0E  3D                      dec a
    2282   00:4D0F  20 0D                   jr  nz,DO_EXTBIO3
    2283   00:4D11  E1                      pop hl
    2284   00:4D12  CD 8D 59                call    GETSLTT                 ; GETSLTT is GETSLT that checks if our memory area @ HIMEM has been allocated, if not, allocate it
    2285   00:4D15  06 FF                   ld  b,#FF
    2286   00:4D17  21 32 4D                ld  hl,UNAPI_ENTRY
    2287   00:4D1A  11 22 22                ld  de,#2222
    2288   00:4D1D  C9                      ret
    2289   00:4D1E                      
    2290   00:4D1E                          ; A>1: A=A-1, and jump to old hook
    2291   00:4D1E                      
    2292   00:4D1E                      DO_EXTBIO3:                         ; A=A-1 already done
    2293   00:4D1E  E3                      ex  (sp),hl
    2294   00:4D1F  11 22 22                ld  de,#2222
    2295   00:4D22  C9                      ret
    2296   00:4D23                      
    2297   00:4D23                      
    2298   00:4D23                      ; Jump here to execute old EXTBIO code
    2299   00:4D23                      JUMP_OLD2:
    2300   00:4D23  11 22 22                ld  de,#2222
    2301   00:4D26                      JUMP_OLD:                           ; Assumes "push hl,bc,af" done
    2302   00:4D26  D5                      push    de
    2303   00:4D27  CD 6D 59                call    GETSLT
    2304   00:4D2A  CD C6 59                call    GETWRK
    2305   00:4D2D  D1                      pop de
    2306   00:4D2E  F1                      pop af
    2307   00:4D2F  C1                      pop bc
    2308   00:4D30  E3                      ex  (sp),hl
    2309   00:4D31  C9                      ret
    2310   00:4D32                      
    2311   00:4D32                      ;====================================
    2312   00:4D32                      ;===  Functions entry point code  ===
    2313   00:4D32                      ;====================================
    2314   00:4D32                      UNAPI_ENTRY:
    2315   00:4D32  FB                      ei
    2316   00:4D33  E5                      push    hl
    2317   00:4D34  F5                      push    af
    2318   00:4D35  21 53 4D                ld  hl,FN_TABLE
    2319   00:4D38  CB 7F                   bit 7,a
    2320   00:4D3A                      
    2321   00:4D3A                          if  MAX_IMPFN >= 128
    2322   00:4D3A                    ~ 
    2323   00:4D3A                    ~     jr  z,IS_STANDARD
    2324   00:4D3A                    ~     ld  hl,IMPFN_TABLE
    2325   00:4D3A                    ~     and %01111111
    2326   00:4D3A                    ~     cp  MAX_IMPFN-128
    2327   00:4D3A                    ~     jr  z,OK_FNUM
    2328   00:4D3A                    ~     jr  nc,UNDEFINED
    2329   00:4D3A                    ~ IS_STANDARD:
    2330   00:4D3A                    ~ 
    2331   00:4D3A                    ~     else
    2332   00:4D3A                      
    2333   00:4D3A  20 14                   jr  nz,UNDEFINED
    2334   00:4D3C                      
    2335   00:4D3C                          endif
    2336   00:4D3C                      
    2337   00:4D3C  FE 1D                   cp  MAX_FN
    2338   00:4D3E  28 02                   jr  z,OK_FNUM
    2339   00:4D40  30 0E                   jr  nc,UNDEFINED
    2340   00:4D42                      
    2341   00:4D42                      OK_FNUM:
    2342   00:4D42  87                      add a,a
    2343   00:4D43  D5                      push    de
    2344   00:4D44  5F                      ld  e,a
    2345   00:4D45  16 00                   ld  d,0
    2346   00:4D47  19                      add hl,de
    2347   00:4D48  D1                      pop de
    2348   00:4D49                      
    2349   00:4D49  7E                      ld  a,(hl)
    2350   00:4D4A  23                      inc hl
    2351   00:4D4B  66                      ld  h,(hl)
    2352   00:4D4C  6F                      ld  l,a
    2353   00:4D4D                      
    2354   00:4D4D  F1                      pop af
    2355   00:4D4E  E3                      ex  (sp),hl
    2356   00:4D4F  C9                      ret
    2357   00:4D50                      
    2358   00:4D50                      ; Undefined function: return with registers unmodified
    2359   00:4D50                      UNDEFINED:
    2360   00:4D50  F1                      pop af
    2361   00:4D51  E1                      pop hl
    2362   00:4D52  C9                      ret
    2363   00:4D53                      
    2364   00:4D53                      ;===================================
    2365   00:4D53                      ;===  Functions addresses table  ===
    2366   00:4D53                      ;===================================
    2367   00:4D53                      ;--- Implementation-specific routines addresses table
    2368   00:4D53                      
    2369   00:4D53                          if  MAX_IMPFN >= 128
    2370   00:4D53                    ~ 
    2371   00:4D53                    ~ IMPFN_TABLE:
    2372   00:4D53                    ~ FN_128:                 dw  FN_DUMMY
    2373   00:4D53                    ~ 
    2374   00:4D53                    ~     endif
    2375   00:4D53                      
    2376   00:4D53                      FN_TABLE:
    2377   00:4D53  A4 4D               FN_0:                   dw  UNAPI_GET_INFO
    2378   00:4D55  AF 4D               FN_1:                   dw  TCPIP_GET_CAPAB
    2379   00:4D57  07 4F               FN_2:                   dw  TCPIP_GET_IPINFO
    2380   00:4D59  96 4F               FN_3:                   dw  TCPIP_NET_STATE
    2381   00:4D5B                      ; TCPIP_SEND_ECHO not going to be implemented, ESP do not support ping like UNAPI specify
    2382   00:4D5B  8F 4D               FN_4:                   dw  FN_NOT_IMP
    2383   00:4D5D                      ; TCPIP_RCV_ECHO not going to be implemented as SEND_ECHO is not implemented
    2384   00:4D5D  8F 4D               FN_5:                   dw  FN_NOT_IMP
    2385   00:4D5F  F0 4F               FN_6:                   dw  TCPIP_DNS_Q
    2386   00:4D61  B1 50               FN_7:                   dw  TCPIP_DNS_S
    2387   00:4D63  DE 50               FN_8:                   dw  TCPIP_UDP_OPEN
    2388   00:4D65  46 51               FN_9:                   dw  TCPIP_UDP_CLOSE
    2389   00:4D67  96 51               FN_10:                  dw  TCPIP_UDP_STATE
    2390   00:4D69  35 52               FN_11:                  dw  TCPIP_UDP_SEND
    2391   00:4D6B  E8 52               FN_12:                  dw  TCPIP_UDP_RCV
    2392   00:4D6D  39 54               FN_13:                  dw  TCPIP_TCP_OPEN
    2393   00:4D6F  0E 55               FN_14:                  dw  TCPIP_TCP_CLOSE
    2394   00:4D71  5E 55               FN_15:                  dw  TCPIP_TCP_ABORT
    2395   00:4D73  D3 55               FN_16:                  dw  TCPIP_TCP_STATE
    2396   00:4D75  0D 57               FN_17:                  dw  TCPIP_TCP_SEND
    2397   00:4D77  B4 57               FN_18:                  dw  TCPIP_TCP_RCV
    2398   00:4D79                      ; TCPIP_TCP_FLUSH makes no sense as we do not use buffers to send, any buffer is internal to ESP and we can't delete
    2399   00:4D79  8F 4D               FN_19:                  dw  FN_NOT_IMP
    2400   00:4D7B                      ; TCPIP_RAW_OPEN not going to be implemented, ESP do not support RAW connections
    2401   00:4D7B  8F 4D               FN_20:                  dw  FN_NOT_IMP
    2402   00:4D7D                      ; TCPIP_RAW_CLOSE not going to be implemented, ESP do not support RAW connections
    2403   00:4D7D  8F 4D               FN_21:                  dw  FN_NOT_IMP
    2404   00:4D7F                      ; TCPIP_RAW_STATE not going to be implemented, ESP do not support RAW connections
    2405   00:4D7F  8F 4D               FN_22:                  dw  FN_NOT_IMP
    2406   00:4D81                      ; TCPIP_RAW_SEND not going to be implemented, ESP do not support RAW connections
    2407   00:4D81  8F 4D               FN_23:                  dw  FN_NOT_IMP
    2408   00:4D83                      ; TCPIP_RAW_RCV not going to be implemented, ESP do not support RAW connections
    2409   00:4D83  8F 4D               FN_24:                  dw  FN_NOT_IMP
    2410   00:4D85  9E 58               FN_25:                  dw  TCPIP_CONFIG_AUTOIP
    2411   00:4D87  02 59               FN_26:                  dw  TCPIP_CONFIG_IP
    2412   00:4D89  4B 59               FN_27:                  dw  TCPIP_CONFIG_TTL
    2413   00:4D8B  5D 59               FN_28:                  dw  TCPIP_CONFIG_PING
    2414   00:4D8D                      ; TCPIP_WAIT not needed for our implementation
    2415   00:4D8D  92 4D               FN_29:                  dw  END_OK
    2416   00:4D8F                      
    2417   00:4D8F                      ;========================
    2418   00:4D8F                      ;===  Functions code  ===
    2419   00:4D8F                      ;========================
    2420   00:4D8F                      FN_NOT_IMP:
    2421   00:4D8F  3E 01                   ld  a,ERR_NOT_IMP
    2422   00:4D91  C9                      ret
    2423   00:4D92                      
    2424   00:4D92                      END_OK:
    2425   00:4D92  AF                      xor a
    2426   00:4D93  C9                      ret
    2427   00:4D94                      
    2428   00:4D94                      ; Most functions do not have special handling on time out and can use this.
    2429   00:4D94                      ; If there is a need to retry sending or receiving on time-out, then a custom
    2430   00:4D94                      ; time-out function must be done, check the examples of UDP and TCP receive
    2431   00:4D94                      TCPIP_GENERIC_CHECK_TIME_OUT:
    2432   00:4D94                          ; Save registers other than AF
    2433   00:4D94  C5                      push bc
    2434   00:4D95  D5                      push de
    2435   00:4D96  E5                      push hl
    2436   00:4D97  CD FE 59                call    GETCOUNTER
    2437   00:4D9A  7D                      ld  a,l
    2438   00:4D9B  B4                      or  h
    2439   00:4D9C                          ; Restore registers, we are returning
    2440   00:4D9C  E1                      pop hl
    2441   00:4D9D  D1                      pop de
    2442   00:4D9E  C1                      pop bc
    2443   00:4D9F  C0                      ret nz
    2444   00:4DA0                          ; Ok, timeout...
    2445   00:4DA0  F1                      pop af                          ; Get return address of who called this out of the stack
    2446   00:4DA1  3E 0F                   ld  a,ERR_INV_OPER
    2447   00:4DA3  C9                      ret                             ; and return the function itself
    2448   00:4DA4                      
    2449   00:4DA4                      ;========================
    2450   00:4DA4                      ;===  UNAPI_GET_INFO  ===
    2451   00:4DA4                      ;========================
    2452   00:4DA4                      ; Obtain the implementation name and version.
    2453   00:4DA4                      ;
    2454   00:4DA4                      ;    Input:  A  = 0
    2455   00:4DA4                      ;    Output: HL = Descriptive string for this implementation, on this slot, zero terminated
    2456   00:4DA4                      ;            DE = API version supported, D.E
    2457   00:4DA4                      ;            BC = This implementation version, B.C.
    2458   00:4DA4                      ;            A  = 0 and Cy = 0
    2459   00:4DA4                      UNAPI_GET_INFO:
    2460   00:4DA4  01 03 01                ld  bc,256*ROM_V_P+ROM_V_S
    2461   00:4DA7  11 02 01                ld  de,256*API_V_P+API_V_S
    2462   00:4DAA  21 BE 69                ld  hl,APIINFO
    2463   00:4DAD  AF                      xor a
    2464   00:4DAE  C9                      ret
    2465   00:4DAF                      
    2466   00:4DAF                      ;=========================
    2467   00:4DAF                      ;===  TCPIP_GET_CAPAB  ===
    2468   00:4DAF                      ;=========================
    2469   00:4DAF                      ; Get information about the TCP/IP capabilities and features.
    2470   00:4DAF                      ;
    2471   00:4DAF                      ;    Input:  A = 1
    2472   00:4DAF                      ;            B = Index of information block to retrieve:
    2473   00:4DAF                      ;                1: Capabilities and features flags, link level protocol
    2474   00:4DAF                      ;                2: Connection pool size and status
    2475   00:4DAF                      ;                3: Maximum datagram size allowed
    2476   00:4DAF                      ;                4: Second set of capabilities and features flags
    2477   00:4DAF                      ;    Output: A = Error code
    2478   00:4DAF                      ;        When information block 1 requested:
    2479   00:4DAF                      ;            HL = Capabilities flags
    2480   00:4DAF                      ;            DE = Features flags
    2481   00:4DAF                      ;            B  = Link level protocol used
    2482   00:4DAF                      ;        When information block 2 requested:
    2483   00:4DAF                      ;            B = Maximum simultaneous TCP connections supported
    2484   00:4DAF                      ;            C = Maximum simultaneous UDP connections supported
    2485   00:4DAF                      ;            D = Free TCP connections currently available
    2486   00:4DAF                      ;            E = Free UDP connections currently available
    2487   00:4DAF                      ;            H = Maximum simultaneous raw IP connections supported
    2488   00:4DAF                      ;            L = Free raw IP connections currently available
    2489   00:4DAF                      ;        When information block 3 requested:
    2490   00:4DAF                      ;            HL = Maximum incoming datagram size supported
    2491   00:4DAF                      ;            DE = Maximum outgoing datagram size supported
    2492   00:4DAF                      ;        When information block 4 requested:
    2493   00:4DAF                      ;            HL = Second set of capabilities flags
    2494   00:4DAF                      ;            DE = Second set of features flags (currently unused, always zero)
    2495   00:4DAF                      TCPIP_GET_CAPAB:
    2496   00:4DAF                          SEND_DATA                       ; Send the command
    2496   00:4DAF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2497   00:4DB2  AF                      xor a
    2498   00:4DB3                          SEND_DATA                       ; Send the command size msb
    2498   00:4DB3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2499   00:4DB6  3C                      inc a
    2500   00:4DB7                          SEND_DATA                       ; Send the command size lsb
    2500   00:4DB7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2501   00:4DBA  78                      ld  a,b
    2502   00:4DBB  CD 2F 5A                call    SETBYTE                 ; Save it, we are going to need it later
    2503   00:4DBE                          SEND_DATA                       ; Send the parameter
    2503   00:4DBE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2504   00:4DC1                      
    2505   00:4DC1                          ; Now wait up to 120 ticks to get response
    2506   00:4DC1  21 78 00                ld  hl,120
    2507   00:4DC4  CD 0D 5A                call    SETCOUNTER
    2508   00:4DC7                      TCPIP_GET_CAPAB_ST1:
    2509   00:4DC7                          CHECK_DATA
    2509   00:4DC7  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2509   00:4DCA  CB 47             >     bit 0,a
    2510   00:4DCC  20 05                   jr  nz,TCPIP_GET_CAPAB_ST1.1
    2511   00:4DCE  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2512   00:4DD1  18 F4                   jr  TCPIP_GET_CAPAB_ST1
    2513   00:4DD3                      TCPIP_GET_CAPAB_ST1.1:
    2514   00:4DD3                          ; nz, check the data
    2515   00:4DD3                          RECEIVE_DATA
    2515   00:4DD3  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2516   00:4DD6  FE 01                   cp  1                           ; Is response of our command?
    2517   00:4DD8  20 ED                   jr  nz,TCPIP_GET_CAPAB_ST1
    2518   00:4DDA                          ; Now get return code, if return code other than 0, it is finished
    2519   00:4DDA                      TCPIP_GET_CAPAB_RC:
    2520   00:4DDA                          CHECK_DATA
    2520   00:4DDA  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2520   00:4DDD  CB 47             >     bit 0,a
    2521   00:4DDF  20 05                   jr  nz,TCPIP_GET_CAPAB_RC.1
    2522   00:4DE1  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2523   00:4DE4  18 F4                   jr  TCPIP_GET_CAPAB_RC
    2524   00:4DE6                      TCPIP_GET_CAPAB_RC.1:
    2525   00:4DE6                          ; nz, discard
    2526   00:4DE6                          RECEIVE_DATA
    2526   00:4DE6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2527   00:4DE9  B7                      or  a                           ; 0?
    2528   00:4DEA  C0                      ret nz                          ; If not, done
    2529   00:4DEB                      
    2530   00:4DEB                          ; Next two bytes are return code and size bytes, don't care
    2531   00:4DEB  06 02                   ld  b,2
    2532   00:4DED                      TCPIP_GET_CAPAB_ST2:
    2533   00:4DED                          CHECK_DATA
    2533   00:4DED  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2533   00:4DF0  CB 47             >     bit 0,a
    2534   00:4DF2  20 05                   jr  nz,TCPIP_GET_CAPAB_ST2.1
    2535   00:4DF4  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2536   00:4DF7  18 F4                   jr  TCPIP_GET_CAPAB_ST2
    2537   00:4DF9                      TCPIP_GET_CAPAB_ST2.1:
    2538   00:4DF9                          ; Nz, discard
    2539   00:4DF9                          RECEIVE_DATA
    2539   00:4DF9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2540   00:4DFC  05                      dec b
    2541   00:4DFD  20 EE                   jr  nz,TCPIP_GET_CAPAB_ST2
    2542   00:4DFF                      
    2543   00:4DFF                          ; Now check if block 1, 2 or 3
    2544   00:4DFF  CD 1D 5A                call    GETBYTE                 ; Get the parameter we saved at the start
    2545   00:4E02  3D                      dec a
    2546   00:4E03  CA B5 4E                jp  z,TCPIP_GET_CAPAB_BLK1      ; 1
    2547   00:4E06  3D                      dec a
    2548   00:4E07  CA 53 4E                jp  z,TCPIP_GET_CAPAB_BLK2      ; 2
    2549   00:4E0A  3D                      dec a
    2550   00:4E0B  CA 11 4E                jp  z,TCPIP_GET_CAPAB_BLK3      ; 3
    2551   00:4E0E                          ; Else, only block four, same as block 1
    2552   00:4E0E  C3 B5 4E                jp  TCPIP_GET_CAPAB_BLK1        ; 1
    2553   00:4E11                          ; Block 3 Handling, we will receive L, H, E and D
    2554   00:4E11                      TCPIP_GET_CAPAB_BLK3:
    2555   00:4E11                      TCPIP_GET_CAPAB_BLK3_ST1:
    2556   00:4E11                          CHECK_DATA
    2556   00:4E11  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2556   00:4E14  CB 47             >     bit 0,a
    2557   00:4E16  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST1.1
    2558   00:4E18  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2559   00:4E1B  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST1
    2560   00:4E1D                      TCPIP_GET_CAPAB_BLK3_ST1.1:
    2561   00:4E1D                          ; nz, get it
    2562   00:4E1D                          RECEIVE_DATA
    2562   00:4E1D  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2563   00:4E20  6F                      ld  l,a
    2564   00:4E21                      TCPIP_GET_CAPAB_BLK3_ST2:
    2565   00:4E21                          CHECK_DATA
    2565   00:4E21  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2565   00:4E24  CB 47             >     bit 0,a
    2566   00:4E26  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST2.1
    2567   00:4E28  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2568   00:4E2B  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST2
    2569   00:4E2D                      TCPIP_GET_CAPAB_BLK3_ST2.1:
    2570   00:4E2D                          ; nz, get it
    2571   00:4E2D                          RECEIVE_DATA
    2571   00:4E2D  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2572   00:4E30  67                      ld  h,a
    2573   00:4E31                      TCPIP_GET_CAPAB_BLK3_ST3:
    2574   00:4E31                          CHECK_DATA
    2574   00:4E31  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2574   00:4E34  CB 47             >     bit 0,a
    2575   00:4E36  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST3.1
    2576   00:4E38  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2577   00:4E3B  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST3
    2578   00:4E3D                      TCPIP_GET_CAPAB_BLK3_ST3.1:
    2579   00:4E3D                          ; nz, get it
    2580   00:4E3D                          RECEIVE_DATA
    2580   00:4E3D  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2581   00:4E40  5F                      ld  e,a
    2582   00:4E41                      TCPIP_GET_CAPAB_BLK3_ST4:
    2583   00:4E41                          CHECK_DATA
    2583   00:4E41  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2583   00:4E44  CB 47             >     bit 0,a
    2584   00:4E46  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST4.1
    2585   00:4E48  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2586   00:4E4B  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST4
    2587   00:4E4D                      TCPIP_GET_CAPAB_BLK3_ST4.1:
    2588   00:4E4D                          ; nz, get it
    2589   00:4E4D                          RECEIVE_DATA
    2589   00:4E4D  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2590   00:4E50  57                      ld  d,a
    2591   00:4E51                          ; Done
    2592   00:4E51  AF                      xor a
    2593   00:4E52  C9                      ret
    2594   00:4E53                      
    2595   00:4E53                      TCPIP_GET_CAPAB_BLK2:
    2596   00:4E53                          ; Block 2 Handling, we will receive B, C, D, E, H, L
    2597   00:4E53                      TCPIP_GET_CAPAB_BLK2_ST1:
    2598   00:4E53                          CHECK_DATA
    2598   00:4E53  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2598   00:4E56  CB 47             >     bit 0,a
    2599   00:4E58  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST1.1
    2600   00:4E5A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2601   00:4E5D  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST1
    2602   00:4E5F                      TCPIP_GET_CAPAB_BLK2_ST1.1:
    2603   00:4E5F                          ; nz, get it
    2604   00:4E5F                          RECEIVE_DATA
    2604   00:4E5F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2605   00:4E62  47                      ld  b,a
    2606   00:4E63                      TCPIP_GET_CAPAB_BLK2_ST2:
    2607   00:4E63                          CHECK_DATA
    2607   00:4E63  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2607   00:4E66  CB 47             >     bit 0,a
    2608   00:4E68  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST2.1
    2609   00:4E6A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2610   00:4E6D  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST2
    2611   00:4E6F                      TCPIP_GET_CAPAB_BLK2_ST2.1:
    2612   00:4E6F                          ; nz, get it
    2613   00:4E6F                          RECEIVE_DATA
    2613   00:4E6F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2614   00:4E72  4F                      ld  c,a
    2615   00:4E73                      TCPIP_GET_CAPAB_BLK2_ST3:
    2616   00:4E73                          CHECK_DATA
    2616   00:4E73  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2616   00:4E76  CB 47             >     bit 0,a
    2617   00:4E78  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST3.1
    2618   00:4E7A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2619   00:4E7D  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST3
    2620   00:4E7F                      TCPIP_GET_CAPAB_BLK2_ST3.1:
    2621   00:4E7F                          ; nz, get it
    2622   00:4E7F                          RECEIVE_DATA
    2622   00:4E7F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2623   00:4E82  57                      ld  d,a
    2624   00:4E83                      TCPIP_GET_CAPAB_BLK2_ST4:
    2625   00:4E83                          CHECK_DATA
    2625   00:4E83  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2625   00:4E86  CB 47             >     bit 0,a
    2626   00:4E88  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST4.1
    2627   00:4E8A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2628   00:4E8D  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST4
    2629   00:4E8F                      TCPIP_GET_CAPAB_BLK2_ST4.1:
    2630   00:4E8F                          ; nz, get it
    2631   00:4E8F                          RECEIVE_DATA
    2631   00:4E8F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2632   00:4E92  5F                      ld  e,a
    2633   00:4E93                      TCPIP_GET_CAPAB_BLK2_ST5:
    2634   00:4E93                          CHECK_DATA
    2634   00:4E93  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2634   00:4E96  CB 47             >     bit 0,a
    2635   00:4E98  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST5.1
    2636   00:4E9A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2637   00:4E9D  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST5
    2638   00:4E9F                      TCPIP_GET_CAPAB_BLK2_ST5.1:
    2639   00:4E9F                          ; nz, get it
    2640   00:4E9F                          RECEIVE_DATA
    2640   00:4E9F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2641   00:4EA2  67                      ld  h,a
    2642   00:4EA3                      TCPIP_GET_CAPAB_BLK2_ST6:
    2643   00:4EA3                          CHECK_DATA
    2643   00:4EA3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2643   00:4EA6  CB 47             >     bit 0,a
    2644   00:4EA8  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST6.1
    2645   00:4EAA  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2646   00:4EAD  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST6
    2647   00:4EAF                      TCPIP_GET_CAPAB_BLK2_ST6.1:
    2648   00:4EAF                          ; nz, get it
    2649   00:4EAF                          RECEIVE_DATA
    2649   00:4EAF  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2650   00:4EB2  6F                      ld  l,a
    2651   00:4EB3                          ; Done
    2652   00:4EB3  AF                      xor a
    2653   00:4EB4  C9                      ret
    2654   00:4EB5                      
    2655   00:4EB5                      TCPIP_GET_CAPAB_BLK1:
    2656   00:4EB5                          ; Block 1 Handling, we will receive L, H, E, D and B
    2657   00:4EB5                      TCPIP_GET_CAPAB_BLK1_ST1:
    2658   00:4EB5                          CHECK_DATA
    2658   00:4EB5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2658   00:4EB8  CB 47             >     bit 0,a
    2659   00:4EBA  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST1.1
    2660   00:4EBC  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2661   00:4EBF  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST1
    2662   00:4EC1                      TCPIP_GET_CAPAB_BLK1_ST1.1:
    2663   00:4EC1                          ; nz, get it
    2664   00:4EC1                          RECEIVE_DATA
    2664   00:4EC1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2665   00:4EC4  6F                      ld  l,a
    2666   00:4EC5                      TCPIP_GET_CAPAB_BLK1_ST2:
    2667   00:4EC5                          CHECK_DATA
    2667   00:4EC5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2667   00:4EC8  CB 47             >     bit 0,a
    2668   00:4ECA  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST2.1
    2669   00:4ECC  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2670   00:4ECF  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST2
    2671   00:4ED1                      TCPIP_GET_CAPAB_BLK1_ST2.1:
    2672   00:4ED1                          ; nz, get it
    2673   00:4ED1                          RECEIVE_DATA
    2673   00:4ED1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2674   00:4ED4  67                      ld  h,a
    2675   00:4ED5                      TCPIP_GET_CAPAB_BLK1_ST3:
    2676   00:4ED5                          CHECK_DATA
    2676   00:4ED5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2676   00:4ED8  CB 47             >     bit 0,a
    2677   00:4EDA  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST3.1
    2678   00:4EDC  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2679   00:4EDF  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST3
    2680   00:4EE1                      TCPIP_GET_CAPAB_BLK1_ST3.1:
    2681   00:4EE1                          ; nz, get it
    2682   00:4EE1                          RECEIVE_DATA
    2682   00:4EE1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2683   00:4EE4  5F                      ld  e,a
    2684   00:4EE5                      TCPIP_GET_CAPAB_BLK1_ST4:
    2685   00:4EE5                          CHECK_DATA
    2685   00:4EE5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2685   00:4EE8  CB 47             >     bit 0,a
    2686   00:4EEA  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST4.1
    2687   00:4EEC  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2688   00:4EEF  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST4
    2689   00:4EF1                      TCPIP_GET_CAPAB_BLK1_ST4.1:
    2690   00:4EF1                          ; nz, get it
    2691   00:4EF1                          RECEIVE_DATA
    2691   00:4EF1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2692   00:4EF4  57                      ld  d,a
    2693   00:4EF5                      TCPIP_GET_CAPAB_BLK1_ST5:
    2694   00:4EF5                          CHECK_DATA
    2694   00:4EF5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2694   00:4EF8  CB 47             >     bit 0,a
    2695   00:4EFA  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST5.1
    2696   00:4EFC  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2697   00:4EFF  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST5
    2698   00:4F01                      TCPIP_GET_CAPAB_BLK1_ST5.1:
    2699   00:4F01                          ; nz, get it
    2700   00:4F01                          RECEIVE_DATA
    2700   00:4F01  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2701   00:4F04  47                      ld  b,a
    2702   00:4F05                          ; Done
    2703   00:4F05  AF                      xor a
    2704   00:4F06  C9                      ret
    2705   00:4F07                      
    2706   00:4F07                      ;==========================
    2707   00:4F07                      ;===  TCPIP_GET_IPINFO  ===
    2708   00:4F07                      ;==========================
    2709   00:4F07                      ;Get IP address.
    2710   00:4F07                      ;
    2711   00:4F07                      ;Input:  A = 2
    2712   00:4F07                      ;        B = Index of address to obtain:
    2713   00:4F07                      ;            1: Local IP address
    2714   00:4F07                      ;            2: Peer IP address
    2715   00:4F07                      ;            3: Subnet mask
    2716   00:4F07                      ;            4: Default gateway
    2717   00:4F07                      ;            5: Primary DNS server IP address
    2718   00:4F07                      ;            6: Secondary DNS server IP address
    2719   00:4F07                      ;Output: A = Error code
    2720   00:4F07                      ;        L.H.E.D = Requested address
    2721   00:4F07                      TCPIP_GET_IPINFO:
    2722   00:4F07                          SEND_DATA                       ; Send the command
    2722   00:4F07  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2723   00:4F0A  AF                      xor a
    2724   00:4F0B                          SEND_DATA                       ; Send the command size msb
    2724   00:4F0B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2725   00:4F0E  3C                      inc a
    2726   00:4F0F                          SEND_DATA                       ; Send the command size lsb
    2726   00:4F0F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2727   00:4F12  78                      ld  a,b
    2728   00:4F13                          SEND_DATA
    2728   00:4F13  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2729   00:4F16                      
    2730   00:4F16                          ; Now wait up to 600 ticks to get response
    2731   00:4F16  21 58 02                ld  hl,600
    2732   00:4F19  CD 0D 5A                call    SETCOUNTER
    2733   00:4F1C                      TCPIP_GET_IPINFO_ST1:
    2734   00:4F1C                          CHECK_DATA
    2734   00:4F1C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2734   00:4F1F  CB 47             >     bit 0,a
    2735   00:4F21  20 05                   jr  nz,TCPIP_GET_IPINFO_ST1.1
    2736   00:4F23  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2737   00:4F26  18 F4                   jr  TCPIP_GET_IPINFO_ST1
    2738   00:4F28                      TCPIP_GET_IPINFO_ST1.1:
    2739   00:4F28                          ; nz, check the data
    2740   00:4F28                          RECEIVE_DATA
    2740   00:4F28  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2741   00:4F2B  FE 02                   cp  2                           ; Is response of our command?
    2742   00:4F2D  20 ED                   jr  nz,TCPIP_GET_IPINFO_ST1
    2743   00:4F2F                          ; now get return code, if return code other than 0, it is finished
    2744   00:4F2F                      TCPIP_GET_IPINFO_RC:
    2745   00:4F2F                          CHECK_DATA
    2745   00:4F2F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2745   00:4F32  CB 47             >     bit 0,a
    2746   00:4F34  20 05                   jr  nz,TCPIP_GET_IPINFO_RC.1
    2747   00:4F36  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2748   00:4F39  18 F4                   jr  TCPIP_GET_IPINFO_RC
    2749   00:4F3B                      TCPIP_GET_IPINFO_RC.1:
    2750   00:4F3B                          ; nz, discard
    2751   00:4F3B                          RECEIVE_DATA
    2751   00:4F3B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2752   00:4F3E  B7                      or  a                           ; 0?
    2753   00:4F3F  C0                      ret nz                          ; if not, done
    2754   00:4F40                      
    2755   00:4F40                          ; next two bytes are return code and size bytes, don't care, it is 4
    2756   00:4F40  06 02                   ld  b,2
    2757   00:4F42                      TCPIP_GET_IPINFO_ST2:
    2758   00:4F42                          CHECK_DATA
    2758   00:4F42  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2758   00:4F45  CB 47             >     bit 0,a
    2759   00:4F47  20 05                   jr  nz,TCPIP_GET_IPINFO_ST2.1
    2760   00:4F49  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2761   00:4F4C  18 F4                   jr  TCPIP_GET_IPINFO_ST2
    2762   00:4F4E                      TCPIP_GET_IPINFO_ST2.1:
    2763   00:4F4E                          ; nz, discard
    2764   00:4F4E                          RECEIVE_DATA
    2764   00:4F4E  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2765   00:4F51  05                      dec b
    2766   00:4F52  20 EE                   jr  nz,TCPIP_GET_IPINFO_ST2
    2767   00:4F54                      
    2768   00:4F54                          ; now just get the 4 bytes IP and order it in L, H, E and D
    2769   00:4F54                      TCPIP_GET_IPINFO_IP_ST1:
    2770   00:4F54                          CHECK_DATA
    2770   00:4F54  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2770   00:4F57  CB 47             >     bit 0,a
    2771   00:4F59  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST1.1
    2772   00:4F5B  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2773   00:4F5E  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST1
    2774   00:4F60                      TCPIP_GET_IPINFO_IP_ST1.1:
    2775   00:4F60                          ; nz, get it
    2776   00:4F60                          RECEIVE_DATA
    2776   00:4F60  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2777   00:4F63  6F                      ld  l,a
    2778   00:4F64                      TCPIP_GET_IPINFO_IP_ST2:
    2779   00:4F64                          CHECK_DATA
    2779   00:4F64  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2779   00:4F67  CB 47             >     bit 0,a
    2780   00:4F69  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST2.1
    2781   00:4F6B  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2782   00:4F6E  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST2
    2783   00:4F70                      TCPIP_GET_IPINFO_IP_ST2.1:
    2784   00:4F70                          ; nz, get it
    2785   00:4F70                          RECEIVE_DATA
    2785   00:4F70  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2786   00:4F73  67                      ld  h,a
    2787   00:4F74                      TCPIP_GET_IPINFO_IP_ST3:
    2788   00:4F74                          CHECK_DATA
    2788   00:4F74  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2788   00:4F77  CB 47             >     bit 0,a
    2789   00:4F79  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST3.1
    2790   00:4F7B  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2791   00:4F7E  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST3
    2792   00:4F80                      TCPIP_GET_IPINFO_IP_ST3.1:
    2793   00:4F80                          ; nz, get it
    2794   00:4F80                          RECEIVE_DATA
    2794   00:4F80  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2795   00:4F83  5F                      ld  e,a
    2796   00:4F84                      TCPIP_GET_IPINFO_IP_ST4:
    2797   00:4F84                          CHECK_DATA
    2797   00:4F84  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2797   00:4F87  CB 47             >     bit 0,a
    2798   00:4F89  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST4.1
    2799   00:4F8B  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2800   00:4F8E  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST4
    2801   00:4F90                      TCPIP_GET_IPINFO_IP_ST4.1:
    2802   00:4F90                          ; nz, get it
    2803   00:4F90                          RECEIVE_DATA
    2803   00:4F90  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2804   00:4F93  57                      ld  d,a
    2805   00:4F94                          ; done
    2806   00:4F94  AF                      xor a
    2807   00:4F95  C9                      ret
    2808   00:4F96                      
    2809   00:4F96                      ;=========================
    2810   00:4F96                      ;===  TCPIP_NET_STATE  ===
    2811   00:4F96                      ;=========================
    2812   00:4F96                      ;Get network state.
    2813   00:4F96                      ;
    2814   00:4F96                      ;Input:  A = 3
    2815   00:4F96                      ;Output: A = Error code
    2816   00:4F96                      ;        B = Current network state:
    2817   00:4F96                      ;            0: Closed
    2818   00:4F96                      ;            1: Opening
    2819   00:4F96                      ;            2: Open
    2820   00:4F96                      ;            3: Closing
    2821   00:4F96                      ;            255: Unknown
    2822   00:4F96                      TCPIP_NET_STATE:
    2823   00:4F96                          SEND_DATA                       ; Send the command
    2823   00:4F96  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2824   00:4F99  AF                      xor a
    2825   00:4F9A                          SEND_DATA                       ; Send the command size msb
    2825   00:4F9A  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2826   00:4F9D                          SEND_DATA                       ; Send the command size lsb
    2826   00:4F9D  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2827   00:4FA0                      
    2828   00:4FA0                          ; Now wait up to 720 ticks to get response
    2829   00:4FA0  21 D0 02                ld  hl,720
    2830   00:4FA3  CD 0D 5A                call    SETCOUNTER
    2831   00:4FA6                      TCPIP_NET_STATE_ST1:
    2832   00:4FA6                          CHECK_DATA
    2832   00:4FA6  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2832   00:4FA9  CB 47             >     bit 0,a
    2833   00:4FAB  20 05                   jr  nz,TCPIP_NET_STATE_ST1.1
    2834   00:4FAD  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2835   00:4FB0  18 F4                   jr  TCPIP_NET_STATE_ST1
    2836   00:4FB2                      TCPIP_NET_STATE_ST1.1:
    2837   00:4FB2                          ; nz, check the data
    2838   00:4FB2                          RECEIVE_DATA
    2838   00:4FB2  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2839   00:4FB5  FE 03                   cp  3                           ; Is response of our command?
    2840   00:4FB7  20 ED                   jr  nz,TCPIP_NET_STATE_ST1
    2841   00:4FB9                          ; now get return code, if return code other than 0, it is finished
    2842   00:4FB9                      TCPIP_NET_STATE_RC:
    2843   00:4FB9                          CHECK_DATA
    2843   00:4FB9  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2843   00:4FBC  CB 47             >     bit 0,a
    2844   00:4FBE  20 05                   jr  nz,TCPIP_NET_STATE_RC.1
    2845   00:4FC0  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2846   00:4FC3  18 F4                   jr  TCPIP_NET_STATE_RC
    2847   00:4FC5                      TCPIP_NET_STATE_RC.1:
    2848   00:4FC5                          ; nz, get it
    2849   00:4FC5                          RECEIVE_DATA
    2849   00:4FC5  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2850   00:4FC8  B7                      or  a                           ; 0?
    2851   00:4FC9  C0                      ret nz                          ; if not, done
    2852   00:4FCA                      
    2853   00:4FCA                          ; next two bytes are return code and size bytes, don't care, it is 1
    2854   00:4FCA  06 02                   ld  b,2
    2855   00:4FCC                      TCPIP_NET_STATE_ST2:
    2856   00:4FCC                          CHECK_DATA
    2856   00:4FCC  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2856   00:4FCF  CB 47             >     bit 0,a
    2857   00:4FD1  20 05                   jr  nz,TCPIP_NET_STATE_ST2.1
    2858   00:4FD3  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2859   00:4FD6  18 F4                   jr  TCPIP_NET_STATE_ST2
    2860   00:4FD8                      TCPIP_NET_STATE_ST2.1:
    2861   00:4FD8                          ; nz, discard
    2862   00:4FD8                          RECEIVE_DATA
    2862   00:4FD8  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2863   00:4FDB  05                      dec b
    2864   00:4FDC  20 EE                   jr  nz,TCPIP_NET_STATE_ST2
    2865   00:4FDE                      
    2866   00:4FDE                          ; now just get the 1 byte (NET STATE) IP and place it in B
    2867   00:4FDE                      TCPIP_NET_STATE_NS_ST1:
    2868   00:4FDE                          CHECK_DATA
    2868   00:4FDE  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2868   00:4FE1  CB 47             >     bit 0,a
    2869   00:4FE3  20 05                   jr  nz,TCPIP_NET_STATE_NS_ST1.1
    2870   00:4FE5  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2871   00:4FE8  18 F4                   jr  TCPIP_NET_STATE_NS_ST1
    2872   00:4FEA                      TCPIP_NET_STATE_NS_ST1.1:
    2873   00:4FEA                          ; nz, get it
    2874   00:4FEA                          RECEIVE_DATA
    2874   00:4FEA  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2875   00:4FED  47                      ld  b,a
    2876   00:4FEE                          ; done
    2877   00:4FEE  AF                      xor a
    2878   00:4FEF  C9                      ret
    2879   00:4FF0                      
    2880   00:4FF0                      ;=====================
    2881   00:4FF0                      ;===  TCPIP_DNS_Q  ===
    2882   00:4FF0                      ;=====================
    2883   00:4FF0                      ;Start a host name resolution query.
    2884   00:4FF0                      ;
    2885   00:4FF0                      ;Input:  A  = 6
    2886   00:4FF0                      ;        HL = Address of the host name to be resolved, zero terminated
    2887   00:4FF0                      ;        B  = Flags, when set to 1 they instruct the resolver to:
    2888   00:4FF0                      ;             bit 0: Only abort the query currently in progress, if there is any
    2889   00:4FF0                      ;                    (other flags and registers are then ignored)
    2890   00:4FF0                      ;             bit 1: Assume that the passed name is an IP address,
    2891   00:4FF0                      ;                    and return an error if this is not true
    2892   00:4FF0                      ;             bit 2: If there is a query in progress already,
    2893   00:4FF0                      ;                    do NOT abort it and return an error instead
    2894   00:4FF0                      ;Output:  A = Error code
    2895   00:4FF0                      ;         B = 0 if a query to a DNS server is in progress
    2896   00:4FF0                      ;             1 if the name represented an IP address
    2897   00:4FF0                      ;             2 if the name could be resolved locally
    2898   00:4FF0                      ;         L.H.E.D = Resolved IP address
    2899   00:4FF0                      ;                   (only if no error occurred and B=1 or 2 is returned)
    2900   00:4FF0                      ;RAM Buffer to store names to be resolved (and used also to translate IPs from ASCII to 32bits number)
    2901   00:4FF0                      ;Will store the result of the last DNS query
    2902   00:4FF0                      TCPIP_DNS_Q:
    2903   00:4FF0  E5                      push    hl                      ; Save HL
    2904   00:4FF1  AF                      xor a
    2905   00:4FF2  5F                      ld  e,a
    2906   00:4FF3  57                      ld  d,a                         ; Zero DE
    2907   00:4FF4                      TCPIP_DNS_Q_SIZE_LOOP:
    2908   00:4FF4  7E                      ld  a,(hl)                      ; so let's check the size of dns data
    2909   00:4FF5  B7                      or  a                           ; it is zero terminated
    2910   00:4FF6  28 05                   jr  z,TCPIP_DNS_Q_SEND          ; if zero, end of string
    2911   00:4FF8  13                      inc de                          ; ok, not zero, one more char
    2912   00:4FF9  23                      inc hl                          ; next
    2913   00:4FFA  C3 F4 4F                jp  TCPIP_DNS_Q_SIZE_LOOP       ; jp is a tad bit faster and we are not worried about code size
    2914   00:4FFD                      TCPIP_DNS_Q_SEND:
    2915   00:4FFD                          ; Here we send the query and wait the result
    2916   00:4FFD  13                      inc de                          ; add 1, we will send flag first
    2917   00:4FFE  3E CE                   ld  a,206                       ; DNS_Q_NEW
    2918   00:5000                          SEND_DATA                       ; Send the command
    2918   00:5000  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2919   00:5003  7A                      ld  a,d
    2920   00:5004                          SEND_DATA                       ; Send the command size msb
    2920   00:5004  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2921   00:5007  7B                      ld  a,e
    2922   00:5008                          SEND_DATA                       ; Send the command size lsb
    2922   00:5008  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2923   00:500B  78                      ld  a,b
    2924   00:500C                          SEND_DATA                       ; Send the flag byte
    2924   00:500C  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2925   00:500F                      
    2926   00:500F                          if USE_MEM_IO = 0
    2927   00:500F                    ~     ; now otir of DNS/DNS BUFFER DATA SIZE
    2928   00:500F                    ~     ld  c,OUT_TX_PORT               ; our data TX port
    2929   00:500F                    ~     endif
    2930   00:500F  E1                      pop hl                          ; string to try to resolve
    2931   00:5010  1B                      dec de                          ; we are sending just data addressed by HL, so revert count
    2932   00:5011  7A                      ld  a,d
    2933   00:5012  B3                      or  e                           ; if de zero, no string, wrong parameters, but let the ESP answer
    2934   00:5013  CA 25 50                jp  z,TCPIP_DNS_Q_WAIT_RSP
    2935   00:5016  AF                      xor a
    2936   00:5017                          ; Fast 16 bit variable size loop by GRAUW
    2937   00:5017  43                      ld  b,e
    2938   00:5018  1B                      dec de
    2939   00:5019  14                      inc d
    2940   00:501A                      TCPIP_DNS_Q_SENDLP:
    2941   00:501A                          ; send it
    2942   00:501A                          if USE_MEM_IO = 0
    2943   00:501A                    ~     outi
    2944   00:501A                    ~     jp  nz,TCPIP_DNS_Q_SENDLP
    2945   00:501A                    ~     else
    2946   00:501A  7E                      ld  a,(hl)
    2947   00:501B  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    2948   00:501E  23                      inc hl
    2949   00:501F  10 F9                   djnz TCPIP_DNS_Q_SENDLP
    2950   00:5021                          endif
    2951   00:5021  15                      dec d
    2952   00:5022  C2 1A 50                jp  nz,TCPIP_DNS_Q_SENDLP
    2953   00:5025                      TCPIP_DNS_Q_WAIT_RSP:
    2954   00:5025                          ; Now wait up to 900 ticks (15s@60Hz) to get response
    2955   00:5025  21 84 03                ld  hl,900
    2956   00:5028  CD 0D 5A                call    SETCOUNTER
    2957   00:502B                      TCPIP_DNSQ_SEND_ST1:
    2958   00:502B                          CHECK_DATA
    2958   00:502B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2958   00:502E  CB 47             >     bit 0,a
    2959   00:5030  20 05                   jr  nz,TCPIP_DNSQ_SEND_ST1.1
    2960   00:5032  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2961   00:5035  18 F4                   jr  TCPIP_DNSQ_SEND_ST1
    2962   00:5037                      TCPIP_DNSQ_SEND_ST1.1:
    2963   00:5037                          ; nz, check the data
    2964   00:5037                          RECEIVE_DATA
    2964   00:5037  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2965   00:503A  FE CE                   cp  206                         ; Is response of our command?
    2966   00:503C  20 ED                   jr  nz,TCPIP_DNSQ_SEND_ST1
    2967   00:503E                          ; now get return code, if return code other than 0, it is finished
    2968   00:503E                      TCPIP_DNSQ_SEND_RC:
    2969   00:503E                          CHECK_DATA
    2969   00:503E  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2969   00:5041  CB 47             >     bit 0,a
    2970   00:5043  20 05                   jr  nz,TCPIP_DNSQ_SEND_RC.1
    2971   00:5045  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2972   00:5048  18 F4                   jr  TCPIP_DNSQ_SEND_RC
    2973   00:504A                      TCPIP_DNSQ_SEND_RC.1:
    2974   00:504A                          ; nz, discard
    2975   00:504A                          RECEIVE_DATA
    2975   00:504A  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2976   00:504D  B7                      or  a                           ; 0?
    2977   00:504E  06 00                   ld  b,0                         ; say in progress as there is no failure status
    2978   00:5050  C0                      ret nz                          ; if not, done, ERROR won't return data
    2979   00:5051                      
    2980   00:5051                          ; next two bytes are return code and size bytes, don't care, it is 4, resolved IP
    2981   00:5051  06 02                   ld  b,2
    2982   00:5053                      TCPIP_DNSQ_SEND_RC_ST2:
    2983   00:5053                          CHECK_DATA
    2983   00:5053  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2983   00:5056  CB 47             >     bit 0,a
    2984   00:5058  20 05                   jr  nz,TCPIP_DNSQ_SEND_RC_ST2.1
    2985   00:505A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2986   00:505D  18 F4                   jr  TCPIP_DNSQ_SEND_RC_ST2
    2987   00:505F                      TCPIP_DNSQ_SEND_RC_ST2.1:
    2988   00:505F                          ; nz, discard
    2989   00:505F                          RECEIVE_DATA
    2989   00:505F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2990   00:5062  05                      dec b
    2991   00:5063  20 EE                   jr  nz,TCPIP_DNSQ_SEND_RC_ST2
    2992   00:5065                      
    2993   00:5065                          ; now just get the 4 bytes IP and place it in L H E D
    2994   00:5065                      TCPIP_DNSQ_IP_ST1:
    2995   00:5065                          CHECK_DATA
    2995   00:5065  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2995   00:5068  CB 47             >     bit 0,a
    2996   00:506A  20 05                   jr  nz,TCPIP_DNSQ_IP_ST1.1
    2997   00:506C  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2998   00:506F  18 F4                   jr  TCPIP_DNSQ_IP_ST1
    2999   00:5071                      TCPIP_DNSQ_IP_ST1.1:
    3000   00:5071                          ; nz, get it
    3001   00:5071                          RECEIVE_DATA
    3001   00:5071  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3002   00:5074  6F                      ld  l,a
    3003   00:5075                      TCPIP_DNSQ_IP_ST2:
    3004   00:5075                          CHECK_DATA
    3004   00:5075  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3004   00:5078  CB 47             >     bit 0,a
    3005   00:507A  20 05                   jr  nz,TCPIP_DNSQ_IP_ST2.1
    3006   00:507C  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3007   00:507F  18 F4                   jr  TCPIP_DNSQ_IP_ST2
    3008   00:5081                      TCPIP_DNSQ_IP_ST2.1:
    3009   00:5081                          ; nz, get it
    3010   00:5081                          RECEIVE_DATA
    3010   00:5081  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3011   00:5084  67                      ld  h,a
    3012   00:5085                      TCPIP_DNSQ_IP_ST3:
    3013   00:5085                          CHECK_DATA
    3013   00:5085  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3013   00:5088  CB 47             >     bit 0,a
    3014   00:508A  20 05                   jr  nz,TCPIP_DNSQ_IP_ST3.1
    3015   00:508C  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3016   00:508F  18 F4                   jr  TCPIP_DNSQ_IP_ST3
    3017   00:5091                      TCPIP_DNSQ_IP_ST3.1:
    3018   00:5091                          ; nz, get it
    3019   00:5091                          RECEIVE_DATA
    3019   00:5091  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3020   00:5094  5F                      ld  e,a
    3021   00:5095                      TCPIP_DNSQ_IP_ST4:
    3022   00:5095                          CHECK_DATA
    3022   00:5095  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3022   00:5098  CB 47             >     bit 0,a
    3023   00:509A  20 05                   jr  nz,TCPIP_DNSQ_IP_ST4.1
    3024   00:509C  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3025   00:509F  18 F4                   jr  TCPIP_DNSQ_IP_ST4
    3026   00:50A1                      TCPIP_DNSQ_IP_ST4.1:
    3027   00:50A1                          ; nz, get it
    3028   00:50A1                          RECEIVE_DATA
    3028   00:50A1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3029   00:50A4  57                      ld  d,a
    3030   00:50A5                          ; done
    3031   00:50A5  3E 01                   ld  a,1
    3032   00:50A7  CD 04 5B                call    SETDNSREADY             ; DNS done
    3033   00:50AA  CD 2E 5B                call    SETDNSRESULT            ; DNS RESULT
    3034   00:50AD  06 02                   ld  b,2
    3035   00:50AF  AF                      xor a
    3036   00:50B0  C9                      ret
    3037   00:50B1                      
    3038   00:50B1                      ;=====================
    3039   00:50B1                      ;===  TCPIP_DNS_S  ===
    3040   00:50B1                      ;=====================
    3041   00:50B1                      ;Obtains the host name resolution process state and result.
    3042   00:50B1                      ;
    3043   00:50B1                      ;Input:  A = 7
    3044   00:50B1                      ;        B = Flags, when set to 1 they instruct the resolver to:
    3045   00:50B1                      ;            bit 0: Clear any existing result or error condition after the execution
    3046   00:50B1                      ;                   (except if there is a query in progress)
    3047   00:50B1                      ;Output: A = Error code
    3048   00:50B1                      ;        B = DNS error code (when error is ERR_DNS)
    3049   00:50B1                      ;        B = Current query status (when error is ERR_OK):
    3050   00:50B1                      ;            0: There is no query in progress, nor any result nor error code available
    3051   00:50B1                      ;            1: There is a query in progress
    3052   00:50B1                      ;            2: Query is complete
    3053   00:50B1                      ;        C = Current query sub status (when error is ERR_OK and B=1):
    3054   00:50B1                      ;            0: Unknown
    3055   00:50B1                      ;            1: Querying the primary DNS server
    3056   00:50B1                      ;            2: Querying the secondary DNS server
    3057   00:50B1                      ;            3: Querying another DNS server
    3058   00:50B1                      ;        C = Resolution process type (when error is ERR_OK and B=2):
    3059   00:50B1                      ;            0: The name was obtained by querying a DNS server
    3060   00:50B1                      ;            1: The name was a direct representation of an IP address
    3061   00:50B1                      ;            2: The name was resolved locally
    3062   00:50B1                      ;       L.H.E.D = Resolved IP address (when error is ERR_OK and B=2)
    3063   00:50B1                      TCPIP_DNS_S:
    3064   00:50B1                          ;--- Is there a result?
    3065   00:50B1  CD F2 5A                call    GETDNSREADY             ; DNS done?
    3066   00:50B4  B7                      or  a
    3067   00:50B5  28 23                   jr  z,TCPIP_DNS_S_NORESULT      ; No DNS result
    3068   00:50B7                          ;--- Ok, we have a result, is it success?
    3069   00:50B7  3D                      dec a
    3070   00:50B8  28 12                   jr  z,TCPIP_DNS_S_HASRESULT     ; If it is 1, it was not an error
    3071   00:50BA                          ;--- Shoot, there is an error...
    3072   00:50BA                          ;--- And sure thing, ESP do not tell us details, it is always failure :-P
    3073   00:50BA  CB 40                   bit 0,b                         ;--- clear error after this?
    3074   00:50BC  28 09                   jr  z,TCP_IP_DNS_S_NOCLR
    3075   00:50BE                          ;--- Clear
    3076   00:50BE  06 00                   ld b,0                          ;--- Like I've said, no details
    3077   00:50C0  AF                      xor a
    3078   00:50C1  CD 04 5B                call    SETDNSREADY             ; DNS not done
    3079   00:50C4  3E 08                   ld  a,ERR_DNS;
    3080   00:50C6  C9                      ret
    3081   00:50C7                      TCP_IP_DNS_S_NOCLR:
    3082   00:50C7                          ;--- Don't clear
    3083   00:50C7  3E 08                   ld  a,ERR_DNS
    3084   00:50C9  06 00                   ld  b,0                         ;--- Like I've said, no details
    3085   00:50CB  C9                      ret
    3086   00:50CC                          ;--- There is a result available...
    3087   00:50CC                      TCPIP_DNS_S_HASRESULT:
    3088   00:50CC                          ;--- Copy the result
    3089   00:50CC  CD 18 5B                call    GETDNSRESULT
    3090   00:50CF  AF                      xor a
    3091   00:50D0  CB 40                   bit 0,b                         ;--- clear result after this?
    3092   00:50D2  28 03                   jr  z,TCP_IP_DNS_S_RES_NOCLR    ;--- no, just return
    3093   00:50D4                          ;--- Yes, clear
    3094   00:50D4  CD 04 5B                call    SETDNSREADY             ; DNS not done
    3095   00:50D7                      TCP_IP_DNS_S_RES_NOCLR:
    3096   00:50D7  06 02                   ld  b,2
    3097   00:50D9  C9                      ret
    3098   00:50DA                      
    3099   00:50DA                      TCPIP_DNS_S_NORESULT:
    3100   00:50DA  AF                      xor a                           ;--- OK no query in progress, no result, means nothing in progress
    3101   00:50DB  06 00                   ld  b,0                         ;--- No query in progress
    3102   00:50DD  C9                      ret
    3103   00:50DE                      
    3104   00:50DE                      ;========================
    3105   00:50DE                      ;===  TCPIP_UDP_OPEN  ===
    3106   00:50DE                      ;========================
    3107   00:50DE                      ;Open an UDP connection.
    3108   00:50DE                      ;
    3109   00:50DE                      ;Input:  A  = 8
    3110   00:50DE                      ;        HL = Local port number (#FFFF=random)
    3111   00:50DE                      ;        B  = Intended connection lifetime:
    3112   00:50DE                      ;             0: Transient
    3113   00:50DE                      ;             1: Resident
    3114   00:50DE                      ;Output: A = Error code
    3115   00:50DE                      ;        B = Connection number
    3116   00:50DE                      TCPIP_UDP_OPEN:
    3117   00:50DE                          SEND_DATA                       ; Send the command
    3117   00:50DE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3118   00:50E1  AF                      xor a
    3119   00:50E2                          SEND_DATA                       ; Send the command size msb
    3119   00:50E2  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3120   00:50E5  3E 03                   ld  a,3
    3121   00:50E7                          SEND_DATA                       ; Send the command size lsb
    3121   00:50E7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3122   00:50EA  7D                      ld  a,l
    3123   00:50EB                          SEND_DATA                       ; Send the port LSB
    3123   00:50EB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3124   00:50EE  7C                      ld  a,h
    3125   00:50EF                          SEND_DATA                       ; Send the port MSB
    3125   00:50EF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3126   00:50F2  78                      ld  a,b
    3127   00:50F3                          SEND_DATA                       ; Send the connection transient/resident
    3127   00:50F3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3128   00:50F6                      
    3129   00:50F6                          ; Now wait up to 180 ticks to get response
    3130   00:50F6  21 B4 00                ld  hl,180
    3131   00:50F9  CD 0D 5A                call    SETCOUNTER
    3132   00:50FC                      TCPIP_UDP_OPEN_ST1:
    3133   00:50FC                          CHECK_DATA
    3133   00:50FC  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3133   00:50FF  CB 47             >     bit 0,a
    3134   00:5101  20 05                   jr  nz,TCPIP_UDP_OPEN_ST1.1
    3135   00:5103  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3136   00:5106  18 F4                   jr  TCPIP_UDP_OPEN_ST1
    3137   00:5108                      TCPIP_UDP_OPEN_ST1.1:
    3138   00:5108                          ; nz, check the data
    3139   00:5108                          RECEIVE_DATA
    3139   00:5108  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3140   00:510B  FE 08                   cp  8                           ; Is response of our command?
    3141   00:510D  20 ED                   jr  nz,TCPIP_UDP_OPEN_ST1
    3142   00:510F                          ; now get return code, if return code other than 0, it is finished
    3143   00:510F                      TCPIP_UDP_OPEN_RC:
    3144   00:510F                          CHECK_DATA
    3144   00:510F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3144   00:5112  CB 47             >     bit 0,a
    3145   00:5114  20 05                   jr  nz,TCPIP_UDP_OPEN_RC.1
    3146   00:5116  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3147   00:5119  18 F4                   jr  TCPIP_UDP_OPEN_RC
    3148   00:511B                      TCPIP_UDP_OPEN_RC.1:
    3149   00:511B                          ; nz, discard
    3150   00:511B                          RECEIVE_DATA
    3150   00:511B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3151   00:511E  B7                      or  a                           ; 0?
    3152   00:511F  C0                      ret nz                          ; if not, done
    3153   00:5120                      
    3154   00:5120                          ; next two bytes are return code and size bytes, don't care, it is 1, conn #
    3155   00:5120  06 02                   ld  b,2
    3156   00:5122                      TCPIP_UDP_OPEN_ST2:
    3157   00:5122                          CHECK_DATA
    3157   00:5122  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3157   00:5125  CB 47             >     bit 0,a
    3158   00:5127  20 05                   jr  nz,TCPIP_UDP_OPEN_ST2.1
    3159   00:5129  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3160   00:512C  18 F4                   jr  TCPIP_UDP_OPEN_ST2
    3161   00:512E                      TCPIP_UDP_OPEN_ST2.1:
    3162   00:512E                          ; nz, discard
    3163   00:512E                          RECEIVE_DATA
    3163   00:512E  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3164   00:5131  05                      dec b
    3165   00:5132  20 EE                   jr  nz,TCPIP_UDP_OPEN_ST2
    3166   00:5134                      
    3167   00:5134                          ; now just get the 1 byte, conn#, should go to B
    3168   00:5134                      TCPIP_UDP_OPEN_CONN_ST1:
    3169   00:5134                          CHECK_DATA
    3169   00:5134  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3169   00:5137  CB 47             >     bit 0,a
    3170   00:5139  20 05                   jr  nz,TCPIP_UDP_OPEN_CONN_ST1.1
    3171   00:513B  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3172   00:513E  18 F4                   jr  TCPIP_UDP_OPEN_CONN_ST1
    3173   00:5140                      TCPIP_UDP_OPEN_CONN_ST1.1:
    3174   00:5140                          ; nz, get it
    3175   00:5140                          RECEIVE_DATA
    3175   00:5140  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3176   00:5143  47                      ld  b,a
    3177   00:5144                          ; done
    3178   00:5144  AF                      xor a
    3179   00:5145  C9                      ret
    3180   00:5146                      
    3181   00:5146                      ;=========================
    3182   00:5146                      ;===  TCPIP_UDP_CLOSE  ===
    3183   00:5146                      ;=========================
    3184   00:5146                      ;Close a UDP connection.
    3185   00:5146                      ;
    3186   00:5146                      ;Input:  A = 9
    3187   00:5146                      ;        B = Connection number
    3188   00:5146                      ;            0 to close all open transient UDP connections
    3189   00:5146                      ;Output: A = Error code
    3190   00:5146                      TCPIP_UDP_CLOSE:
    3191   00:5146                          SEND_DATA                       ; Send the command
    3191   00:5146  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3192   00:5149  AF                      xor a
    3193   00:514A                          SEND_DATA                       ; Send the command size msb
    3193   00:514A  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3194   00:514D  3E 01                   ld  a,1
    3195   00:514F                          SEND_DATA                       ; Send the command size lsb
    3195   00:514F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3196   00:5152  78                      ld  a,b
    3197   00:5153                          SEND_DATA                       ; Send the connection #
    3197   00:5153  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3198   00:5156                          ; Now wait up to 180 ticks to get response
    3199   00:5156  21 B4 00                ld  hl,180
    3200   00:5159  CD 0D 5A                call    SETCOUNTER
    3201   00:515C                      TCPIP_UDP_CLOSE_ST1:
    3202   00:515C                          CHECK_DATA
    3202   00:515C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3202   00:515F  CB 47             >     bit 0,a
    3203   00:5161  20 05                   jr  nz,TCPIP_UDP_CLOSE_ST1.1
    3204   00:5163  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3205   00:5166  18 F4                   jr  TCPIP_UDP_CLOSE_ST1
    3206   00:5168                      TCPIP_UDP_CLOSE_ST1.1:
    3207   00:5168                          ; nz, check the data
    3208   00:5168                          RECEIVE_DATA
    3208   00:5168  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3209   00:516B  FE 09                   cp  9                           ; Is response of our command?
    3210   00:516D  20 ED                   jr  nz,TCPIP_UDP_CLOSE_ST1
    3211   00:516F                          ; now get return code, if return code other than 0, it is finished
    3212   00:516F                      TCPIP_UDP_CLOSE_RC:
    3213   00:516F                          CHECK_DATA
    3213   00:516F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3213   00:5172  CB 47             >     bit 0,a
    3214   00:5174  20 05                   jr  nz,TCPIP_UDP_CLOSE_RC.1
    3215   00:5176  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3216   00:5179  18 F4                   jr  TCPIP_UDP_CLOSE_RC
    3217   00:517B                      TCPIP_UDP_CLOSE_RC.1:
    3218   00:517B                          ; nz, discard
    3219   00:517B                          RECEIVE_DATA
    3219   00:517B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3220   00:517E  B7                      or  a                           ; 0?
    3221   00:517F  C0                      ret nz                          ; if not, done
    3222   00:5180                      
    3223   00:5180                          ; next two bytes are return code and size bytes, don't care, it is 1, conn #
    3224   00:5180  06 02                   ld  b,2
    3225   00:5182                      TCPIP_UDP_CLOSE_ST2:
    3226   00:5182                          CHECK_DATA
    3226   00:5182  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3226   00:5185  CB 47             >     bit 0,a
    3227   00:5187  20 05                   jr  nz,TCPIP_UDP_CLOSE_ST2.1
    3228   00:5189  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3229   00:518C  18 F4                   jr  TCPIP_UDP_CLOSE_ST2
    3230   00:518E                      TCPIP_UDP_CLOSE_ST2.1:
    3231   00:518E                          ; nz, discard
    3232   00:518E                          RECEIVE_DATA
    3232   00:518E  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3233   00:5191  05                      dec b
    3234   00:5192  20 EE                   jr  nz,TCPIP_UDP_CLOSE_ST2
    3235   00:5194                      
    3236   00:5194                          ; done, no return data other than return code
    3237   00:5194  AF                      xor a
    3238   00:5195  C9                      ret
    3239   00:5196                      
    3240   00:5196                      ;=========================
    3241   00:5196                      ;===  TCPIP_UDP_STATE  ===
    3242   00:5196                      ;=========================
    3243   00:5196                      ;Get the state of a UDP connection.
    3244   00:5196                      ;
    3245   00:5196                      ;Input:  A = 10
    3246   00:5196                      ;        B = Connection number
    3247   00:5196                      ;Output: A  = Error code
    3248   00:5196                      ;        HL = Local port number
    3249   00:5196                      ;        B  = Number of pending incoming datagrams
    3250   00:5196                      ;        DE = Size of oldest pending incoming datagram (data part only)
    3251   00:5196                      TCPIP_UDP_STATE:
    3252   00:5196                          SEND_DATA                       ; Send the command
    3252   00:5196  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3253   00:5199  AF                      xor a
    3254   00:519A                          SEND_DATA                       ; Send the command size msb
    3254   00:519A  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3255   00:519D  3C                      inc a
    3256   00:519E                          SEND_DATA                       ; Send the command size lsb
    3256   00:519E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3257   00:51A1  78                      ld  a,b
    3258   00:51A2                          SEND_DATA                       ; Send the parameter
    3258   00:51A2  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3259   00:51A5                      
    3260   00:51A5                          ; Now wait up to 60 ticks to get response
    3261   00:51A5  21 3C 00                ld  hl,60
    3262   00:51A8  CD 0D 5A                call    SETCOUNTER
    3263   00:51AB                      TCPIP_UDP_STATE_ST1:
    3264   00:51AB                          CHECK_DATA
    3264   00:51AB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3264   00:51AE  CB 47             >     bit 0,a
    3265   00:51B0  20 05                   jr  nz,TCPIP_UDP_STATE_ST1.1
    3266   00:51B2  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3267   00:51B5  18 F4                   jr  TCPIP_UDP_STATE_ST1
    3268   00:51B7                      TCPIP_UDP_STATE_ST1.1:
    3269   00:51B7                          ; nz, check the data
    3270   00:51B7                          RECEIVE_DATA
    3270   00:51B7  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3271   00:51BA  FE 0A                   cp  10                          ; Is response of our command?
    3272   00:51BC  20 ED                   jr  nz,TCPIP_UDP_STATE_ST1
    3273   00:51BE                          ; now get return code, if return code other than 0, it is finished
    3274   00:51BE                      TCPIP_UDP_STATE_RC:
    3275   00:51BE                          CHECK_DATA
    3275   00:51BE  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3275   00:51C1  CB 47             >     bit 0,a
    3276   00:51C3  20 05                   jr  nz,TCPIP_UDP_STATE_RC.1
    3277   00:51C5  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3278   00:51C8  18 F4                   jr  TCPIP_UDP_STATE_RC
    3279   00:51CA                      TCPIP_UDP_STATE_RC.1:
    3280   00:51CA                          ; nz, discard
    3281   00:51CA                          RECEIVE_DATA
    3281   00:51CA  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3282   00:51CD  B7                      or  a                           ; 0?
    3283   00:51CE  C0                      ret nz                          ; if not, done
    3284   00:51CF                      
    3285   00:51CF                          ; next two bytes are return code and size bytes, don't care, it is 5
    3286   00:51CF  06 02                   ld  b,2
    3287   00:51D1                      TCPIP_UDP_STATE_ST2:
    3288   00:51D1                          CHECK_DATA
    3288   00:51D1  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3288   00:51D4  CB 47             >     bit 0,a
    3289   00:51D6  20 05                   jr  nz,TCPIP_UDP_STATE_ST2.1
    3290   00:51D8  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3291   00:51DB  18 F4                   jr  TCPIP_UDP_STATE_ST2
    3292   00:51DD                      TCPIP_UDP_STATE_ST2.1:
    3293   00:51DD                          ; nz, discard
    3294   00:51DD                          RECEIVE_DATA
    3294   00:51DD  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3295   00:51E0  05                      dec b
    3296   00:51E1  20 EE                   jr  nz,TCPIP_UDP_STATE_ST2
    3297   00:51E3                      
    3298   00:51E3                          ; now just get the 5 bytes (Port LSB then MSB, # of packets, packet size LSB then MSB) and order it in L, H, B, E and D
    3299   00:51E3                      TCPIP_UDP_STATE_RESP_ST1:
    3300   00:51E3                          CHECK_DATA
    3300   00:51E3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3300   00:51E6  CB 47             >     bit 0,a
    3301   00:51E8  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST1.1
    3302   00:51EA  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3303   00:51ED  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST1
    3304   00:51EF                      TCPIP_UDP_STATE_RESP_ST1.1:
    3305   00:51EF                          ; nz, get it
    3306   00:51EF                          RECEIVE_DATA
    3306   00:51EF  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3307   00:51F2  6F                      ld  l,a
    3308   00:51F3                      TCPIP_UDP_STATE_RESP_ST2:
    3309   00:51F3                          CHECK_DATA
    3309   00:51F3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3309   00:51F6  CB 47             >     bit 0,a
    3310   00:51F8  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST2.1
    3311   00:51FA  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3312   00:51FD  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST2
    3313   00:51FF                      TCPIP_UDP_STATE_RESP_ST2.1:
    3314   00:51FF                          ; nz, get it
    3315   00:51FF                          RECEIVE_DATA
    3315   00:51FF  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3316   00:5202  67                      ld  h,a
    3317   00:5203                      TCPIP_UDP_STATE_RESP_ST3:
    3318   00:5203                          CHECK_DATA
    3318   00:5203  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3318   00:5206  CB 47             >     bit 0,a
    3319   00:5208  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST3.1
    3320   00:520A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3321   00:520D  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST3
    3322   00:520F                      TCPIP_UDP_STATE_RESP_ST3.1:
    3323   00:520F                          ; nz, get it
    3324   00:520F                          RECEIVE_DATA
    3324   00:520F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3325   00:5212  47                      ld  b,a
    3326   00:5213                      TCPIP_UDP_STATE_RESP_ST4:
    3327   00:5213                          CHECK_DATA
    3327   00:5213  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3327   00:5216  CB 47             >     bit 0,a
    3328   00:5218  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST4.1
    3329   00:521A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3330   00:521D  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST4
    3331   00:521F                      TCPIP_UDP_STATE_RESP_ST4.1:
    3332   00:521F                          ; nz, get it
    3333   00:521F                          RECEIVE_DATA
    3333   00:521F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3334   00:5222  5F                      ld  e,a
    3335   00:5223                      TCPIP_UDP_STATE_RESP_ST5:
    3336   00:5223                          CHECK_DATA
    3336   00:5223  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3336   00:5226  CB 47             >     bit 0,a
    3337   00:5228  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST5.1
    3338   00:522A  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3339   00:522D  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST5
    3340   00:522F                      TCPIP_UDP_STATE_RESP_ST5.1:
    3341   00:522F                          ; nz, get it
    3342   00:522F                          RECEIVE_DATA
    3342   00:522F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3343   00:5232  57                      ld  d,a
    3344   00:5233                          ; done
    3345   00:5233  AF                      xor a
    3346   00:5234  C9                      ret
    3347   00:5235                      
    3348   00:5235                      ;========================
    3349   00:5235                      ;===  TCPIP_UDP_SEND  ===
    3350   00:5235                      ;========================
    3351   00:5235                      ;Send an UDP datagram.
    3352   00:5235                      ;
    3353   00:5235                      ;Input:  A = 11
    3354   00:5235                      ;        B = Connection number
    3355   00:5235                      ;        HL = Address of datagram data
    3356   00:5235                      ;        DE = Address of parameters block
    3357   00:5235                      ;Output: A = Error code
    3358   00:5235                      ;
    3359   00:5235                      ;Parameters block:
    3360   00:5235                      ;
    3361   00:5235                      ;    +0 (4): Destination IP address
    3362   00:5235                      ;    +4 (2): Destination port
    3363   00:5235                      ;    +6 (2): Data length
    3364   00:5235                      TCPIP_UDP_SEND:
    3365   00:5235  E5                      push    hl
    3366   00:5236  D5                      push    de
    3367   00:5237                          SEND_DATA                       ; Send the command
    3367   00:5237  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3368   00:523A                          ; prepare new data size, adding our 7 bytes overhead
    3369   00:523A  DD 62                   ld  ixh,d
    3370   00:523C  DD 6B                   ld  ixl,e
    3371   00:523E  11 07 00                ld  de,7
    3372   00:5241  DD 6E 06                ld  l,(ix+6)
    3373   00:5244  DD 66 07                ld  h,(ix+7)
    3374   00:5247  19                      add hl,de
    3375   00:5248  7C                      ld  a,h
    3376   00:5249                          SEND_DATA                       ; Send the command size msb
    3376   00:5249  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3377   00:524C  7D                      ld  a,l
    3378   00:524D                          SEND_DATA                       ; Send the command size lsb
    3378   00:524D  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3379   00:5250  78                      ld  a,b
    3380   00:5251                          SEND_DATA                       ; Send the connection #
    3380   00:5251  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3381   00:5254  D1                      pop de
    3382   00:5255  E1                      pop hl
    3383   00:5256  1A                      ld  a,(de)
    3384   00:5257                          SEND_DATA                       ; Send IP byte 1
    3384   00:5257  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3385   00:525A  13                      inc de
    3386   00:525B  1A                      ld  a,(de)
    3387   00:525C                          SEND_DATA                       ; Send IP byte 2
    3387   00:525C  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3388   00:525F  13                      inc de
    3389   00:5260  1A                      ld  a,(de)
    3390   00:5261                          SEND_DATA                       ; Send IP byte 3
    3390   00:5261  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3391   00:5264  13                      inc de
    3392   00:5265  1A                      ld  a,(de)
    3393   00:5266                          SEND_DATA                       ; Send IP byte 4
    3393   00:5266  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3394   00:5269  13                      inc de
    3395   00:526A  1A                      ld  a,(de)
    3396   00:526B                          SEND_DATA                       ; Send Port LSB
    3396   00:526B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3397   00:526E  13                      inc de
    3398   00:526F  1A                      ld  a,(de)
    3399   00:5270                          SEND_DATA                       ; Send Port MSB
    3399   00:5270  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3400   00:5273                          ; now oti the data starting at hl, size is in next DE position
    3401   00:5273  13                      inc de
    3402   00:5274  1A                      ld  a,(de)
    3403   00:5275  47                      ld  b,a                         ; save lsb in b
    3404   00:5276  13                      inc de
    3405   00:5277  1A                      ld  a,(de)                      ; msb
    3406   00:5278  57                      ld  d,a                         ; put in D, there is no ld d,(de)
    3407   00:5279  58                      ld  e,b                         ; lsb
    3408   00:527A                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    3409   00:527A                          ;ld b,e                         ; Number of loops originaly in DE, not needed, b already has e
    3410   00:527A  1B                      dec de
    3411   00:527B  14                      inc d
    3412   00:527C                          if USE_MEM_IO = 0
    3413   00:527C                    ~     ld  c,OUT_TX_PORT
    3414   00:527C                    ~ TCPIP_UDP_SEND_R:
    3415   00:527C                    ~     otir                            ; Send until B is 0
    3416   00:527C                    ~     else
    3417   00:527C                      TCPIP_UDP_SEND_R:
    3418   00:527C  7E                      ld  a,(hl)
    3419   00:527D  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3420   00:5280  23                      inc hl
    3421   00:5281  10 F9                   djnz TCPIP_UDP_SEND_R
    3422   00:5283                          endif
    3423   00:5283  15                      dec d                           ; decrement secondary counter
    3424   00:5284  20 F6                   jr  nz,TCPIP_UDP_SEND_R         ; If still have another round, do it
    3425   00:5286                          ; Now wait up to 600 ticks to get response
    3426   00:5286  21 58 02                ld  hl,600
    3427   00:5289  CD 0D 5A                call    SETCOUNTER
    3428   00:528C                      TCPIP_UDP_SEND_ST1:
    3429   00:528C                          CHECK_DATA
    3429   00:528C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3429   00:528F  CB 47             >     bit 0,a
    3430   00:5291  20 05                   jr  nz,TCPIP_UDP_SEND_ST1.1
    3431   00:5293  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3432   00:5296  18 F4                   jr  TCPIP_UDP_SEND_ST1
    3433   00:5298                      TCPIP_UDP_SEND_ST1.1:
    3434   00:5298                          ; nz, check the data
    3435   00:5298                          RECEIVE_DATA
    3435   00:5298  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3436   00:529B  FE 0B                   cp  11                          ; Is response of our command?
    3437   00:529D  20 ED                   jr  nz,TCPIP_UDP_SEND_ST1
    3438   00:529F                          ; now get return code, if return code other than 0, it is finished
    3439   00:529F                      TCPIP_UDP_SEND_RC:
    3440   00:529F                          CHECK_DATA
    3440   00:529F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3440   00:52A2  CB 47             >     bit 0,a
    3441   00:52A4  20 05                   jr  nz,TCPIP_UDP_SEND_RC.1
    3442   00:52A6  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3443   00:52A9  18 F4                   jr  TCPIP_UDP_SEND_RC
    3444   00:52AB                      TCPIP_UDP_SEND_RC.1:
    3445   00:52AB                          ; nz, discard
    3446   00:52AB                          RECEIVE_DATA
    3446   00:52AB  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3447   00:52AE  B7                      or  a                           ; 0?
    3448   00:52AF  C0                      ret nz                          ; if not, done
    3449   00:52B0                      
    3450   00:52B0                          ; next two bytes are return code and size bytes, don't care, it is 0
    3451   00:52B0  06 02                   ld  b,2
    3452   00:52B2                      TCPIP_UDP_SEND_ST2:
    3453   00:52B2                          CHECK_DATA
    3453   00:52B2  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3453   00:52B5  CB 47             >     bit 0,a
    3454   00:52B7  20 05                   jr  nz,TCPIP_UDP_SEND_ST2.1
    3455   00:52B9  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3456   00:52BC  18 F4                   jr  TCPIP_UDP_SEND_ST2
    3457   00:52BE                      TCPIP_UDP_SEND_ST2.1:
    3458   00:52BE                          ; nz, discard
    3459   00:52BE                          RECEIVE_DATA
    3459   00:52BE  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3460   00:52C1  05                      dec b
    3461   00:52C2  20 EE                   jr  nz,TCPIP_UDP_SEND_ST2
    3462   00:52C4                      
    3463   00:52C4                          ; done, no return data other than return code
    3464   00:52C4  AF                      xor a
    3465   00:52C5  C9                      ret
    3466   00:52C6                      
    3467   00:52C6                      ;=======================
    3468   00:52C6                      ;===  TCPIP_UDP_RCV  ===
    3469   00:52C6                      ;=======================
    3470   00:52C6                      ;Retrieve an incoming UDP datagram.
    3471   00:52C6                      ;
    3472   00:52C6                      ;Input:  A = 12
    3473   00:52C6                      ;        B = Connection number
    3474   00:52C6                      ;        HL = Address for datagram data
    3475   00:52C6                      ;        DE = Maximum data size to retrieve
    3476   00:52C6                      ;Output: A = Error code
    3477   00:52C6                      ;        L.H.E.D = Source IP address
    3478   00:52C6                      ;        IX = Source port
    3479   00:52C6                      ;        BC = Actual received data size
    3480   00:52C6                      
    3481   00:52C6                      ; Customized TIME OUT routine: If time out receiving data, retry as received data
    3482   00:52C6                      ; won't be re-sent as host is unaware of this
    3483   00:52C6                      TCPIP_UDP_RCV_CHECK_TIME_OUT:
    3484   00:52C6                          ; Save registers other than AF
    3485   00:52C6  C5                      push bc
    3486   00:52C7  D5                      push de
    3487   00:52C8  E5                      push hl
    3488   00:52C9  CD FE 59                call    GETCOUNTER
    3489   00:52CC  7D                      ld  a,l
    3490   00:52CD  B4                      or  h
    3491   00:52CE                          ; Restore registers, we are returning
    3492   00:52CE  E1                      pop hl
    3493   00:52CF  D1                      pop de
    3494   00:52D0  C1                      pop bc
    3495   00:52D1  C0                      ret nz
    3496   00:52D2                          ; Ok, timeout...
    3497   00:52D2  F1                      pop af                          ; Get return address of who called this out of the stack, we will return from the function or re-start
    3498   00:52D3                      TCPIP_TCP_UDP_RETRY_QRCV:
    3499   00:52D3  CD 1D 5A                call    GETBYTE
    3500   00:52D6  B7                      or  a
    3501   00:52D7  28 0C                   jr  z,TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY
    3502   00:52D9                          ; Ok, so let's ask ESP to re-send the data and retry receiving it
    3503   00:52D9  3D                      dec a
    3504   00:52DA  CD 2F 5A                call    SETBYTE                 ; we are retrying it
    3505   00:52DD  3E 72                   ld  a,'r'                       ; retry transmission command
    3506   00:52DF                          SEND_DATA
    3506   00:52DF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3507   00:52E2  C3 0A 53                jp  TCPIP_UDP_RCV.RXRETRY       ; and retry it
    3508   00:52E5                      TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY:
    3509   00:52E5  3E 0F                   ld  a,ERR_INV_OPER
    3510   00:52E7  C9                      ret                             ; and return the function itself
    3511   00:52E8                      
    3512   00:52E8                      TCPIP_UDP_RCV:
    3513   00:52E8  CD 56 5A                call    SETWORD                 ; Save for later the datagram address
    3514   00:52EB  3E 0C                   ld  a,12
    3515   00:52ED                          SEND_DATA                       ; Send the command
    3515   00:52ED  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3516   00:52F0  AF                      xor a
    3517   00:52F1                          SEND_DATA                       ; Send the command size msb
    3517   00:52F1  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3518   00:52F4  3E 03                   ld  a,3
    3519   00:52F6                          SEND_DATA                       ; Send the command size lsb
    3519   00:52F6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3520   00:52F9  78                      ld  a,b
    3521   00:52FA                          SEND_DATA                       ; Send the connection #
    3521   00:52FA  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3522   00:52FD  7B                      ld  a,e
    3523   00:52FE                          SEND_DATA                       ; Send MAX rcv size LSB
    3523   00:52FE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3524   00:5301  7A                      ld  a,d
    3525   00:5302                          SEND_DATA                       ; Send MAX rcv size MSB
    3525   00:5302  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3526   00:5305  3E 03                   ld  a,3
    3527   00:5307  CD 2F 5A                call    SETBYTE                 ; Ok, retry up to three times
    3528   00:530A                      TCPIP_UDP_RCV.RXRETRY:
    3529   00:530A                          ; Now wait up to 600 ticks to get response
    3530   00:530A  21 58 02                ld  hl,600
    3531   00:530D  CD 0D 5A                call    SETCOUNTER
    3532   00:5310                      TCPIP_UDP_RCV_ST1:
    3533   00:5310                          CHECK_DATA
    3533   00:5310  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3533   00:5313  CB 47             >     bit 0,a
    3534   00:5315  20 05                   jr  nz,TCPIP_UDP_RCV_ST1.1
    3535   00:5317  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3536   00:531A  18 F4                   jr  TCPIP_UDP_RCV_ST1
    3537   00:531C                      TCPIP_UDP_RCV_ST1.1:
    3538   00:531C                          ; nz, check the data
    3539   00:531C                          RECEIVE_DATA
    3539   00:531C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3540   00:531F  FE 0C                   cp  12                          ; Is response of our command?
    3541   00:5321  20 ED                   jr  nz,TCPIP_UDP_RCV_ST1
    3542   00:5323                          ; At this point, all data is being buffered, so 30 ticks, half second, is more than enough time-out
    3543   00:5323  F3                      di
    3544   00:5324  21 1E 00                ld  hl,30
    3545   00:5327  CD 0D 5A                call    SETCOUNTER
    3546   00:532A  FB                      ei
    3547   00:532B                          ; now get return code, if return code other than 0, it is finished
    3548   00:532B                      TCPIP_UDP_RCV_RC:
    3549   00:532B                          CHECK_DATA
    3549   00:532B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3549   00:532E  CB 47             >     bit 0,a
    3550   00:5330  20 05                   jr  nz,TCPIP_UDP_RCV_RC.1
    3551   00:5332  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3552   00:5335  18 F4                   jr  TCPIP_UDP_RCV_RC
    3553   00:5337                      TCPIP_UDP_RCV_RC.1:
    3554   00:5337                          ; nz, discard
    3555   00:5337                          RECEIVE_DATA
    3555   00:5337  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3556   00:533A  B7                      or  a                           ; 0?
    3557   00:533B  C0                      ret nz                          ; if not, done
    3558   00:533C                          ; next two bytes are return code and size bytes, save it to BC
    3559   00:533C                      TCPIP_UDP_RCV_ST2A:
    3560   00:533C                          CHECK_DATA
    3560   00:533C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3560   00:533F  CB 47             >     bit 0,a
    3561   00:5341  20 05                   jr  nz,TCPIP_UDP_RCV_ST2A.1
    3562   00:5343  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3563   00:5346  18 F4                   jr  TCPIP_UDP_RCV_ST2A
    3564   00:5348                      TCPIP_UDP_RCV_ST2A.1:
    3565   00:5348                          ; nz, discard
    3566   00:5348                          RECEIVE_DATA
    3566   00:5348  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3567   00:534B  67                      ld  h,a
    3568   00:534C                      TCPIP_UDP_RCV_ST2B:
    3569   00:534C                          CHECK_DATA
    3569   00:534C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3569   00:534F  CB 47             >     bit 0,a
    3570   00:5351  20 05                   jr  nz,TCPIP_UDP_RCV_ST2B.1
    3571   00:5353  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3572   00:5356  18 F4                   jr  TCPIP_UDP_RCV_ST2B
    3573   00:5358                      TCPIP_UDP_RCV_ST2B.1:
    3574   00:5358                          ; nz, discard
    3575   00:5358                          RECEIVE_DATA
    3575   00:5358  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3576   00:535B  6F                      ld  l,a
    3577   00:535C  01 06 00                ld  bc,6
    3578   00:535F                          ; subtract 6 (IP and PORT)
    3579   00:535F  AF                      xor a                           ; zero carry
    3580   00:5360  ED 42                   sbc hl,bc
    3581   00:5362  4D                      ld  c,l
    3582   00:5363  44                      ld  b,h                         ; BC has effective received data size
    3583   00:5364                          ; now just get the 4 bytes IP and place it in L H E D
    3584   00:5364                      TCPIP_UDP_RCV_IP_ST1:
    3585   00:5364                          CHECK_DATA
    3585   00:5364  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3585   00:5367  CB 47             >     bit 0,a
    3586   00:5369  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST1.1
    3587   00:536B  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3588   00:536E  18 F4                   jr  TCPIP_UDP_RCV_IP_ST1
    3589   00:5370                      TCPIP_UDP_RCV_IP_ST1.1:
    3590   00:5370                          ; nz, get it
    3591   00:5370                          RECEIVE_DATA
    3591   00:5370  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3592   00:5373  6F                      ld  l,a
    3593   00:5374                      TCPIP_UDP_RCV_IP_ST2:
    3594   00:5374                          CHECK_DATA
    3594   00:5374  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3594   00:5377  CB 47             >     bit 0,a
    3595   00:5379  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST2.1
    3596   00:537B  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3597   00:537E  18 F4                   jr  TCPIP_UDP_RCV_IP_ST2
    3598   00:5380                      TCPIP_UDP_RCV_IP_ST2.1:
    3599   00:5380                          ; nz, get it
    3600   00:5380                          RECEIVE_DATA
    3600   00:5380  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3601   00:5383  67                      ld  h,a
    3602   00:5384                      TCPIP_UDP_RCV_IP_ST3:
    3603   00:5384                          CHECK_DATA
    3603   00:5384  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3603   00:5387  CB 47             >     bit 0,a
    3604   00:5389  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST3.1
    3605   00:538B  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3606   00:538E  18 F4                   jr  TCPIP_UDP_RCV_IP_ST3
    3607   00:5390                      TCPIP_UDP_RCV_IP_ST3.1:
    3608   00:5390                          ; nz, get it
    3609   00:5390                          RECEIVE_DATA
    3609   00:5390  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3610   00:5393  5F                      ld  e,a
    3611   00:5394                      TCPIP_UDP_RCV_IP_ST4:
    3612   00:5394                          CHECK_DATA
    3612   00:5394  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3612   00:5397  CB 47             >     bit 0,a
    3613   00:5399  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST4.1
    3614   00:539B  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3615   00:539E  18 F4                   jr  TCPIP_UDP_RCV_IP_ST4
    3616   00:53A0                      TCPIP_UDP_RCV_IP_ST4.1:
    3617   00:53A0                          ; nz, get it
    3618   00:53A0                          RECEIVE_DATA
    3618   00:53A0  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3619   00:53A3  57                      ld  d,a
    3620   00:53A4                          ; now get the 2 bytes port and place in IXL and IXH
    3621   00:53A4                      TCPIP_UDP_RCV_PORT_ST1:
    3622   00:53A4                          CHECK_DATA
    3622   00:53A4  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3622   00:53A7  CB 47             >     bit 0,a
    3623   00:53A9  20 05                   jr  nz,TCPIP_UDP_RCV_PORT_ST1.1
    3624   00:53AB  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3625   00:53AE  18 F4                   jr  TCPIP_UDP_RCV_PORT_ST1
    3626   00:53B0                      TCPIP_UDP_RCV_PORT_ST1.1:
    3627   00:53B0                          ; nz, get it
    3628   00:53B0                          RECEIVE_DATA
    3628   00:53B0  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3629   00:53B3  DD 6F                   ld  ixl,a
    3630   00:53B5                      TCPIP_UDP_RCV_PORT_ST2:
    3631   00:53B5                          CHECK_DATA
    3631   00:53B5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3631   00:53B8  CB 47             >     bit 0,a
    3632   00:53BA  20 05                   jr  nz,TCPIP_UDP_RCV_PORT_ST2.1
    3633   00:53BC  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3634   00:53BF  18 F4                   jr  TCPIP_UDP_RCV_PORT_ST2
    3635   00:53C1                      TCPIP_UDP_RCV_PORT_ST2.1:
    3636   00:53C1                          ; nz, get it
    3637   00:53C1                          RECEIVE_DATA
    3637   00:53C1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3638   00:53C4  DD 67                   ld  ixh,a
    3639   00:53C6                      
    3640   00:53C6                          ; save the received data in memory
    3641   00:53C6  CD 82 5A                call    REGBACKUP               ; Save the data received so far, registers will change
    3642   00:53C9                          ; will start moving at RCV_ADDRESS that was stored in our WORD
    3643   00:53C9  CD 43 5A                call    GETWORD
    3644   00:53CC                          ; size goes to DE
    3645   00:53CC  50                      ld  d,b
    3646   00:53CD  59                      ld  e,c
    3647   00:53CE                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use ini :-D
    3648   00:53CE  43                      ld  b,e                         ; Number of loops originaly in DE
    3649   00:53CF  1B                      dec de
    3650   00:53D0  14                      inc d
    3651   00:53D1                          if USE_MEM_IO = 0
    3652   00:53D1                    ~     ld  c,IN_DATA_PORT
    3653   00:53D1                    ~     endif
    3654   00:53D1                          CHECK_QUICK_RECEIVE
    3654   00:53D1  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3654   00:53D4  CB 5F             >     bit 3,a
    3655   00:53D6  28 17                   jr  z,TCPIP_UDP_RCV_R_NSF       ; If not, go to the old, slower route
    3656   00:53D8                          ; Otherwise, let's speed it up baby!
    3657   00:53D8                      TCPIP_UDP_RCV_R:
    3658   00:53D8                          if USE_MEM_IO = 0
    3659   00:53D8                    ~     inir
    3660   00:53D8                    ~     else
    3661   00:53D8  3A 06 7F                ld  a,(MEM_IN_DATA_PORT)
    3662   00:53DB  77                      ld  (hl),a
    3663   00:53DC  23                      inc hl
    3664   00:53DD  10 F9                   djnz TCPIP_UDP_RCV_R
    3665   00:53DF                          endif
    3666   00:53DF  15                      dec d
    3667   00:53E0  20 F6                   jr  nz,TCPIP_UDP_RCV_R
    3668   00:53E2                          CHECK_BUFFER_UNDERRUN
    3668   00:53E2  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3668   00:53E5  CB 67             >     bit 4,a
    3669   00:53E7  C2 D3 52                jp  nz,TCPIP_TCP_UDP_RETRY_QRCV ; If yes, retry
    3670   00:53EA                          ; Otherwise, done
    3671   00:53EA                          ; done, restore return data in DE BC and HL
    3672   00:53EA  CD 6B 5A                call    REGRESTORE
    3673   00:53ED  AF                      xor a
    3674   00:53EE  C9                      ret
    3675   00:53EF                          ; Slower route if Interface doesn't implement quick receive
    3676   00:53EF                      TCPIP_UDP_RCV_R_NSF:
    3677   00:53EF                          CHECK_DATA
    3677   00:53EF  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3677   00:53F2  CB 47             >     bit 0,a
    3678   00:53F4  20 05                   jr  nz,TCPIP_UDP_RCV_R_NSF.1
    3679   00:53F6  CD C6 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3680   00:53F9  18 F4                   jr  TCPIP_UDP_RCV_R_NSF
    3681   00:53FB                      TCPIP_UDP_RCV_R_NSF.1:
    3682   00:53FB                          if USE_MEM_IO = 0
    3683   00:53FB                    ~     ini
    3684   00:53FB                    ~     else
    3685   00:53FB  3A 06 7F                ld  a,(MEM_IN_DATA_PORT)
    3686   00:53FE  77                      ld  (hl),a
    3687   00:53FF  23                      inc hl
    3688   00:5400  05                      dec b
    3689   00:5401                          endif
    3690   00:5401  20 EC                   jr  nz,TCPIP_UDP_RCV_R_NSF          ; We do not use INIR because we don't know if there is more data, avoiding geting a junk 0xFF
    3691   00:5403  15                      dec d
    3692   00:5404  20 E9                   jr  nz,TCPIP_UDP_RCV_R_NSF
    3693   00:5406                          ; done, restore return data in DE BC and HL
    3694   00:5406  CD 6B 5A                call    REGRESTORE
    3695   00:5409  AF                      xor a
    3696   00:540A  C9                      ret
    3697   00:540B                      
    3698   00:540B                      ;========================
    3699   00:540B                      ;===  TCPIP_TCP_OPEN  ===
    3700   00:540B                      ;========================
    3701   00:540B                      ;Open a TCP connection.
    3702   00:540B                      ;
    3703   00:540B                      ;Input:  A  = 13
    3704   00:540B                      ;        HL = Address of parameters block
    3705   00:540B                      ;Output: A = Error code
    3706   00:540B                      ;        B = Connection number
    3707   00:540B                      ;        C = Connection not open reason (mostly for TLS)
    3708   00:540B                      ;
    3709   00:540B                      ;Parameters block format:
    3710   00:540B                      ;
    3711   00:540B                      ;+0 (4): Remote IP address (0.0.0.0 for unspecified remote socket)
    3712   00:540B                      ;+4 (2): Remote port (ignored if unspecified remote socket)
    3713   00:540B                      ;+6 (2): Local port, 0FFFFh for a random value
    3714   00:540B                      ;+8 (2): Suggestion for user timeout value
    3715   00:540B                      ;+10 (1): Flags:
    3716   00:540B                      ;         bit 0: Set for passive connection
    3717   00:540B                      ;         bit 1: Set for resident connection
    3718   00:540B                      ;         bit 2: Set for TLS connection
    3719   00:540B                      ;         bit 3: Set for TLS connection validating host certificate
    3720   00:540B                      ;+11 (2): If 0000 no host name validation, otherwise the hostname string address (zero terminated)
    3721   00:540B                      ;TCP_OPEN_IP1               (ix+0)
    3722   00:540B                      ;TCP_OPEN_IP2               (ix+1)
    3723   00:540B                      ;TCP_OPEN_IP3               (ix+2)
    3724   00:540B                      ;TCP_OPEN_IP4               (ix+3)
    3725   00:540B                      ;TCP_OPEN_RP                (ix+4)
    3726   00:540B                      ;TCP_OPEN_LP                (ix+6)
    3727   00:540B                      ;TCP_OPEN_TO                (ix+8)
    3728   00:540B                      ;TCP_OPEN_CMD_FLAGS         (ix+10)
    3729   00:540B                      ;TCP_OPEN_CMD_HOST_LSB      (ix+11)
    3730   00:540B                      ;TCP_OPEN_CMD_HOST_MSB      (ix+12)
    3731   00:540B                      
    3732   00:540B                      ; When no connection, let's get the reason and put in register C, as agreed
    3733   00:540B                      ; with Nestor this will be the way to go in the next UNAPI revision
    3734   00:540B                      TCPIP_TCP_OPEN_ERROR:
    3735   00:540B                          ; next two bytes are return code and size bytes, don't care, it is 1, conn close reason
    3736   00:540B  47                      ld  b,a                         ; save error in b
    3737   00:540C  0E 02                   ld  c,2
    3738   00:540E                      TCPIP_TCP_OPEN_ERROR2:
    3739   00:540E                          CHECK_DATA
    3739   00:540E  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3739   00:5411  CB 47             >     bit 0,a
    3740   00:5413  20 05                   jr  nz,TCPIP_TCP_OPEN_ERROR2.1
    3741   00:5415  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3742   00:5418  18 F4                   jr  TCPIP_TCP_OPEN_ERROR2
    3743   00:541A                      TCPIP_TCP_OPEN_ERROR2.1:
    3744   00:541A                          ; nz, discard
    3745   00:541A                          RECEIVE_DATA
    3745   00:541A  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3746   00:541D  0D                      dec c
    3747   00:541E  20 EE                   jr  nz,TCPIP_TCP_OPEN_ERROR2
    3748   00:5420  78                      ld  a,b
    3749   00:5421  FE 0B                   cp  ERR_NO_CONN
    3750   00:5423  20 10                   jr  nz,TCPIP_TCP_OPEN_ERROR4    ; other errors do not have extra bytes as result
    3751   00:5425                      ; now just get the 1 byte, close reason, should go to C
    3752   00:5425                      TCPIP_TCP_OPEN_ERROR3:
    3753   00:5425                          CHECK_DATA
    3753   00:5425  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3753   00:5428  CB 47             >     bit 0,a
    3754   00:542A  20 05                   jr  nz,TCPIP_TCP_OPEN_ERROR3.1
    3755   00:542C  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3756   00:542F  18 F4                   jr  TCPIP_TCP_OPEN_ERROR3
    3757   00:5431                      TCPIP_TCP_OPEN_ERROR3.1:
    3758   00:5431                          ; nz, get it
    3759   00:5431                          RECEIVE_DATA
    3759   00:5431  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3760   00:5434  4F                      ld  c,a
    3761   00:5435                      TCPIP_TCP_OPEN_ERROR4:
    3762   00:5435                          ; now return w/ error that is saved in b
    3763   00:5435  78                      ld  a,b
    3764   00:5436  06 00                   ld  b,0                         ; no connection, so 0
    3765   00:5438  C9                      ret
    3766   00:5439                      
    3767   00:5439                      TCPIP_TCP_OPEN:
    3768   00:5439  E5                      push    hl                      ; save param block address
    3769   00:543A  7C                      ld  a,h
    3770   00:543B  DD 67                   ld  ixh,a
    3771   00:543D  7D                      ld  a,l
    3772   00:543E  DD 6F                   ld  ixl,a
    3773   00:5440                          ; IX now has the parameters area
    3774   00:5440                          ; most times it will be non tls, so this is the first test case
    3775   00:5440  21 0B 00                ld  hl,11
    3776   00:5443  CD 56 5A                call    SETWORD                 ; If it is non-TLS, send 11 bytes
    3777   00:5446  DD 7E 0A                ld  a,(ix+10)                   ; TCP_OPEN_CMD_FLAGS
    3778   00:5449  CB 57                   bit 2,a
    3779   00:544B  28 4F                   jr  z,TCPIP_TCP_OPEN_NO_TLS
    3780   00:544D                      
    3781   00:544D                          ; TLS, but, do we have host name?
    3782   00:544D  21 0C 00                ld  hl,12
    3783   00:5450  CD 56 5A                call    SETWORD                 ; If it is TLS without host name, send 12 bytes, one zero as host name suffice
    3784   00:5453  DD 6E 0B                ld  l,(ix+11)                   ; TCP_OPEN_CMD_HOST_LSB
    3785   00:5456  DD 7E 0C                ld  a,(ix+12)                   ; TCP_OPEN_CMD_HOST_MSB
    3786   00:5459  B5                      or  l
    3787   00:545A                          ; if TLS and next two bytes are 00 no host to check
    3788   00:545A  28 40                   jr  z,TCPIP_TCP_OPEN_NO_CHECKHOST
    3789   00:545C                          ; we are here, host to check
    3790   00:545C  DD 66 0C                ld  h,(ix+12)                   ; TCP_OPEN_CMD_HOST_MSB
    3791   00:545F  D1                      pop de                          ; Retrieve parameters address
    3792   00:5460  E5                      push    hl                      ; Save host name address
    3793   00:5461  D5                      push    de                      ; Save Parameters address (so it is in the order we are going to need)
    3794   00:5462                          ; let's check how many bytes there are
    3795   00:5462  11 0B 00                ld  de,11                       ; Start with 11, all params except host name
    3796   00:5465                      TCPIP_TCP_OPEN_CHECK_HOSTOF:
    3797   00:5465  7E                      ld  a,(hl)
    3798   00:5466  13                      inc de                          ; Not zero, so increase size count
    3799   00:5467  23                      inc hl                          ; And next hostname byte
    3800   00:5468  B7                      or  a                           ; If zero, hostname terminated
    3801   00:5469                          ; Loop until terminator (0) is found
    3802   00:5469  C2 65 54                jp  nz,TCPIP_TCP_OPEN_CHECK_HOSTOF
    3803   00:546C                      
    3804   00:546C                      TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME:
    3805   00:546C                          ; Ok, so, DE has the full hostname size, let's start sending from here
    3806   00:546C  3E 0D                   ld  a,13                        ; Function TCP OPEN
    3807   00:546E                          SEND_DATA                       ; Send the command
    3807   00:546E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3808   00:5471  7A                      ld  a,d
    3809   00:5472                          SEND_DATA                       ; Send the command size msb
    3809   00:5472  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3810   00:5475  7B                      ld  a,e
    3811   00:5476                          SEND_DATA                       ; Send the command size lsb
    3811   00:5476  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3812   00:5479  E1                      pop hl                          ; Restore the memory address for the parameters
    3813   00:547A                          ; First send the 11 bytes parameters
    3814   00:547A                          if USE_MEM_IO = 0
    3815   00:547A                    ~     ld  c,OUT_TX_PORT
    3816   00:547A                    ~     outi
    3817   00:547A                    ~     outi
    3818   00:547A                    ~     outi
    3819   00:547A                    ~     outi
    3820   00:547A                    ~     outi
    3821   00:547A                    ~     outi
    3822   00:547A                    ~     outi
    3823   00:547A                    ~     outi
    3824   00:547A                    ~     outi
    3825   00:547A                    ~     outi
    3826   00:547A                    ~     outi                            ; Unrolled outi is a bit faster :)
    3827   00:547A                    ~     else
    3828   00:547A  06 0B                   ld  b,11                        ; Send 11 bytes
    3829   00:547C                      TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME_LOOP_PARAM:
    3830   00:547C  7E                      ld  a,(hl)
    3831   00:547D  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3832   00:5480  23                      inc hl
    3833   00:5481  10 F9                   djnz TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME_LOOP_PARAM
    3834   00:5483                          endif
    3835   00:5483  EB                      ex  de,hl                       ; Size in HL
    3836   00:5484  11 0B 00                ld  de,11
    3837   00:5487  B7                      or  a                           ; zero flag
    3838   00:5488  ED 52                   sbc hl,de
    3839   00:548A  EB                      ex de,hl                        ; and adjusted size back in de
    3840   00:548B  E1                      pop hl                          ; Restore the memory address for hostname
    3841   00:548C                      ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    3842   00:548C  43                      ld  b,e                         ; Number of loops originaly in DE
    3843   00:548D  1B                      dec de
    3844   00:548E  14                      inc d
    3845   00:548F                          if USE_MEM_IO = 0
    3846   00:548F                    ~     ld  c,OUT_TX_PORT
    3847   00:548F                    ~ TCPIP_TCP_OPEN_SENDHOSTNAME:
    3848   00:548F                    ~     outi
    3849   00:548F                    ~     jr  nz,TCPIP_TCP_OPEN_SENDHOSTNAME
    3850   00:548F                    ~     else
    3851   00:548F                      TCPIP_TCP_OPEN_SENDHOSTNAME:
    3852   00:548F  7E                      ld  a,(hl)
    3853   00:5490  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3854   00:5493  23                      inc hl
    3855   00:5494  10 F9                   djnz TCPIP_TCP_OPEN_SENDHOSTNAME
    3856   00:5496                          endif
    3857   00:5496  15                      dec d
    3858   00:5497  20 F6                   jr  nz,TCPIP_TCP_OPEN_SENDHOSTNAME
    3859   00:5499  C3 BC 54                jp  TCPIP_TCP_OPEN_WAIT_RESPONSE
    3860   00:549C                      
    3861   00:549C                      TCPIP_TCP_OPEN_NO_TLS:
    3862   00:549C                      TCPIP_TCP_OPEN_NO_CHECKHOST:
    3863   00:549C  3E 0D                   ld  a,13                        ; Function TCP OPEN
    3864   00:549E                          SEND_DATA                       ; Send the command
    3864   00:549E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3865   00:54A1  CD 43 5A                call    GETWORD
    3866   00:54A4  7C                      ld  a,h
    3867   00:54A5  57                      ld  d,a
    3868   00:54A6                          SEND_DATA                       ; Send the command size msb
    3868   00:54A6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3869   00:54A9  7D                      ld  a,l
    3870   00:54AA  5F                      ld  e,a
    3871   00:54AB                          SEND_DATA                       ; Send the command size lsb
    3871   00:54AB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3872   00:54AE                      
    3873   00:54AE  E1                      pop hl                          ; Restore the memory address for the parameters
    3874   00:54AF                      ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    3875   00:54AF  43                      ld  b,e                         ; Number of loops originaly in DE
    3876   00:54B0  1B                      dec de
    3877   00:54B1  14                      inc d
    3878   00:54B2                          if USE_MEM_IO = 0
    3879   00:54B2                    ~     ld  c,OUT_TX_PORT
    3880   00:54B2                    ~ TCPIP_TCP_OPEN_R:
    3881   00:54B2                    ~     outi
    3882   00:54B2                    ~     jr  nz,TCPIP_TCP_OPEN_R
    3883   00:54B2                    ~     else
    3884   00:54B2                      TCPIP_TCP_OPEN_R:
    3885   00:54B2  7E                      ld  a,(hl)
    3886   00:54B3  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3887   00:54B6  23                      inc hl
    3888   00:54B7  10 F9                   djnz TCPIP_TCP_OPEN_R
    3889   00:54B9                          endif
    3890   00:54B9  15                      dec d
    3891   00:54BA  20 F6                   jr  nz,TCPIP_TCP_OPEN_R
    3892   00:54BC                      
    3893   00:54BC                      TCPIP_TCP_OPEN_WAIT_RESPONSE:
    3894   00:54BC                          ; Now wait up to 3600 (1 minute @ 60Hz) ticks to get response
    3895   00:54BC                          ; TLS Connections might take SEVERAL seconds on TLS Handshake
    3896   00:54BC                          ; Even more if certificates database is being indexed
    3897   00:54BC  21 10 0E                ld  hl,3600
    3898   00:54BF  CD 0D 5A                call    SETCOUNTER
    3899   00:54C2                      TCPIP_TCP_OPEN_ST1:
    3900   00:54C2                          CHECK_DATA
    3900   00:54C2  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3900   00:54C5  CB 47             >     bit 0,a
    3901   00:54C7  20 05                   jr  nz,TCPIP_TCP_OPEN_ST1.1
    3902   00:54C9  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3903   00:54CC  18 F4                   jr  TCPIP_TCP_OPEN_ST1
    3904   00:54CE                      TCPIP_TCP_OPEN_ST1.1:
    3905   00:54CE                          ; nz, check the data
    3906   00:54CE                          RECEIVE_DATA
    3906   00:54CE  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3907   00:54D1  FE 0D                   cp  13                          ; Is response of our command?
    3908   00:54D3  20 ED                   jr  nz,TCPIP_TCP_OPEN_ST1
    3909   00:54D5                          ; now get return code, if return code other than 0, it is finished
    3910   00:54D5                      TCPIP_TCP_OPEN_RC:
    3911   00:54D5                          CHECK_DATA
    3911   00:54D5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3911   00:54D8  CB 47             >     bit 0,a
    3912   00:54DA  20 05                   jr  nz,TCPIP_TCP_OPEN_RC.1
    3913   00:54DC  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3914   00:54DF  18 F4                   jr  TCPIP_TCP_OPEN_RC
    3915   00:54E1                      TCPIP_TCP_OPEN_RC.1:
    3916   00:54E1                          ; nz, discard
    3917   00:54E1                          RECEIVE_DATA
    3917   00:54E1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3918   00:54E4  B7                      or  a                           ; 0?
    3919   00:54E5  C2 0B 54                jp  nz,TCPIP_TCP_OPEN_ERROR
    3920   00:54E8                      
    3921   00:54E8                          ; next two bytes are size bytes, don't care, it is 1, conn #
    3922   00:54E8  06 02                   ld  b,2
    3923   00:54EA                      TCPIP_TCP_OPEN_ST2:
    3924   00:54EA                          CHECK_DATA
    3924   00:54EA  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3924   00:54ED  CB 47             >     bit 0,a
    3925   00:54EF  20 05                   jr  nz,TCPIP_TCP_OPEN_ST2.1
    3926   00:54F1  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3927   00:54F4  18 F4                   jr  TCPIP_TCP_OPEN_ST2
    3928   00:54F6                      TCPIP_TCP_OPEN_ST2.1:
    3929   00:54F6                          ; nz, discard
    3930   00:54F6                          RECEIVE_DATA
    3930   00:54F6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3931   00:54F9  05                      dec b
    3932   00:54FA  20 EE                   jr  nz,TCPIP_TCP_OPEN_ST2
    3933   00:54FC                      
    3934   00:54FC                          ; now just get the 1 byte, conn#, should go to B
    3935   00:54FC                      TCPIP_TCP_OPEN_CONN_ST1:
    3936   00:54FC                          CHECK_DATA
    3936   00:54FC  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3936   00:54FF  CB 47             >     bit 0,a
    3937   00:5501  20 05                   jr  nz,TCPIP_TCP_OPEN_CONN_ST1.1
    3938   00:5503  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3939   00:5506  18 F4                   jr  TCPIP_TCP_OPEN_CONN_ST1
    3940   00:5508                      TCPIP_TCP_OPEN_CONN_ST1.1:
    3941   00:5508                          ; nz, get it
    3942   00:5508                          RECEIVE_DATA
    3942   00:5508  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3943   00:550B  47                      ld  b,a
    3944   00:550C                          ; done
    3945   00:550C  AF                      xor a
    3946   00:550D  C9                      ret
    3947   00:550E                      
    3948   00:550E                      ;=========================
    3949   00:550E                      ;===  TCPIP_TCP_CLOSE  ===
    3950   00:550E                      ;=========================
    3951   00:550E                      ;Close a TCP connection.
    3952   00:550E                      ;
    3953   00:550E                      ;Input:  A = 14
    3954   00:550E                      ;        B = Connection number
    3955   00:550E                      ;            0 to close all open transient UDP connections
    3956   00:550E                      ;Output: A = Error code
    3957   00:550E                      TCPIP_TCP_CLOSE:
    3958   00:550E                          SEND_DATA                       ; Send the command
    3958   00:550E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3959   00:5511  AF                      xor a
    3960   00:5512                          SEND_DATA                       ; Send the command size msb
    3960   00:5512  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3961   00:5515  3E 01                   ld  a,1
    3962   00:5517                          SEND_DATA                       ; Send the command size lsb
    3962   00:5517  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3963   00:551A  78                      ld  a,b
    3964   00:551B                          SEND_DATA                       ; Send the connection #
    3964   00:551B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3965   00:551E                          ; Now wait up to 180 ticks to get response
    3966   00:551E  21 B4 00                ld  hl,180
    3967   00:5521  CD 0D 5A                call    SETCOUNTER
    3968   00:5524                      TCPIP_TCP_CLOSE_ST1:
    3969   00:5524                          CHECK_DATA
    3969   00:5524  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3969   00:5527  CB 47             >     bit 0,a
    3970   00:5529  20 05                   jr  nz,TCPIP_TCP_CLOSE_ST1.1
    3971   00:552B  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3972   00:552E  18 F4                   jr  TCPIP_TCP_CLOSE_ST1
    3973   00:5530                      TCPIP_TCP_CLOSE_ST1.1:
    3974   00:5530                          ; nz, check the data
    3975   00:5530                          RECEIVE_DATA
    3975   00:5530  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3976   00:5533  FE 0E                   cp  14                          ; Is response of our command?
    3977   00:5535  20 ED                   jr  nz,TCPIP_TCP_CLOSE_ST1
    3978   00:5537                          ; now get return code, if return code other than 0, it is finished
    3979   00:5537                      TCPIP_TCP_CLOSE_RC:
    3980   00:5537                          CHECK_DATA
    3980   00:5537  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3980   00:553A  CB 47             >     bit 0,a
    3981   00:553C  20 05                   jr  nz,TCPIP_TCP_CLOSE_RC.1
    3982   00:553E  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3983   00:5541  18 F4                   jr  TCPIP_TCP_CLOSE_RC
    3984   00:5543                      TCPIP_TCP_CLOSE_RC.1:
    3985   00:5543                          ; nz, discard
    3986   00:5543                          RECEIVE_DATA
    3986   00:5543  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3987   00:5546  B7                      or  a                           ; 0?
    3988   00:5547  C0                      ret nz                          ; if not, done
    3989   00:5548                      
    3990   00:5548                          ; next two bytes are return code and size bytes, don't care, it is 0
    3991   00:5548  06 02                   ld  b,2
    3992   00:554A                      TCPIP_TCP_CLOSE_ST2:
    3993   00:554A                          CHECK_DATA
    3993   00:554A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3993   00:554D  CB 47             >     bit 0,a
    3994   00:554F  20 05                   jr  nz,TCPIP_TCP_CLOSE_ST2.1
    3995   00:5551  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3996   00:5554  18 F4                   jr  TCPIP_TCP_CLOSE_ST2
    3997   00:5556                      TCPIP_TCP_CLOSE_ST2.1:
    3998   00:5556                          ; nz, discard
    3999   00:5556                          RECEIVE_DATA
    3999   00:5556  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4000   00:5559  05                      dec b
    4001   00:555A  20 EE                   jr  nz,TCPIP_TCP_CLOSE_ST2
    4002   00:555C                      
    4003   00:555C                          ; done, no return data other than return code
    4004   00:555C  AF                      xor a
    4005   00:555D  C9                      ret
    4006   00:555E                      
    4007   00:555E                      ;=========================
    4008   00:555E                      ;===  TCPIP_TCP_ABORT  ===
    4009   00:555E                      ;=========================
    4010   00:555E                      ;Abort a TCP connection.
    4011   00:555E                      ;Input:  A  = 15
    4012   00:555E                      ;        B = Connection number
    4013   00:555E                      ;            0 to abort all open transient TCP connections
    4014   00:555E                      ;Output: A = Error code
    4015   00:555E                      
    4016   00:555E                      TCPIP_TCP_ABORT:
    4017   00:555E                          SEND_DATA                       ; Send the command
    4017   00:555E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4018   00:5561  AF                      xor a
    4019   00:5562                          SEND_DATA                       ; Send the command size msb
    4019   00:5562  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4020   00:5565  3E 01                   ld  a,1
    4021   00:5567                          SEND_DATA                       ; Send the command size lsb
    4021   00:5567  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4022   00:556A  78                      ld  a,b
    4023   00:556B                          SEND_DATA                       ; Send the connection #
    4023   00:556B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4024   00:556E                          ; Now wait up to 180 ticks to get response
    4025   00:556E  21 B4 00                ld  hl,180
    4026   00:5571  CD 0D 5A                call    SETCOUNTER
    4027   00:5574                      TCPIP_TCP_ABORT_ST1:
    4028   00:5574                          CHECK_DATA
    4028   00:5574  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4028   00:5577  CB 47             >     bit 0,a
    4029   00:5579  20 05                   jr  nz,TCPIP_TCP_ABORT_ST1.1
    4030   00:557B  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4031   00:557E  18 F4                   jr  TCPIP_TCP_ABORT_ST1
    4032   00:5580                      TCPIP_TCP_ABORT_ST1.1:
    4033   00:5580                          ; nz, check the data
    4034   00:5580                          RECEIVE_DATA
    4034   00:5580  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4035   00:5583  FE 0F                   cp  15                          ; Is response of our command?
    4036   00:5585  20 ED                   jr  nz,TCPIP_TCP_ABORT_ST1
    4037   00:5587                          ; now get return code, if return code other than 0, it is finished
    4038   00:5587                      TCPIP_TCP_ABORT_RC:
    4039   00:5587                          CHECK_DATA
    4039   00:5587  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4039   00:558A  CB 47             >     bit 0,a
    4040   00:558C  20 05                   jr  nz,TCPIP_TCP_ABORT_RC.1
    4041   00:558E  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4042   00:5591  18 F4                   jr  TCPIP_TCP_ABORT_RC
    4043   00:5593                      TCPIP_TCP_ABORT_RC.1:
    4044   00:5593                          ; nz, discard
    4045   00:5593                          RECEIVE_DATA
    4045   00:5593  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4046   00:5596  B7                      or  a                           ; 0?
    4047   00:5597  C0                      ret nz                          ; if not, done
    4048   00:5598                      
    4049   00:5598                          ; next two bytes are return code and size bytes, don't care, it is 0
    4050   00:5598  06 02                   ld  b,2
    4051   00:559A                      TCPIP_TCP_ABORT_ST2:
    4052   00:559A                          CHECK_DATA
    4052   00:559A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4052   00:559D  CB 47             >     bit 0,a
    4053   00:559F  20 05                   jr  nz,TCPIP_TCP_ABORT_ST2.1
    4054   00:55A1  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4055   00:55A4  18 F4                   jr  TCPIP_TCP_ABORT_ST2
    4056   00:55A6                      TCPIP_TCP_ABORT_ST2.1:
    4057   00:55A6                          ; nz, discard
    4058   00:55A6                          RECEIVE_DATA
    4058   00:55A6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4059   00:55A9  05                      dec b
    4060   00:55AA  20 EE                   jr  nz,TCPIP_TCP_ABORT_ST2
    4061   00:55AC                      
    4062   00:55AC                          ; done, no return data other than return code
    4063   00:55AC  AF                      xor a
    4064   00:55AD  C9                      ret
    4065   00:55AE                      
    4066   00:55AE                      ;=========================
    4067   00:55AE                      ;===  TCPIP_TCP_STATE  ===
    4068   00:55AE                      ;=========================
    4069   00:55AE                      ;Get the state of a TCP connection.
    4070   00:55AE                      ;
    4071   00:55AE                      ;Input:  A = 16
    4072   00:55AE                      ;        B = Connection number
    4073   00:55AE                      ;        HL = Pointer in TPA for connection information block
    4074   00:55AE                      ;             (0 if not needed)
    4075   00:55AE                      ;Output: A  = Error code
    4076   00:55AE                      ;        B  = Connection state
    4077   00:55AE                      ;        C  = Close reason (only if ERR_NO_CONN is returned)
    4078   00:55AE                      ;        HL = Number of total available incoming bytes
    4079   00:55AE                      ;        DE = Number of urgent available incoming bytes
    4080   00:55AE                      ;        IX = Available free space in the output buffer
    4081   00:55AE                      ;             (0FFFFh = infinite)
    4082   00:55AE                      ;
    4083   00:55AE                      ;Connection information block consists of:
    4084   00:55AE                      ;
    4085   00:55AE                      ;    +0 (4): Remote IP address
    4086   00:55AE                      ;    +4 (2): Remote port
    4087   00:55AE                      ;    +6 (2): Local port
    4088   00:55AE                      TCPIP_TCP_STATE_ERROR:
    4089   00:55AE                          ; next two bytes are size bytes, don't care
    4090   00:55AE  47                      ld  b,a                         ; save error in b
    4091   00:55AF  0E 02                   ld  c,2
    4092   00:55B1                      TCPIP_TCP_STATE_ERROR2:
    4093   00:55B1                          CHECK_DATA
    4093   00:55B1  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4093   00:55B4  CB 47             >     bit 0,a
    4094   00:55B6  20 05                   jr  nz,TCPIP_TCP_STATE_ERROR2.1
    4095   00:55B8  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4096   00:55BB  18 F4                   jr  TCPIP_TCP_STATE_ERROR2
    4097   00:55BD                      TCPIP_TCP_STATE_ERROR2.1:
    4098   00:55BD                          ; nz, discard
    4099   00:55BD                          RECEIVE_DATA
    4099   00:55BD  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4100   00:55C0  0D                      dec c
    4101   00:55C1  20 EE                   jr  nz,TCPIP_TCP_STATE_ERROR2
    4102   00:55C3                      
    4103   00:55C3                          ; now return w/ error that is saved in b
    4104   00:55C3  78                      ld  a,b
    4105   00:55C4  06 00                   ld  b,0
    4106   00:55C6  0E 07                   ld  c,7
    4107   00:55C8  21 00 00                ld  hl,0
    4108   00:55CB  11 00 00                ld  de,0
    4109   00:55CE  DD 21 00 00             ld  ix,0
    4110   00:55D2  C9                      ret
    4111   00:55D3                      
    4112   00:55D3                      TCPIP_TCP_STATE:
    4113   00:55D3  CD 56 5A                call    SETWORD                 ; Save HL pointer in our memory
    4114   00:55D6  7C                      ld  a,h
    4115   00:55D7  B5                      or  l                           ; Information block required?
    4116   00:55D8  3E 00                   ld  a,0                         ; do not want to mess with flags, let's say no need
    4117   00:55DA  28 01                   jr  z,TCPIP_TCP_STATE_NOINFOBLOCK
    4118   00:55DC  3C                      inc a                           ; otherwise there is a need
    4119   00:55DD                      TCPIP_TCP_STATE_NOINFOBLOCK:
    4120   00:55DD  CD 2F 5A                call    SETBYTE                 ; Save for later
    4121   00:55E0  3E 10                   ld  a,16                        ; Our command
    4122   00:55E2                          SEND_DATA                       ; Send the command
    4122   00:55E2  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4123   00:55E5  AF                      xor a
    4124   00:55E6                          SEND_DATA                       ; Send the command size msb
    4124   00:55E6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4125   00:55E9  3C                      inc a
    4126   00:55EA                          SEND_DATA                       ; Send the command size lsb
    4126   00:55EA  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4127   00:55ED  78                      ld  a,b
    4128   00:55EE                          SEND_DATA                       ; Send the parameter
    4128   00:55EE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4129   00:55F1                      
    4130   00:55F1                          ; Now wait up to 180 ticks to get response
    4131   00:55F1  21 B4 00                ld  hl,180
    4132   00:55F4  CD 0D 5A                call    SETCOUNTER
    4133   00:55F7                      TCPIP_TCP_STATE_ST1:
    4134   00:55F7                          CHECK_DATA
    4134   00:55F7  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4134   00:55FA  CB 47             >     bit 0,a
    4135   00:55FC  20 05                   jr  nz,TCPIP_TCP_STATE_ST1.1
    4136   00:55FE  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4137   00:5601  18 F4                   jr  TCPIP_TCP_STATE_ST1
    4138   00:5603                      TCPIP_TCP_STATE_ST1.1:
    4139   00:5603                          ; nz, check the data
    4140   00:5603                          RECEIVE_DATA
    4140   00:5603  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4141   00:5606  FE 10                   cp  16                          ; Is response of our command?
    4142   00:5608  20 ED                   jr  nz,TCPIP_TCP_STATE_ST1
    4143   00:560A                          ; now get return code, if return code other than 0, it is finished
    4144   00:560A                      TCPIP_TCP_STATE_RC:
    4145   00:560A                          CHECK_DATA
    4145   00:560A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4145   00:560D  CB 47             >     bit 0,a
    4146   00:560F  20 05                   jr  nz,TCPIP_TCP_STATE_RC.1
    4147   00:5611  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4148   00:5614  18 F4                   jr  TCPIP_TCP_STATE_RC
    4149   00:5616                      TCPIP_TCP_STATE_RC.1:
    4150   00:5616                          ; nz, discard
    4151   00:5616                          RECEIVE_DATA
    4151   00:5616  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4152   00:5619  B7                      or  a                           ; 0?
    4153   00:561A  20 92                   jr  nz,TCPIP_TCP_STATE_ERROR    ; if not, done
    4154   00:561C                      
    4155   00:561C                          ; next two bytes are return code and size bytes, don't care, it is 16
    4156   00:561C  06 02                   ld  b,2
    4157   00:561E                      TCPIP_TCP_STATE_ST2:
    4158   00:561E                          CHECK_DATA
    4158   00:561E  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4158   00:5621  CB 47             >     bit 0,a
    4159   00:5623  20 05                   jr  nz,TCPIP_TCP_STATE_ST2.1
    4160   00:5625  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4161   00:5628  18 F4                   jr  TCPIP_TCP_STATE_ST2
    4162   00:562A                      TCPIP_TCP_STATE_ST2.1:
    4163   00:562A                          ; nz, discard
    4164   00:562A                          RECEIVE_DATA
    4164   00:562A  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4165   00:562D  05                      dec b
    4166   00:562E  20 EE                   jr  nz,TCPIP_TCP_STATE_ST2
    4167   00:5630                      
    4168   00:5630                          ; now just get the 16 bytes (Port LSB then MSB, # of packets, packet size LSB then MSB) and order it in C, B, L, H, E, D, IXL and IXH.
    4169   00:5630                          ; Remaining 8 bytes go to TCP_STATE_INFORMATION_BLOCK if its value is other than 0
    4170   00:5630                      TCPIP_TCP_STATE_RESP_ST1:
    4171   00:5630                          CHECK_DATA
    4171   00:5630  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4171   00:5633  CB 47             >     bit 0,a
    4172   00:5635  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST1.1
    4173   00:5637  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4174   00:563A  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST1
    4175   00:563C                      TCPIP_TCP_STATE_RESP_ST1.1:
    4176   00:563C                          ; nz, get it
    4177   00:563C                          RECEIVE_DATA
    4177   00:563C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4178   00:563F  4F                      ld  c,a
    4179   00:5640                      TCPIP_TCP_STATE_RESP_ST2:
    4180   00:5640                          CHECK_DATA
    4180   00:5640  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4180   00:5643  CB 47             >     bit 0,a
    4181   00:5645  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST2.1
    4182   00:5647  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4183   00:564A  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST2
    4184   00:564C                      TCPIP_TCP_STATE_RESP_ST2.1:
    4185   00:564C                          ; nz, get it
    4186   00:564C                          RECEIVE_DATA
    4186   00:564C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4187   00:564F  47                      ld  b,a
    4188   00:5650                      TCPIP_TCP_STATE_RESP_ST3:
    4189   00:5650                          CHECK_DATA
    4189   00:5650  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4189   00:5653  CB 47             >     bit 0,a
    4190   00:5655  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST3.1
    4191   00:5657  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4192   00:565A  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST3
    4193   00:565C                      TCPIP_TCP_STATE_RESP_ST3.1:
    4194   00:565C                          ; nz, get it
    4195   00:565C                          RECEIVE_DATA
    4195   00:565C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4196   00:565F  6F                      ld  l,a
    4197   00:5660                      TCPIP_TCP_STATE_RESP_ST4:
    4198   00:5660                          CHECK_DATA
    4198   00:5660  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4198   00:5663  CB 47             >     bit 0,a
    4199   00:5665  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST4.1
    4200   00:5667  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4201   00:566A  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST4
    4202   00:566C                      TCPIP_TCP_STATE_RESP_ST4.1:
    4203   00:566C                          ; nz, get it
    4204   00:566C                          RECEIVE_DATA
    4204   00:566C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4205   00:566F  67                      ld  h,a
    4206   00:5670                      TCPIP_TCP_STATE_RESP_ST5:
    4207   00:5670                          CHECK_DATA
    4207   00:5670  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4207   00:5673  CB 47             >     bit 0,a
    4208   00:5675  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST5.1
    4209   00:5677  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4210   00:567A  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST5
    4211   00:567C                      TCPIP_TCP_STATE_RESP_ST5.1:
    4212   00:567C                          ; nz, get it
    4213   00:567C                          RECEIVE_DATA
    4213   00:567C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4214   00:567F  5F                      ld  e,a
    4215   00:5680                      TCPIP_TCP_STATE_RESP_ST6:
    4216   00:5680                          CHECK_DATA
    4216   00:5680  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4216   00:5683  CB 47             >     bit 0,a
    4217   00:5685  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST6.1
    4218   00:5687  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4219   00:568A  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST6
    4220   00:568C                      TCPIP_TCP_STATE_RESP_ST6.1:
    4221   00:568C                          ; nz, get it
    4222   00:568C                          RECEIVE_DATA
    4222   00:568C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4223   00:568F  57                      ld  d,a
    4224   00:5690                      TCPIP_TCP_STATE_RESP_ST7:
    4225   00:5690                          CHECK_DATA
    4225   00:5690  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4225   00:5693  CB 47             >     bit 0,a
    4226   00:5695  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST7.1
    4227   00:5697  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4228   00:569A  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST7
    4229   00:569C                      TCPIP_TCP_STATE_RESP_ST7.1:
    4230   00:569C                          ; nz, get it
    4231   00:569C                          RECEIVE_DATA
    4231   00:569C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4232   00:569F  DD 6F                   ld  ixl,a
    4233   00:56A1                      TCPIP_TCP_STATE_RESP_ST8:
    4234   00:56A1                          CHECK_DATA
    4234   00:56A1  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4234   00:56A4  CB 47             >     bit 0,a
    4235   00:56A6  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST8.1
    4236   00:56A8  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4237   00:56AB  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST8
    4238   00:56AD                      TCPIP_TCP_STATE_RESP_ST8.1:
    4239   00:56AD                          ; nz, get it
    4240   00:56AD                          RECEIVE_DATA
    4240   00:56AD  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4241   00:56B0  DD 67                   ld  ixh,a
    4242   00:56B2                      
    4243   00:56B2                      ; Check if there is an information block
    4244   00:56B2  CD B6 5A                call    BCBACKUP                ; Save BC, we gonna use it
    4245   00:56B5  06 08                   ld  b,8                         ; prepare in advance for 8 bytes being transferred
    4246   00:56B7  CD 1D 5A                call    GETBYTE                 ; Let's check if we have flagged need for INFOBLOCK
    4247   00:56BA  B7                      or  a
    4248   00:56BB  20 17                   jr  nz,TCPIP_TCP_STATE_GET_IBLOCK
    4249   00:56BD                      
    4250   00:56BD                      ; If here, just discard Information Block (next 8 bytes)
    4251   00:56BD                      TCPIP_TCP_STATE_DISCARD_IBLOCK:
    4252   00:56BD                          CHECK_DATA
    4252   00:56BD  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4252   00:56C0  CB 47             >     bit 0,a
    4253   00:56C2  20 05                   jr  nz,TCPIP_TCP_STATE_DISCARD_IBLOCK.1
    4254   00:56C4  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4255   00:56C7  18 F4                   jr  TCPIP_TCP_STATE_DISCARD_IBLOCK
    4256   00:56C9                      TCPIP_TCP_STATE_DISCARD_IBLOCK.1:
    4257   00:56C9                          ; nz, discard
    4258   00:56C9                          RECEIVE_DATA
    4258   00:56C9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4259   00:56CC  05                      dec b
    4260   00:56CD  20 EE                   jr  nz,TCPIP_TCP_STATE_DISCARD_IBLOCK
    4261   00:56CF                          ; done
    4262   00:56CF  CD A4 5A                call    BCRESTORE
    4263   00:56D2  AF                      xor a
    4264   00:56D3  C9                      ret
    4265   00:56D4                      
    4266   00:56D4                      ; If here, save Information Block (next 8 bytes)
    4267   00:56D4                      TCPIP_TCP_STATE_GET_IBLOCK:
    4268   00:56D4  CD DD 5A                call    HLBACKUP                ; Save HL
    4269   00:56D7  CD 43 5A                call    GETWORD                 ; Restore address for IB on HL
    4270   00:56DA                      TCPIP_TCP_STATE_SAVE_IBLOCK:
    4271   00:56DA                          CHECK_DATA
    4271   00:56DA  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4271   00:56DD  CB 47             >     bit 0,a
    4272   00:56DF  20 05                   jr  nz,TCPIP_TCP_STATE_SAVE_IBLOCK.1
    4273   00:56E1  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4274   00:56E4  18 F4                   jr  TCPIP_TCP_STATE_SAVE_IBLOCK
    4275   00:56E6                      TCPIP_TCP_STATE_SAVE_IBLOCK.1:
    4276   00:56E6                          ; nz, save
    4277   00:56E6                          RECEIVE_DATA
    4277   00:56E6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4278   00:56E9  77                      ld  (hl),a
    4279   00:56EA  23                      inc hl
    4280   00:56EB  05                      dec b
    4281   00:56EC  20 EC                   jr  nz,TCPIP_TCP_STATE_SAVE_IBLOCK
    4282   00:56EE                          ; done
    4283   00:56EE  CD CA 5A                call    HLRESTORE
    4284   00:56F1  CD A4 5A                call    BCRESTORE
    4285   00:56F4  AF                      xor a
    4286   00:56F5  C9                      ret
    4287   00:56F6                      
    4288   00:56F6                      ;========================
    4289   00:56F6                      ;===  TCPIP_TCP_SEND  ===
    4290   00:56F6                      ;========================
    4291   00:56F6                      ;Send data to a TCP connection.
    4292   00:56F6                      ;
    4293   00:56F6                      ;Input:  A  = 17
    4294   00:56F6                      ;        B  = Connection number
    4295   00:56F6                      ;        DE = Address of the data to be sent
    4296   00:56F6                      ;        HL = Length of the data to be sent
    4297   00:56F6                      ;        C  = Flags:
    4298   00:56F6                      ;             bit 0: Send the data PUSHed
    4299   00:56F6                      ;             bit 1: The data is urgent
    4300   00:56F6                      ;Output: A = Error code
    4301   00:56F6                      TCPIP_TCP_SEND_ERROR:
    4302   00:56F6                          ; next two bytes are size bytes, don't care
    4303   00:56F6  47                      ld  b,a                         ; save error in b
    4304   00:56F7  0E 02                   ld  c,2
    4305   00:56F9                      TCPIP_TCP_SEND_ERROR2:
    4306   00:56F9                          CHECK_DATA
    4306   00:56F9  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4306   00:56FC  CB 47             >     bit 0,a
    4307   00:56FE  20 05                   jr  nz,TCPIP_TCP_SEND_ERROR2.1
    4308   00:5700  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4309   00:5703  18 F4                   jr  TCPIP_TCP_SEND_ERROR2
    4310   00:5705                      TCPIP_TCP_SEND_ERROR2.1:
    4311   00:5705                          ; nz, discard
    4312   00:5705                          RECEIVE_DATA
    4312   00:5705  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4313   00:5708  0D                      dec c
    4314   00:5709  20 EE                   jr  nz,TCPIP_TCP_SEND_ERROR2
    4315   00:570B                          ; now return w/ error that is saved in b
    4316   00:570B  78                      ld  a,b
    4317   00:570C  C9                      ret
    4318   00:570D                      
    4319   00:570D                      TCPIP_TCP_SEND:
    4320   00:570D  E5                      push    hl
    4321   00:570E  D5                      push    de
    4322   00:570F                          SEND_DATA                       ; Send the command
    4322   00:570F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4323   00:5712                          ; prepare new data size, adding our 2 bytes overhead
    4324   00:5712  11 02 00                ld  de,2
    4325   00:5715  19                      add hl,de
    4326   00:5716  7C                      ld  a,h
    4327   00:5717                          SEND_DATA                       ; Send the command size msb
    4327   00:5717  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4328   00:571A  7D                      ld  a,l
    4329   00:571B                          SEND_DATA                       ; Send the command size lsb
    4329   00:571B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4330   00:571E  78                      ld  a,b
    4331   00:571F                          SEND_DATA                       ; Send the connection #
    4331   00:571F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4332   00:5722  79                      ld  a,c
    4333   00:5723                          SEND_DATA                       ; Send the connection flags
    4333   00:5723  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4334   00:5726  E1                      pop hl
    4335   00:5727  D1                      pop de
    4336   00:5728                          ; now oti the data starting at hl, size is in DE
    4337   00:5728                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    4338   00:5728  43                      ld  b,e                         ;Number of loops originaly in DE
    4339   00:5729  1B                      dec de
    4340   00:572A  14                      inc d
    4341   00:572B                          if USE_MEM_IO = 0
    4342   00:572B                    ~     ld  c,OUT_TX_PORT
    4343   00:572B                    ~ TCPIP_TCP_SEND_R:
    4344   00:572B                    ~     outi
    4345   00:572B                    ~     jr  nz,TCPIP_TCP_SEND_R
    4346   00:572B                    ~     else
    4347   00:572B                      TCPIP_TCP_SEND_R:
    4348   00:572B  7E                      ld  a,(hl)
    4349   00:572C  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    4350   00:572F  23                      inc hl
    4351   00:5730  10 F9                   djnz TCPIP_TCP_SEND_R
    4352   00:5732                          endif
    4353   00:5732  15                      dec d
    4354   00:5733  20 F6                   jr  nz,TCPIP_TCP_SEND_R
    4355   00:5735                      
    4356   00:5735                          ; Now wait up to 600 ticks to get response
    4357   00:5735  21 58 02                ld  hl,600
    4358   00:5738  CD 0D 5A                call    SETCOUNTER
    4359   00:573B                      TCPIP_TCP_SEND_ST1:
    4360   00:573B                          CHECK_DATA
    4360   00:573B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4360   00:573E  CB 47             >     bit 0,a
    4361   00:5740  20 05                   jr  nz,TCPIP_TCP_SEND_R.1
    4362   00:5742  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4363   00:5745  18 F4                   jr  TCPIP_TCP_SEND_ST1
    4364   00:5747                      TCPIP_TCP_SEND_R.1:
    4365   00:5747                          ; nz, check the data
    4366   00:5747                          RECEIVE_DATA
    4366   00:5747  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4367   00:574A  FE 11                   cp  17                          ; Is response of our command?
    4368   00:574C  20 ED                   jr  nz,TCPIP_TCP_SEND_ST1
    4369   00:574E                          ; now get return code, if return code other than 0, it is finished
    4370   00:574E                      TCPIP_TCP_SEND_RC:
    4371   00:574E                          CHECK_DATA
    4371   00:574E  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4371   00:5751  CB 47             >     bit 0,a
    4372   00:5753  20 05                   jr  nz,TCPIP_TCP_SEND_RC.1
    4373   00:5755  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4374   00:5758  18 F4                   jr  TCPIP_TCP_SEND_RC
    4375   00:575A                      TCPIP_TCP_SEND_RC.1:
    4376   00:575A                          ; nz, discard
    4377   00:575A                          RECEIVE_DATA
    4377   00:575A  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4378   00:575D  B7                      or  a                           ; 0?
    4379   00:575E  C0                      ret nz                          ; if not, done
    4380   00:575F                      
    4381   00:575F                          ; next two bytes are return code and size bytes, don't care, it is 0
    4382   00:575F  06 02                   ld  b,2
    4383   00:5761                      TCPIP_TCP_SEND_ST2:
    4384   00:5761                          CHECK_DATA
    4384   00:5761  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4384   00:5764  CB 47             >     bit 0,a
    4385   00:5766  20 05                   jr  nz,TCPIP_TCP_SEND_ST2.1
    4386   00:5768  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4387   00:576B  18 F4                   jr  TCPIP_TCP_SEND_ST2
    4388   00:576D                      TCPIP_TCP_SEND_ST2.1:
    4389   00:576D                          ; nz, discard
    4390   00:576D                          RECEIVE_DATA
    4390   00:576D  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4391   00:5770  05                      dec b
    4392   00:5771  20 EE                   jr  nz,TCPIP_TCP_SEND_ST2
    4393   00:5773                      
    4394   00:5773                          ; done, no return data other than return code
    4395   00:5773  AF                      xor a
    4396   00:5774  C9                      ret
    4397   00:5775                      
    4398   00:5775                      ;=======================
    4399   00:5775                      ;===  TCPIP_TCP_RCV  ===
    4400   00:5775                      ;=======================
    4401   00:5775                      ;Receive data from a TCP connection.
    4402   00:5775                      ;
    4403   00:5775                      ;Input:   A  = 18
    4404   00:5775                      ;         B  = Connection number
    4405   00:5775                      ;         DE = Address for the retrieved data
    4406   00:5775                      ;         HL = Length of the data to be obtained
    4407   00:5775                      ;Output:  A  = Error code
    4408   00:5775                      ;         BC = Total number of bytes that have been actually retrieved
    4409   00:5775                      ;         HL = Number of urgent data bytes that have been retrieved
    4410   00:5775                      ;              (placed at the beginning of the received data block)
    4411   00:5775                      ; Save registers other than AF
    4412   00:5775                      TCPIP_TCP_RCV_CHECK_TIME_OUT:
    4413   00:5775  C5                      push bc
    4414   00:5776  D5                      push de
    4415   00:5777  E5                      push hl
    4416   00:5778  CD FE 59                call    GETCOUNTER
    4417   00:577B  7D                      ld  a,l
    4418   00:577C  B4                      or  h
    4419   00:577D                          ; Restore registers, we are returning
    4420   00:577D  E1                      pop hl
    4421   00:577E  D1                      pop de
    4422   00:577F  C1                      pop bc
    4423   00:5780  C0                      ret nz
    4424   00:5781                          ; Ok, timeout...
    4425   00:5781  F1                      pop af                          ; Get return address of who called this out of the stack, we will return from the function or re-start
    4426   00:5782                      TCPIP_TCP_RCV_RETRY_QRCV:
    4427   00:5782  CD 1D 5A                call    GETBYTE
    4428   00:5785  B7                      or  a
    4429   00:5786  28 0C                   jr  z,TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY
    4430   00:5788                          ; Ok, so let's ask ESP to re-send the data and retry receiving it
    4431   00:5788  3D                      dec a
    4432   00:5789  CD 2F 5A                call    SETBYTE                 ; we are retrying it
    4433   00:578C  3E 72                   ld  a,'r'                       ; retry transmission command
    4434   00:578E                          SEND_DATA
    4434   00:578E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4435   00:5791  C3 D8 57                jp  TCPIP_TCP_RCV.RXRETRY       ; and retry it
    4436   00:5794                      TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY:
    4437   00:5794  3E 0F                   ld  a,ERR_INV_OPER
    4438   00:5796  C9                      ret                             ; and return the function itself
    4439   00:5797                      
    4440   00:5797                      TCPIP_TCP_RCV_RET_ERR:
    4441   00:5797                          ; next two bytes are size bytes, don't care
    4442   00:5797  47                      ld  b,a                         ; save error in b
    4443   00:5798  0E 02                   ld  c,2
    4444   00:579A                      TCPIP_TCP_RCV_RET_ERR2:
    4445   00:579A                          CHECK_DATA
    4445   00:579A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4445   00:579D  CB 47             >     bit 0,a
    4446   00:579F  20 05                   jr  nz,TCPIP_TCP_RCV_RET_ERR2.1
    4447   00:57A1  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4448   00:57A4  18 F4                   jr  TCPIP_TCP_RCV_RET_ERR2
    4449   00:57A6                      TCPIP_TCP_RCV_RET_ERR2.1:
    4450   00:57A6                          ; nz, discard
    4451   00:57A6                          RECEIVE_DATA
    4451   00:57A6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4452   00:57A9  0D                      dec c
    4453   00:57AA  20 EE                   jr  nz,TCPIP_TCP_RCV_RET_ERR2
    4454   00:57AC                          ; now return w/ error that is saved in b
    4455   00:57AC  78                      ld  a,b
    4456   00:57AD                      TCPIP_TCP_RCV_RET_NODATA:
    4457   00:57AD  21 00 00                ld  hl,0
    4458   00:57B0  01 00 00                ld  bc,0
    4459   00:57B3  C9                      ret
    4460   00:57B4                      
    4461   00:57B4                      TCPIP_TCP_RCV:
    4462   00:57B4  EB                      ex  de,hl
    4463   00:57B5  CD 56 5A                call    SETWORD
    4464   00:57B8  EB                      ex  de,hl
    4465   00:57B9  3E 12                   ld  a,18
    4466   00:57BB                          SEND_DATA                       ; Send the command
    4466   00:57BB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4467   00:57BE  AF                      xor a
    4468   00:57BF                          SEND_DATA                       ; Send the command size msb
    4468   00:57BF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4469   00:57C2  3E 03                   ld  a,3
    4470   00:57C4                          SEND_DATA                       ; Send the command size lsb
    4470   00:57C4  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4471   00:57C7  78                      ld  a,b
    4472   00:57C8                          SEND_DATA                       ; Send the connection #
    4472   00:57C8  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4473   00:57CB  7D                      ld  a,l
    4474   00:57CC                          SEND_DATA                       ; Send MAX rcv size LSB
    4474   00:57CC  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4475   00:57CF  7C                      ld  a,h
    4476   00:57D0                          SEND_DATA                       ; Send MAX rcv size MSB
    4476   00:57D0  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4477   00:57D3  3E 03                   ld  a,3
    4478   00:57D5  CD 2F 5A                call    SETBYTE                 ; Ok, retry up to three times
    4479   00:57D8                      TCPIP_TCP_RCV.RXRETRY:
    4480   00:57D8                          ; Now wait up to 600 ticks to get response
    4481   00:57D8  21 58 02                ld  hl,600
    4482   00:57DB  CD 0D 5A                call    SETCOUNTER
    4483   00:57DE                      TCPIP_TCP_RCV_ST1:
    4484   00:57DE                          CHECK_DATA
    4484   00:57DE  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4484   00:57E1  CB 47             >     bit 0,a
    4485   00:57E3  20 05                   jr  nz,TCPIP_TCP_RCV_ST1.1
    4486   00:57E5  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4487   00:57E8  18 F4                   jr  TCPIP_TCP_RCV_ST1
    4488   00:57EA                      TCPIP_TCP_RCV_ST1.1:
    4489   00:57EA                          ; nz, check the data
    4490   00:57EA                          RECEIVE_DATA
    4490   00:57EA  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4491   00:57ED  FE 12                   cp 18                           ; Is response of our command?
    4492   00:57EF  20 ED                   jr  nz,TCPIP_TCP_RCV_ST1
    4493   00:57F1                          ; At this point, all data is being buffered, so 15 ticks, quarter second, is more than enough time-out
    4494   00:57F1  F3                      di
    4495   00:57F2  21 1E 00                ld  hl,30
    4496   00:57F5  CD 0D 5A                call    SETCOUNTER
    4497   00:57F8  FB                      ei
    4498   00:57F9                          ; now get return code, if return code other than 0, it is finished
    4499   00:57F9                      TCPIP_TCP_RCV_RC:
    4500   00:57F9                          CHECK_DATA
    4500   00:57F9  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4500   00:57FC  CB 47             >     bit 0,a
    4501   00:57FE  20 05                   jr  nz,TCPIP_TCP_RCV_RC.1
    4502   00:5800  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4503   00:5803  18 F4                   jr  TCPIP_TCP_RCV_RC
    4504   00:5805                      TCPIP_TCP_RCV_RC.1:
    4505   00:5805                          ; nz, discard
    4506   00:5805                          RECEIVE_DATA
    4506   00:5805  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4507   00:5808  B7                      or  a                           ; 0?
    4508   00:5809  20 8C                   jr  nz,TCPIP_TCP_RCV_RET_ERR    ; if not, done
    4509   00:580B                          ; next two bytes are response size bytes (UB count two bytes, always 0, and data read), save it -2 to BC
    4510   00:580B                      TCPIP_TCP_RCV_ST2A:
    4511   00:580B                          CHECK_DATA
    4511   00:580B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4511   00:580E  CB 47             >     bit 0,a
    4512   00:5810  20 05                   jr  nz,TCPIP_TCP_RCV_ST2A.1
    4513   00:5812  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4514   00:5815  18 F4                   jr  TCPIP_TCP_RCV_ST2A
    4515   00:5817                      TCPIP_TCP_RCV_ST2A.1:
    4516   00:5817                          ; nz, high byte count of bytes to receive
    4517   00:5817                          RECEIVE_DATA
    4517   00:5817  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4518   00:581A  67                      ld h,a
    4519   00:581B                      TCPIP_TCP_RCV_ST2B:
    4520   00:581B                          CHECK_DATA
    4520   00:581B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4520   00:581E  CB 47             >     bit 0,a
    4521   00:5820  20 05                   jr  nz,TCPIP_TCP_RCV_ST2B.1
    4522   00:5822  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4523   00:5825  18 F4                   jr  TCPIP_TCP_RCV_ST2B
    4524   00:5827                      TCPIP_TCP_RCV_ST2B.1:
    4525   00:5827                          ; nz, low byte count of bytes to receive
    4526   00:5827                          RECEIVE_DATA
    4526   00:5827  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4527   00:582A  6F                      ld  l,a
    4528   00:582B  01 02 00                ld  bc,2
    4529   00:582E                          ; subtract 2 (Urgent data count, not used)
    4530   00:582E  AF                      xor a                           ; zero carry
    4531   00:582F  ED 42                   sbc hl,bc
    4532   00:5831                          ; if it was 0, will carry
    4533   00:5831                          if USE_MEM_IO = 1
    4534   00:5831  DA AD 57                jp  c,TCPIP_TCP_RCV_RET_NODATA
    4535   00:5834                          else
    4536   00:5834                    ~     jr  c,TCPIP_TCP_RCV_RET_NODATA
    4537   00:5834                    ~     endif
    4538   00:5834  4D                      ld  c,l
    4539   00:5835  44                      ld  b,h                         ; BC has effective received data size, as well as HL
    4540   00:5836                      
    4541   00:5836                          ; now just discard 2 bytes urgent data
    4542   00:5836                      TCPIP_TCP_RCV_UDC_ST1:
    4543   00:5836                          CHECK_DATA
    4543   00:5836  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4543   00:5839  CB 47             >     bit 0,a
    4544   00:583B  20 05                   jr  nz,TCPIP_TCP_RCV_UDC_ST1.1
    4545   00:583D  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4546   00:5840  18 F4                   jr  TCPIP_TCP_RCV_UDC_ST1
    4547   00:5842                      TCPIP_TCP_RCV_UDC_ST1.1:
    4548   00:5842                          ; nz, get it
    4549   00:5842                          RECEIVE_DATA
    4549   00:5842  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4550   00:5845                      TCPIP_TCP_RCV_UDC_ST2:
    4551   00:5845                          CHECK_DATA
    4551   00:5845  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4551   00:5848  CB 47             >     bit 0,a
    4552   00:584A  20 05                   jr  nz,TCPIP_TCP_RCV_UDC_ST2.1
    4553   00:584C  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4554   00:584F  18 F4                   jr  TCPIP_TCP_RCV_UDC_ST2
    4555   00:5851                      TCPIP_TCP_RCV_UDC_ST2.1:
    4556   00:5851                          ; nz, get it
    4557   00:5851                          RECEIVE_DATA
    4557   00:5851  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4558   00:5854                      
    4559   00:5854                          ; put effective data size in de
    4560   00:5854  EB                      ex  de,hl
    4561   00:5855                          ; will start moving at address in stack (we've pushed the adress in WORD)
    4562   00:5855  CD 43 5A                call    GETWORD
    4563   00:5858  CD B6 5A                call    BCBACKUP                ; save count (BC)
    4564   00:585B                      
    4565   00:585B                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use ini :-D
    4566   00:585B  43                      ld  b,e                         ; Number of loops originaly in DE
    4567   00:585C  1B                      dec de
    4568   00:585D  14                      inc d
    4569   00:585E                          if USE_MEM_IO = 0
    4570   00:585E                    ~     ld  c,IN_DATA_PORT
    4571   00:585E                    ~     CHECK_QUICK_RECEIVE
    4572   00:585E                    ~     jr  z,TCPIP_TCP_RCV_R_NSF       ; If not, go to the old, slower route
    4573   00:585E                    ~     ; Otherwise, let's speed it up baby!
    4574   00:585E                    ~ TCPIP_TCP_RCV_R:
    4575   00:585E                    ~     inir
    4576   00:585E                    ~     else
    4577   00:585E                          CHECK_QUICK_RECEIVE
    4577   00:585E  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4577   00:5861  CB 5F             >     bit 3,a
    4578   00:5863  28 1A                   jr  z,TCPIP_TCP_RCV_R_NSF       ; If not, go to the old, slower route
    4579   00:5865                          ; Otherwise, let's speed it up baby!
    4580   00:5865                      TCPIP_TCP_RCV_R:
    4581   00:5865  3A 06 7F                ld  a,(MEM_IN_DATA_PORT)
    4582   00:5868  77                      ld  (hl),a
    4583   00:5869  23                      inc hl
    4584   00:586A  10 F9                   djnz TCPIP_TCP_RCV_R
    4585   00:586C                          endif
    4586   00:586C  15                      dec d
    4587   00:586D  20 F6                   jr nz,TCPIP_TCP_RCV_R
    4588   00:586F                          CHECK_BUFFER_UNDERRUN
    4588   00:586F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4588   00:5872  CB 67             >     bit 4,a
    4589   00:5874  C2 82 57                jp  nz,TCPIP_TCP_RCV_RETRY_QRCV ; If yes, retry
    4590   00:5877                          ; Otherwise, done
    4591   00:5877  CD A4 5A                call    BCRESTORE               ; done, restore return data in BC
    4592   00:587A                          ; no urgent data support
    4593   00:587A  21 00 00                ld  hl,0
    4594   00:587D  AF                      xor a
    4595   00:587E  C9                      ret
    4596   00:587F                      TCPIP_TCP_RCV_R_NSF:
    4597   00:587F                          CHECK_DATA
    4597   00:587F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4597   00:5882  CB 47             >     bit 0,a
    4598   00:5884  20 05                   jr  nz,TCPIP_TCP_RCV_R_NSF.1
    4599   00:5886  CD 75 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4600   00:5889  18 F4                   jr  TCPIP_TCP_RCV_R_NSF
    4601   00:588B                      TCPIP_TCP_RCV_R_NSF.1:
    4602   00:588B                          if USE_MEM_IO = 0
    4603   00:588B                    ~     ini
    4604   00:588B                    ~     else
    4605   00:588B  3A 06 7F                ld  a,(MEM_IN_DATA_PORT)
    4606   00:588E  77                      ld  (hl),a
    4607   00:588F  23                      inc hl
    4608   00:5890  05                      dec b
    4609   00:5891                          endif
    4610   00:5891  20 EC                   jr  nz,TCPIP_TCP_RCV_R_NSF
    4611   00:5893  15                      dec d
    4612   00:5894  20 E9                   jr nz,TCPIP_TCP_RCV_R_NSF
    4613   00:5896  CD A4 5A                call    BCRESTORE               ; done, restore return data in BC
    4614   00:5899                          ; no urgent data support
    4615   00:5899  21 00 00                ld  hl,0
    4616   00:589C  AF                      xor a
    4617   00:589D  C9                      ret
    4618   00:589E                      
    4619   00:589E                      ;=============================
    4620   00:589E                      ;===  TCPIP_CONFIG_AUTOIP  ===
    4621   00:589E                      ;=============================
    4622   00:589E                      ;Enable or disable the automatic IP addresses retrieval.
    4623   00:589E                      ;
    4624   00:589E                      ;Input:  A = 25
    4625   00:589E                      ;        B = 0: Get current configuration
    4626   00:589E                      ;            1: Set configuration
    4627   00:589E                      ;        C = Configuration to set (only if B=1):
    4628   00:589E                      ;            bit 0: Set to automatically retrieve
    4629   00:589E                      ;                   local IP address, subnet mask and default gateway
    4630   00:589E                      ;            bit 1: Set to automatically retrieve DNS servers addresses
    4631   00:589E                      ;            bits 2-7: Unused, must be zero
    4632   00:589E                      ;Output: A = Error code
    4633   00:589E                      ;        C = Configuration after the routine execution
    4634   00:589E                      ;            (same format as C at input)
    4635   00:589E                      TCPIP_CONFIG_AUTOIP:
    4636   00:589E                          SEND_DATA                       ; Send the command
    4636   00:589E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4637   00:58A1  AF                      xor a
    4638   00:58A2                          SEND_DATA                       ; Send the command size msb
    4638   00:58A2  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4639   00:58A5  3E 02                   ld  a,2
    4640   00:58A7                          SEND_DATA                       ; Send the command size lsb
    4640   00:58A7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4641   00:58AA  78                      ld  a,b
    4642   00:58AB                          SEND_DATA                       ; Send the command
    4642   00:58AB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4643   00:58AE  79                      ld  a,c
    4644   00:58AF                          SEND_DATA                       ; Send the command parameter
    4644   00:58AF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4645   00:58B2                      
    4646   00:58B2                          ; Now wait up to 180 ticks to get response
    4647   00:58B2  21 B4 00                ld hl,180
    4648   00:58B5  CD 0D 5A                call    SETCOUNTER
    4649   00:58B8                      TCPIP_CONFIG_AUTOIP_ST1:
    4650   00:58B8                          CHECK_DATA
    4650   00:58B8  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4650   00:58BB  CB 47             >     bit 0,a
    4651   00:58BD  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_ST1.1
    4652   00:58BF  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4653   00:58C2  18 F4                   jr  TCPIP_CONFIG_AUTOIP_ST1
    4654   00:58C4                      TCPIP_CONFIG_AUTOIP_ST1.1:
    4655   00:58C4                          ; nz, check the data
    4656   00:58C4                          RECEIVE_DATA
    4656   00:58C4  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4657   00:58C7  FE 19                   cp  25                          ; Is response of our command?
    4658   00:58C9  20 ED                   jr  nz,TCPIP_CONFIG_AUTOIP_ST1
    4659   00:58CB                          ; now get return code, if return code other than 0, it is finished
    4660   00:58CB                      TCPIP_CONFIG_AUTOIP_RC:
    4661   00:58CB                          CHECK_DATA
    4661   00:58CB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4661   00:58CE  CB 47             >     bit 0,a
    4662   00:58D0  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_RC.1
    4663   00:58D2  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4664   00:58D5  18 F4                   jr  TCPIP_CONFIG_AUTOIP_RC
    4665   00:58D7                      TCPIP_CONFIG_AUTOIP_RC.1:
    4666   00:58D7                          ;nz, discard
    4667   00:58D7                          RECEIVE_DATA
    4667   00:58D7  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4668   00:58DA  B7                      or  a                           ; 0?
    4669   00:58DB  C0                      ret nz                          ; if not, done
    4670   00:58DC                      
    4671   00:58DC                          ; next two bytes are return code and size bytes, don't care, it is 1, configuration
    4672   00:58DC  06 02                   ld  b,2
    4673   00:58DE                      TCPIP_CONFIG_AUTOIP_ST2:
    4674   00:58DE                          CHECK_DATA
    4674   00:58DE  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4674   00:58E1  CB 47             >     bit 0,a
    4675   00:58E3  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_ST2.1
    4676   00:58E5  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4677   00:58E8  18 F4                   jr  TCPIP_CONFIG_AUTOIP_ST2
    4678   00:58EA                      TCPIP_CONFIG_AUTOIP_ST2.1:
    4679   00:58EA                          ; nz, discard
    4680   00:58EA                          RECEIVE_DATA
    4680   00:58EA  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4681   00:58ED  05                      dec b
    4682   00:58EE  20 EE                   jr  nz,TCPIP_CONFIG_AUTOIP_ST2
    4683   00:58F0                      
    4684   00:58F0                          ; now just get the 1 byte, configuration, should go to C
    4685   00:58F0                      TCPIP_CONFIG_AUTOIP_CONF_ST1:
    4686   00:58F0                          CHECK_DATA
    4686   00:58F0  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4686   00:58F3  CB 47             >     bit 0,a
    4687   00:58F5  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_CONF_ST1.1
    4688   00:58F7  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4689   00:58FA  18 F4                   jr  TCPIP_CONFIG_AUTOIP_CONF_ST1
    4690   00:58FC                      TCPIP_CONFIG_AUTOIP_CONF_ST1.1:
    4691   00:58FC                          ; nz, get it
    4692   00:58FC                          RECEIVE_DATA
    4692   00:58FC  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4693   00:58FF  4F                      ld  c,a
    4694   00:5900                          ; done
    4695   00:5900  AF                      xor a
    4696   00:5901  C9                      ret
    4697   00:5902                      
    4698   00:5902                      ;=========================
    4699   00:5902                      ;===  TCPIP_CONFIG_IP  ===
    4700   00:5902                      ;=========================
    4701   00:5902                      ;Manually configure an IP address.
    4702   00:5902                      ;
    4703   00:5902                      ;Input:  A = 26
    4704   00:5902                      ;        B = Index of address to set:
    4705   00:5902                      ;            1: Local IP address
    4706   00:5902                      ;            2: Peer IP address
    4707   00:5902                      ;            3: Subnet mask
    4708   00:5902                      ;            4: Default gateway
    4709   00:5902                      ;            5: Primary DNS server IP address
    4710   00:5902                      ;            6: Secondary DNS server IP address
    4711   00:5902                      ;        L.H.E.D = Address value
    4712   00:5902                      ;Output: A = Error code
    4713   00:5902                      TCPIP_CONFIG_IP:
    4714   00:5902                          SEND_DATA                       ; Send the command
    4714   00:5902  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4715   00:5905  AF                      xor a
    4716   00:5906                          SEND_DATA                       ; Send the command size msb
    4716   00:5906  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4717   00:5909  3E 05                   ld  a,5
    4718   00:590B                          SEND_DATA                       ; Send the command size lsb
    4718   00:590B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4719   00:590E  78                      ld  a,b
    4720   00:590F                          SEND_DATA                       ; Send the address to set
    4720   00:590F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4721   00:5912  7D                      ld  a,l
    4722   00:5913                          SEND_DATA                       ; Send the IP first byte
    4722   00:5913  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4723   00:5916  7C                      ld  a,h
    4724   00:5917                          SEND_DATA                       ; Send the IP second byte
    4724   00:5917  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4725   00:591A  7B                      ld  a,e
    4726   00:591B                          SEND_DATA                       ; Send the IP third byte
    4726   00:591B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4727   00:591E  7A                      ld  a,d
    4728   00:591F                          SEND_DATA                       ; Send the IP fourth byte
    4728   00:591F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4729   00:5922                      
    4730   00:5922                          ; Now wait up to 180 ticks to get response
    4731   00:5922  21 B4 00                ld  hl,180
    4732   00:5925  CD 0D 5A                call    SETCOUNTER
    4733   00:5928                      TCPIP_CONFIG_IP_ST1:
    4734   00:5928                          CHECK_DATA
    4734   00:5928  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4734   00:592B  CB 47             >     bit 0,a
    4735   00:592D  20 05                   jr  nz,TCPIP_CONFIG_IP_ST1.1
    4736   00:592F  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4737   00:5932  18 F4                   jr  TCPIP_CONFIG_IP_ST1
    4738   00:5934                      TCPIP_CONFIG_IP_ST1.1:
    4739   00:5934                          ; nz, check the data
    4740   00:5934                          RECEIVE_DATA
    4740   00:5934  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4741   00:5937  FE 1A                   cp  26                          ; Is response of our command?
    4742   00:5939  20 ED                   jr  nz,TCPIP_CONFIG_IP_ST1
    4743   00:593B                          ; now get return code, and that is it
    4744   00:593B                      TCPIP_CONFIG_IP_RC:
    4745   00:593B                          CHECK_DATA
    4745   00:593B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4745   00:593E  CB 47             >     bit 0,a
    4746   00:5940  20 05                   jr  nz,TCPIP_CONFIG_IP_RC.1
    4747   00:5942  CD 94 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4748   00:5945  18 F4                   jr  TCPIP_CONFIG_IP_RC
    4749   00:5947                      TCPIP_CONFIG_IP_RC.1:
    4750   00:5947                          ; nz, discard
    4751   00:5947                          RECEIVE_DATA
    4751   00:5947  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4752   00:594A  C9                      ret                             ; done
    4753   00:594B                      
    4754   00:594B                      ;==========================
    4755   00:594B                      ;===  TCPIP_CONFIG_TTL  ===
    4756   00:594B                      ;==========================
    4757   00:594B                      ;Get/set the value of TTL and TOS for outgoing datagrams.
    4758   00:594B                      ;
    4759   00:594B                      ;Input:  A = 27
    4760   00:594B                      ;        B = 0: Get current values (just return 255 for TTL and 0 for TOS
    4761   00:594B                      ;               as ESP do not expose or allow configurations of it)
    4762   00:594B                      ;            1: Set values
    4763   00:594B                      ;        D = New value for TTL (only if B=1)
    4764   00:594B                      ;        E = New value for ToS (only if B=1)
    4765   00:594B                      ;Output: A = Error code
    4766   00:594B                      ;        D = Value of TTL after the routine execution
    4767   00:594B                      ;        E = Value of ToS after the routine execution
    4768   00:594B                      TCPIP_CONFIG_TTL:
    4769   00:594B  78                      ld  a,b
    4770   00:594C  E6 FE                   and %11111110
    4771   00:594E  B7                      or  a
    4772   00:594F  3E 04                   ld  a,ERR_INV_PARAM
    4773   00:5951  C0                      ret nz
    4774   00:5952  78                      ld  a,b
    4775   00:5953  B7                      or  a
    4776   00:5954                          ; Cant set, so NOT IMP
    4777   00:5954  3E 01                   ld  a,ERR_NOT_IMP
    4778   00:5956  C0                      ret nz                          ; if not get, not implemented
    4779   00:5957                          ; get, so just return D = #FF, A = OK = 0 and E = 0
    4780   00:5957  AF                      xor a
    4781   00:5958  1E 00                   ld  e,0
    4782   00:595A  16 FF                   ld  d,#FF
    4783   00:595C  C9                      ret
    4784   00:595D                      
    4785   00:595D                      ;===========================
    4786   00:595D                      ;===  TCPIP_CONFIG_PING  ===
    4787   00:595D                      ;===========================
    4788   00:595D                      ;Get/set the automatic PING reply flag.
    4789   00:595D                      ;
    4790   00:595D                      ;Input:  A = 28
    4791   00:595D                      ;        B = 0: Get current flag value
    4792   00:595D                      ;            1: Set flag value (ERR_NOT_IMP)
    4793   00:595D                      ;        C = New flag value (only if B=1):
    4794   00:595D                      ;            0: Off
    4795   00:595D                      ;            1: On
    4796   00:595D                      ;Output: A = Error code
    4797   00:595D                      ;        C = Flag value after the routine execution
    4798   00:595D                      TCPIP_CONFIG_PING:
    4799   00:595D  78                      ld  a,b
    4800   00:595E  E6 FE                   and %11111110
    4801   00:5960  B7                      or  a
    4802   00:5961  3E 04                   ld  a,ERR_INV_PARAM
    4803   00:5963  C0                      ret nz
    4804   00:5964  78                      ld  a,b
    4805   00:5965  B7                      or  a
    4806   00:5966                          ; Cant set, so NOT IMP
    4807   00:5966  3E 01                   ld  a,ERR_NOT_IMP
    4808   00:5968  C0                      ret nz                          ; if not get, not implemented
    4809   00:5969                          ; get, so just return C = 1, A = OK = 0
    4810   00:5969  AF                      xor a
    4811   00:596A  0E 01                   ld  c,1
    4812   00:596C  C9                      ret
    4813   00:596D                      
    4814   00:596D                      ;============================
    4815   00:596D                      ;===  Auxiliary routines  ===
    4816   00:596D                      ;============================
    4817   00:596D                      
    4818   00:596D                      ;--- Get slot connected on page 1
    4819   00:596D                      ;    Input:  -
    4820   00:596D                      ;    Output: A = Slot number
    4821   00:596D                      ;    Modifies: AF, HL, E, BC
    4822   00:596D                      
    4823   00:596D                      GETSLT:
    4824   00:596D  DB A8                   in  a,(#A8)
    4825   00:596F  0F                      rrca
    4826   00:5970  0F                      rrca
    4827   00:5971  E6 03                   and 3
    4828   00:5973  4F                      ld  c,a                         ;C = Slot
    4829   00:5974  06 00                   ld  b,0
    4830   00:5976  21 C1 FC                ld  hl,EXPTBL
    4831   00:5979  09                      add hl,bc
    4832   00:597A  7E                      ld  a,(hl)
    4833   00:597B  E6 80                   and #80
    4834   00:597D  B1                      or  c
    4835   00:597E  4F                      ld  c,a
    4836   00:597F  23                      inc hl
    4837   00:5980  23                      inc hl
    4838   00:5981  23                      inc hl
    4839   00:5982  23                      inc hl
    4840   00:5983  7E                      ld  a,(hl)
    4841   00:5984  E6 0C                   and #0C
    4842   00:5986  B1                      or  c
    4843   00:5987  CB 7F                   bit 7,a
    4844   00:5989  C0                      ret nz
    4845   00:598A  E6 03                   and %11
    4846   00:598C  C9                      ret
    4847   00:598D                      
    4848   00:598D                      ;--- Get slot connected on page 1 and test if work area has been created, if not, create it
    4849   00:598D                      ;    Input:  -
    4850   00:598D                      ;    Output: A = Slot number
    4851   00:598D                      ;    Modifies: AF, HL, E, BC
    4852   00:598D                      
    4853   00:598D                      GETSLTT:
    4854   00:598D  DB A8                   in  a,(#A8)
    4855   00:598F  0F                      rrca
    4856   00:5990  0F                      rrca
    4857   00:5991  E6 03                   and 3
    4858   00:5993  4F                      ld  c,a                         ;C = Slot
    4859   00:5994  06 00                   ld  b,0
    4860   00:5996  21 C1 FC                ld  hl,EXPTBL
    4861   00:5999  09                      add hl,bc
    4862   00:599A  7E                      ld  a,(hl)
    4863   00:599B  E6 80                   and #80
    4864   00:599D  B1                      or  c
    4865   00:599E  4F                      ld  c,a
    4866   00:599F  23                      inc hl
    4867   00:59A0  23                      inc hl
    4868   00:59A1  23                      inc hl
    4869   00:59A2  23                      inc hl
    4870   00:59A3  7E                      ld  a,(hl)
    4871   00:59A4  E6 0C                   and #0C
    4872   00:59A6  B1                      or  c
    4873   00:59A7  CB 7F                   bit 7,a
    4874   00:59A9  C2 AE 59                jp  nz,GETSLTT1
    4875   00:59AC  E6 03                   and %11
    4876   00:59AE                      GETSLTT1:
    4877   00:59AE  F5                      push    af
    4878   00:59AF  C5                      push    bc
    4879   00:59B0  E5                      push    hl
    4880   00:59B1  CD C6 59                call    GETWRK
    4881   00:59B4  01 05 00                ld  bc,5
    4882   00:59B7  09                      add hl,bc
    4883   00:59B8  7E                      ld  a,(hl)
    4884   00:59B9  B7                      or  a
    4885   00:59BA  C2 C2 59                jp  nz,GETSLTTRET
    4886   00:59BD  3C                      inc a
    4887   00:59BE  77                      ld  (hl),a
    4888   00:59BF  CD F3 41                call    HIMEM_ALLOC
    4889   00:59C2                      GETSLTTRET:
    4890   00:59C2  E1                      pop hl
    4891   00:59C3  C1                      pop bc
    4892   00:59C4  F1                      pop af
    4893   00:59C5  C9                      ret
    4894   00:59C6                      
    4895   00:59C6                      ;--- Obtain slot work area (8 bytes) on SLTWRK
    4896   00:59C6                      ;    Input:  A  = Slot number
    4897   00:59C6                      ;    Output: HL = Work area address
    4898   00:59C6                      ;    Modifies: AF, BC
    4899   00:59C6                      
    4900   00:59C6                      GETWRK:
    4901   00:59C6  47                      ld  b,a
    4902   00:59C7  0F                      rrca
    4903   00:59C8  0F                      rrca
    4904   00:59C9  0F                      rrca
    4905   00:59CA  E6 60                   and %01100000
    4906   00:59CC  4F                      ld  c,a                         ;C = Slot * 32
    4907   00:59CD  78                      ld  a,b
    4908   00:59CE  07                      rlca
    4909   00:59CF  E6 18                   and %00011000                   ;A = Subslot * 8
    4910   00:59D1  B1                      or  c
    4911   00:59D2  4F                      ld  c,a
    4912   00:59D3  06 00                   ld  b,0
    4913   00:59D5  21 09 FD                ld  hl,SLTWRK
    4914   00:59D8  09                      add hl,bc
    4915   00:59D9  C9                      ret
    4916   00:59DA                      
    4917   00:59DA                      ;--- Obtain the address where our memory area address in high memory is stored
    4918   00:59DA                      ;    Input:  A  = Slot number
    4919   00:59DA                      ;    Output: HL = High memory area address
    4920   00:59DA                      ;    Modifies: AF, BC
    4921   00:59DA                      
    4922   00:59DA                      GETMEMPOINTERADDR:
    4923   00:59DA  47                      ld  b,a
    4924   00:59DB  0F                      rrca
    4925   00:59DC  0F                      rrca
    4926   00:59DD  0F                      rrca
    4927   00:59DE  E6 60                   and %01100000
    4928   00:59E0  4F                      ld  c,a                         ; C = Slot * 32
    4929   00:59E1  78                      ld  a,b
    4930   00:59E2  07                      rlca
    4931   00:59E3  E6 18                   and %00011000                   ; A = Subslot * 8
    4932   00:59E5  B1                      or  c
    4933   00:59E6  4F                      ld  c,a
    4934   00:59E7  06 00                   ld  b,0
    4935   00:59E9  D2 ED 59                jp  nc,GETMEM_1
    4936   00:59EC  04                      inc b
    4937   00:59ED                      GETMEM_1:
    4938   00:59ED  21 09 FD                ld  hl,SLTWRK
    4939   00:59F0  09                      add hl,bc
    4940   00:59F1  01 05 00                ld  bc,5
    4941   00:59F4  09                      add hl,bc
    4942   00:59F5  C9                      ret
    4943   00:59F6                      
    4944   00:59F6                      ;--- Obtain the address where our memory area address in high memory is stored
    4945   00:59F6                      ;    Input:  A  = Slot number
    4946   00:59F6                      ;    Output: HL = High memory area address
    4947   00:59F6                      ;    Modifies: AF, BC
    4948   00:59F6                      
    4949   00:59F6                      GETMEMPOINTER:
    4950   00:59F6  CD DA 59                call    GETMEMPOINTERADDR
    4951   00:59F9  4E                      ld  c,(hl)
    4952   00:59FA  23                      inc hl
    4953   00:59FB  66                      ld  h,(hl)
    4954   00:59FC  69                      ld  l,c
    4955   00:59FD  C9                      ret
    4956   00:59FE                      
    4957   00:59FE                      ;--- Obtain our HTIM_I driven counter value in high memory
    4958   00:59FE                      ;    Input:  none
    4959   00:59FE                      ;    Output: HL = counter value
    4960   00:59FE                      ;    Modifies: AF, HL, DE, BC
    4961   00:59FE                      
    4962   00:59FE                      GETCOUNTER:
    4963   00:59FE  CD 6D 59                call    GETSLT
    4964   00:5A01                          ; Slot in A, now get the address of our counter
    4965   00:5A01  CD F6 59                call    GETMEMPOINTER
    4966   00:5A04                          ; HL has the address of our memory area, counter is 5 bytes after start
    4967   00:5A04  11 05 00                ld  de,MEMORY_COUNTER_OFFSET
    4968   00:5A07  19                      add hl,de
    4969   00:5A08                          ; Ok, this is where our counter is so get it
    4970   00:5A08  5E                      ld  e,(hl)
    4971   00:5A09  23                      inc hl
    4972   00:5A0A  56                      ld  d,(hl)
    4973   00:5A0B                          ; DE has the counter value
    4974   00:5A0B  EB                      ex  de,hl                       ; Counter value in HL
    4975   00:5A0C  C9                      ret
    4976   00:5A0D                      
    4977   00:5A0D                      ;--- Set our HTIM_I driven counter value in high memory
    4978   00:5A0D                      ;    Input:  HL = new counter value
    4979   00:5A0D                      ;    Output: none
    4980   00:5A0D                      ;    Modifies: AF, HL, DE, BC
    4981   00:5A0D                      
    4982   00:5A0D                      SETCOUNTER:
    4983   00:5A0D  E5                      push    hl                      ; Save parameter
    4984   00:5A0E  CD 6D 59                call    GETSLT
    4985   00:5A11                          ; Slot in A, now get the address of our counter
    4986   00:5A11  CD F6 59                call    GETMEMPOINTER
    4987   00:5A14                          ; HL has the address of our memory area, counter is 5 bytes after start
    4988   00:5A14  11 05 00                ld  de,MEMORY_COUNTER_OFFSET
    4989   00:5A17  19                      add hl,de
    4990   00:5A18                          ; Ok, this is where our counter is so get it
    4991   00:5A18                          ; HL has the address of counter
    4992   00:5A18  D1                      pop de                          ; Restore parameter in DE
    4993   00:5A19  73                      ld  (hl),e
    4994   00:5A1A  23                      inc hl
    4995   00:5A1B  72                      ld  (hl),d
    4996   00:5A1C  C9                      ret
    4997   00:5A1D                      
    4998   00:5A1D                      ;--- Obtain a one byte param saved in high memory
    4999   00:5A1D                      ;    Input:  none
    5000   00:5A1D                      ;    Output: A = param
    5001   00:5A1D                      ;    Modifies: AF
    5002   00:5A1D                      
    5003   00:5A1D                      GETBYTE:
    5004   00:5A1D  C5                      push    bc
    5005   00:5A1E  D5                      push    de
    5006   00:5A1F  E5                      push    hl
    5007   00:5A20  CD 6D 59                call    GETSLT
    5008   00:5A23                          ; Slot in A, now get the address of our counter
    5009   00:5A23  CD F6 59                call    GETMEMPOINTER
    5010   00:5A26                          ; HL has the address of our memory area, param is 7 bytes after start
    5011   00:5A26  11 07 00                ld  de,MEMORY_SB_VAR_OFFSET
    5012   00:5A29  19                      add hl,de
    5013   00:5A2A                          ; Ok, this is where our param is so get it
    5014   00:5A2A  7E                      ld  a,(hl)
    5015   00:5A2B  E1                      pop hl
    5016   00:5A2C  D1                      pop de
    5017   00:5A2D  C1                      pop bc
    5018   00:5A2E  C9                      ret
    5019   00:5A2F                      
    5020   00:5A2F                      ;--- Set a one byte param value in high memory
    5021   00:5A2F                      ;    Input:  A = new counter value
    5022   00:5A2F                      ;    Output: none
    5023   00:5A2F                      ;    Modifies: AF
    5024   00:5A2F                      
    5025   00:5A2F                      SETBYTE:
    5026   00:5A2F  C5                      push    bc
    5027   00:5A30  D5                      push    de
    5028   00:5A31  E5                      push    hl
    5029   00:5A32  F5                      push    af                      ; Save parameter
    5030   00:5A33  CD 6D 59                call    GETSLT
    5031   00:5A36                          ; Slot in A, now get the address
    5032   00:5A36  CD F6 59                call    GETMEMPOINTER
    5033   00:5A39                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5034   00:5A39  11 07 00                ld  de,MEMORY_SB_VAR_OFFSET
    5035   00:5A3C  19                      add hl,de
    5036   00:5A3D                          ; HL has the address of param
    5037   00:5A3D  F1                      pop af                          ; Restore parameter
    5038   00:5A3E  77                      ld  (hl),a
    5039   00:5A3F  E1                      pop hl
    5040   00:5A40  D1                      pop de
    5041   00:5A41  C1                      pop bc
    5042   00:5A42  C9                      ret
    5043   00:5A43                      
    5044   00:5A43                      ;--- Obtain a two bytes param saved in high memory
    5045   00:5A43                      ;    Input:  none
    5046   00:5A43                      ;    Output: HL = param
    5047   00:5A43                      ;    Modifies: AF, HL
    5048   00:5A43                      
    5049   00:5A43                      GETWORD:
    5050   00:5A43  C5                      push    bc
    5051   00:5A44  D5                      push    de
    5052   00:5A45  CD 6D 59                call    GETSLT
    5053   00:5A48                          ; Slot in A, now get the address of our counter
    5054   00:5A48  CD F6 59                call    GETMEMPOINTER
    5055   00:5A4B                          ; HL has the address of our memory area, param is 7 bytes after start
    5056   00:5A4B  11 0B 00                ld  de,MEMORY_DB_VAR_OFFSET
    5057   00:5A4E  19                      add hl,de
    5058   00:5A4F                          ; Ok, this is where our param is so get it
    5059   00:5A4F  5E                      ld  e,(hl)
    5060   00:5A50  23                      inc hl
    5061   00:5A51  56                      ld  d,(hl)
    5062   00:5A52  EB                      ex  de,hl                       ; Return in HL
    5063   00:5A53  D1                      pop de
    5064   00:5A54  C1                      pop bc
    5065   00:5A55  C9                      ret
    5066   00:5A56                      
    5067   00:5A56                      ;--- Set a two bytes param value in high memory
    5068   00:5A56                      ;    Input:  HL = new counter value
    5069   00:5A56                      ;    Output: none
    5070   00:5A56                      ;    Modifies: AF
    5071   00:5A56                      
    5072   00:5A56                      SETWORD:
    5073   00:5A56  C5                      push    bc
    5074   00:5A57  D5                      push    de
    5075   00:5A58  E5                      push    hl
    5076   00:5A59  CD 6D 59                call    GETSLT
    5077   00:5A5C                          ; Slot in A, now get the address
    5078   00:5A5C  CD F6 59                call    GETMEMPOINTER
    5079   00:5A5F                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5080   00:5A5F  11 0B 00                ld  de,MEMORY_DB_VAR_OFFSET
    5081   00:5A62  19                      add hl,de
    5082   00:5A63                          ; HL has the address of param
    5083   00:5A63  D1                      pop de                          ; Restore parameter in DE
    5084   00:5A64  73                      ld  (hl),e
    5085   00:5A65  23                      inc hl
    5086   00:5A66  72                      ld  (hl),d
    5087   00:5A67  EB                      ex  de,hl                       ; Restore HL original value
    5088   00:5A68  D1                      pop de
    5089   00:5A69  C1                      pop bc
    5090   00:5A6A  C9                      ret
    5091   00:5A6B                      
    5092   00:5A6B                      ;--- Restores BC / DE / HL copy saved in high memory
    5093   00:5A6B                      ;    Input:  none
    5094   00:5A6B                      ;    Output: BC / DE / HL
    5095   00:5A6B                      ;    Modifies: AF
    5096   00:5A6B                      
    5097   00:5A6B                      REGRESTORE:
    5098   00:5A6B  CD 6D 59                call    GETSLT
    5099   00:5A6E                          ; Slot in A, now get the address of our counter
    5100   00:5A6E  CD F6 59                call    GETMEMPOINTER
    5101   00:5A71                          ; HL has the address of our memory area, param is 7 bytes after start
    5102   00:5A71  11 0D 00                ld  de,MEMORY_REGBACKUP_OFFSET
    5103   00:5A74  19                      add hl,de
    5104   00:5A75                          ; Ok, this is where our param is so get it
    5105   00:5A75  4E                      ld  c,(hl)
    5106   00:5A76  23                      inc hl
    5107   00:5A77  46                      ld  b,(hl)
    5108   00:5A78  23                      inc hl
    5109   00:5A79  5E                      ld  e,(hl)
    5110   00:5A7A  23                      inc hl
    5111   00:5A7B  56                      ld  d,(hl)
    5112   00:5A7C  23                      inc hl
    5113   00:5A7D  7E                      ld  a,(hl)
    5114   00:5A7E  23                      inc hl
    5115   00:5A7F  66                      ld  h,(hl)
    5116   00:5A80  6F                      ld  l,a
    5117   00:5A81  C9                      ret
    5118   00:5A82                      
    5119   00:5A82                      ;--- Backups BC / DE /HL in high memory
    5120   00:5A82                      ;    Input:  BC / DE / HL
    5121   00:5A82                      ;    Output: none
    5122   00:5A82                      ;    Modifies: AF
    5123   00:5A82                      
    5124   00:5A82                      REGBACKUP:
    5125   00:5A82  E5                      push    hl
    5126   00:5A83  D5                      push    de
    5127   00:5A84  C5                      push    bc
    5128   00:5A85  CD 6D 59                call    GETSLT
    5129   00:5A88                          ; Slot in A, now get the address
    5130   00:5A88  CD F6 59                call    GETMEMPOINTER
    5131   00:5A8B                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5132   00:5A8B  11 0D 00                ld  de,MEMORY_REGBACKUP_OFFSET
    5133   00:5A8E  19                      add hl,de
    5134   00:5A8F                          ; HL has the address of param
    5135   00:5A8F  C1                      pop bc                          ; Restore BC
    5136   00:5A90  71                      ld  (hl),c
    5137   00:5A91  23                      inc hl
    5138   00:5A92  70                      ld  (hl),b
    5139   00:5A93  23                      inc hl
    5140   00:5A94  D1                      pop de                          ; Restore DE
    5141   00:5A95  73                      ld  (hl),e
    5142   00:5A96  23                      inc hl
    5143   00:5A97  72                      ld  (hl),d
    5144   00:5A98  23                      inc hl
    5145   00:5A99  E3                      ex (sp),hl                      ; backup the address and get HL value
    5146   00:5A9A  7D                      ld  a,l
    5147   00:5A9B  E3                      ex (sp),hl                      ; return it to the stack and get back the pointer
    5148   00:5A9C  77                      ld  (hl),a                      ; save l
    5149   00:5A9D  23                      inc hl
    5150   00:5A9E  E3                      ex (sp),hl                      ; backup the address and get HL value
    5151   00:5A9F  7C                      ld  a,h
    5152   00:5AA0  E3                      ex (sp),hl                      ; return it to the stack and get back the pointer
    5153   00:5AA1  77                      ld  (hl),a                      ; save h
    5154   00:5AA2  E1                      pop hl                          ; Restore HL original value
    5155   00:5AA3  C9                      ret
    5156   00:5AA4                      
    5157   00:5AA4                      ;--- Restores BC copy saved in high memory
    5158   00:5AA4                      ;    Input:  none
    5159   00:5AA4                      ;    Output: BC
    5160   00:5AA4                      ;    Modifies: AF
    5161   00:5AA4                      
    5162   00:5AA4                      BCRESTORE:
    5163   00:5AA4  E5                      push    hl
    5164   00:5AA5  D5                      push    de
    5165   00:5AA6  CD 6D 59                call    GETSLT
    5166   00:5AA9                          ; Slot in A, now get the address of our counter
    5167   00:5AA9  CD F6 59                call    GETMEMPOINTER
    5168   00:5AAC                          ; HL has the address of our memory area, param is 7 bytes after start
    5169   00:5AAC  11 0D 00                ld  de,MEMORY_BCBACKUP_OFFSET
    5170   00:5AAF  19                      add hl,de
    5171   00:5AB0                          ; Ok, this is where our param is so get it
    5172   00:5AB0  4E                      ld  c,(hl)
    5173   00:5AB1  23                      inc hl
    5174   00:5AB2  46                      ld  b,(hl)
    5175   00:5AB3  D1                      pop de
    5176   00:5AB4  E1                      pop hl
    5177   00:5AB5  C9                      ret
    5178   00:5AB6                      
    5179   00:5AB6                      ;--- Backups BC in high memory
    5180   00:5AB6                      ;    Input:  BC
    5181   00:5AB6                      ;    Output: none
    5182   00:5AB6                      ;    Modifies: AF
    5183   00:5AB6                      
    5184   00:5AB6                      BCBACKUP:
    5185   00:5AB6  D5                      push    de
    5186   00:5AB7  E5                      push    hl
    5187   00:5AB8  C5                      push    bc
    5188   00:5AB9  CD 6D 59                call    GETSLT
    5189   00:5ABC                          ; Slot in A, now get the address
    5190   00:5ABC  CD F6 59                call    GETMEMPOINTER
    5191   00:5ABF                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5192   00:5ABF  11 0D 00                ld  de,MEMORY_BCBACKUP_OFFSET
    5193   00:5AC2  19                      add hl,de
    5194   00:5AC3                          ; HL has the address of param
    5195   00:5AC3  C1                      pop bc                          ; Restore BC
    5196   00:5AC4  71                      ld  (hl),c
    5197   00:5AC5  23                      inc hl
    5198   00:5AC6  70                      ld  (hl),b
    5199   00:5AC7  E1                      pop hl                          ; Restore HL original value
    5200   00:5AC8  D1                      pop de                          ; Restore DE
    5201   00:5AC9  C9                      ret
    5202   00:5ACA                      
    5203   00:5ACA                      ;--- Restores HL copy saved in high memory
    5204   00:5ACA                      ;    Input:  none
    5205   00:5ACA                      ;    Output: HL
    5206   00:5ACA                      ;    Modifies: AF
    5207   00:5ACA                      
    5208   00:5ACA                      HLRESTORE:
    5209   00:5ACA  C5                      push    bc
    5210   00:5ACB  D5                      push    de
    5211   00:5ACC  CD 6D 59                call    GETSLT
    5212   00:5ACF                          ; Slot in A, now get the address of our counter
    5213   00:5ACF  CD F6 59                call    GETMEMPOINTER
    5214   00:5AD2                          ; HL has the address of our memory area, param is 7 bytes after start
    5215   00:5AD2  11 11 00                ld  de,MEMORY_HLBACKUP_OFFSET
    5216   00:5AD5  19                      add hl,de
    5217   00:5AD6                          ; Ok, this is where our param is so get it
    5218   00:5AD6  5E                      ld  e,(hl)
    5219   00:5AD7  23                      inc hl
    5220   00:5AD8  56                      ld  d,(hl)
    5221   00:5AD9  EB                      ex  de,hl
    5222   00:5ADA  D1                      pop de
    5223   00:5ADB  C1                      pop bc
    5224   00:5ADC  C9                      ret
    5225   00:5ADD                      
    5226   00:5ADD                      ;--- Backups HL in high memory
    5227   00:5ADD                      ;    Input:  HL
    5228   00:5ADD                      ;    Output: none
    5229   00:5ADD                      ;    Modifies: AF
    5230   00:5ADD                      
    5231   00:5ADD                      HLBACKUP:
    5232   00:5ADD  D5                      push    de
    5233   00:5ADE  C5                      push    bc
    5234   00:5ADF  E5                      push    hl
    5235   00:5AE0  CD 6D 59                call    GETSLT
    5236   00:5AE3                          ; Slot in A, now get the address
    5237   00:5AE3  CD F6 59                call    GETMEMPOINTER
    5238   00:5AE6                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5239   00:5AE6  11 11 00                ld  de,MEMORY_HLBACKUP_OFFSET
    5240   00:5AE9  19                      add hl,de
    5241   00:5AEA                          ; HL has the address of param
    5242   00:5AEA  D1                      pop de                          ; Restore HL in de
    5243   00:5AEB  73                      ld  (hl),e
    5244   00:5AEC  23                      inc hl
    5245   00:5AED  72                      ld  (hl),d
    5246   00:5AEE  EB                      ex  de,hl                       ; Restore HL
    5247   00:5AEF  C1                      pop bc                          ; Restore BC
    5248   00:5AF0  D1                      pop de                          ; Restore DE
    5249   00:5AF1  C9                      ret
    5250   00:5AF2                      
    5251   00:5AF2                      ;--- Obtain if DNS is ready saved in high memory
    5252   00:5AF2                      ;    Input:  none
    5253   00:5AF2                      ;    Output: A = DNS ready value
    5254   00:5AF2                      ;    Modifies: AF
    5255   00:5AF2                      
    5256   00:5AF2                      GETDNSREADY:
    5257   00:5AF2  C5                      push    bc
    5258   00:5AF3  D5                      push    de
    5259   00:5AF4  E5                      push    hl
    5260   00:5AF5  CD 6D 59                call    GETSLT
    5261   00:5AF8                          ; Slot in A, now get the address
    5262   00:5AF8  CD F6 59                call    GETMEMPOINTER
    5263   00:5AFB                          ; HL has the address of our memory area, DNS ready is 8 bytes after start
    5264   00:5AFB  11 08 00                ld  de,MEMORY_DNS_READY_OFFSET
    5265   00:5AFE  19                      add hl,de
    5266   00:5AFF                          ; Ok, get it
    5267   00:5AFF  7E                      ld  a,(hl)
    5268   00:5B00  E1                      pop hl
    5269   00:5B01  D1                      pop de
    5270   00:5B02  C1                      pop bc
    5271   00:5B03  C9                      ret
    5272   00:5B04                      
    5273   00:5B04                      ;--- Set DNS redy in high memory
    5274   00:5B04                      ;    Input:  A = new value
    5275   00:5B04                      ;    Output: none
    5276   00:5B04                      ;    Modifies: AF
    5277   00:5B04                      
    5278   00:5B04                      SETDNSREADY:
    5279   00:5B04  C5                      push    bc
    5280   00:5B05  D5                      push    de
    5281   00:5B06  E5                      push    hl
    5282   00:5B07  F5                      push    af                      ; Save parameter
    5283   00:5B08  CD 6D 59                call    GETSLT
    5284   00:5B0B                          ; Slot in A, now get the address
    5285   00:5B0B  CD F6 59                call    GETMEMPOINTER
    5286   00:5B0E                          ; HL has the address of our memory area, DNS ready is 8 bytes after start
    5287   00:5B0E  11 08 00                ld  de,MEMORY_DNS_READY_OFFSET
    5288   00:5B11  19                      add hl,de
    5289   00:5B12                          ; HL has the address of DNS ready
    5290   00:5B12  F1                      pop af                          ; Restore parameter
    5291   00:5B13  77                      ld  (hl),a
    5292   00:5B14  E1                      pop hl
    5293   00:5B15  D1                      pop de
    5294   00:5B16  C1                      pop bc
    5295   00:5B17  C9                      ret
    5296   00:5B18                      
    5297   00:5B18                      ;--- Obtain DNS result saved in high memory
    5298   00:5B18                      ;    Input:  none
    5299   00:5B18                      ;    Output: HL DE = DNS result
    5300   00:5B18                      ;    Modifies: AF
    5301   00:5B18                      
    5302   00:5B18                      GETDNSRESULT:
    5303   00:5B18  C5                      push    bc
    5304   00:5B19  CD 6D 59                call    GETSLT
    5305   00:5B1C                          ; Slot in A, now get the address
    5306   00:5B1C  CD F6 59                call    GETMEMPOINTER
    5307   00:5B1F                          ; HL has the address of our memory area, DNS result is 9 bytes after start
    5308   00:5B1F  11 09 00                ld  de,MEMORY_DNS_RES_OFFSET
    5309   00:5B22  19                      add hl,de
    5310   00:5B23                          ; Ok, get it, first bytes are hl
    5311   00:5B23  5E                      ld  e,(hl)
    5312   00:5B24  23                      inc hl
    5313   00:5B25  56                      ld  d,(hl)
    5314   00:5B26  D5                      push    de                      ; for now, save in stack, so we can restore to HL later
    5315   00:5B27  23                      inc hl
    5316   00:5B28  5E                      ld  e,(hl)
    5317   00:5B29  23                      inc hl
    5318   00:5B2A  56                      ld  d,(hl)
    5319   00:5B2B  E1                      pop hl                          ; and now restore HL value from stack
    5320   00:5B2C  C1                      pop bc
    5321   00:5B2D  C9                      ret
    5322   00:5B2E                      
    5323   00:5B2E                      ;--- Set DNS result in high memory
    5324   00:5B2E                      ;    Input:  HL DE = new value
    5325   00:5B2E                      ;    Output: none
    5326   00:5B2E                      ;    Modifies: AF
    5327   00:5B2E                      
    5328   00:5B2E                      SETDNSRESULT:
    5329   00:5B2E  C5                      push    bc
    5330   00:5B2F  D5                      push    de
    5331   00:5B30  E5                      push    hl
    5332   00:5B31  CD 6D 59                call    GETSLT
    5333   00:5B34                          ; Slot in A, now get the address
    5334   00:5B34  CD F6 59                call    GETMEMPOINTER
    5335   00:5B37                          ; HL has the address of our memory area, DNS result is 9 bytes after start
    5336   00:5B37  11 09 00                ld  de,MEMORY_DNS_RES_OFFSET
    5337   00:5B3A  19                      add hl,de
    5338   00:5B3B                          ; HL has the address of DNS result
    5339   00:5B3B  C1                      pop bc                          ; Restore parameter HL in BC
    5340   00:5B3C  71                      ld  (hl),c
    5341   00:5B3D  23                      inc hl
    5342   00:5B3E  70                      ld  (hl),b
    5343   00:5B3F  D1                      pop de                          ; Restore parameter DE in DE
    5344   00:5B40  23                      inc hl
    5345   00:5B41  73                      ld  (hl),e
    5346   00:5B42  23                      inc hl
    5347   00:5B43  72                      ld  (hl),d
    5348   00:5B44  69                      ld  l,c
    5349   00:5B45  60                      ld  h,b                         ; And HL is restored
    5350   00:5B46  C1                      pop bc                          ; Restore BC
    5351   00:5B47  C9                      ret
    5352   00:5B48                      
    5353   00:5B48                      ;--- Convert a character to upper-case if it is a lower-case letter
    5354   00:5B48                      TOUPPER:
    5355   00:5B48  FE 61                   cp  "a"
    5356   00:5B4A  D8                      ret c
    5357   00:5B4B  FE 7B                   cp  "z"+1
    5358   00:5B4D  D0                      ret nc
    5359   00:5B4E  E6 DF                   and #DF
    5360   00:5B50  C9                      ret
    5361   00:5B51                      
    5362   00:5B51                      ;*********************************************
    5363   00:5B51                      ;***       WAIT_RESPONSE_FROM_ESP          ***
    5364   00:5B51                      ;*** Will wait ESP to send a response,     ***
    5365   00:5B51                      ;*** discarding all data until it is found.***
    5366   00:5B51                      ;***                                       ***
    5367   00:5B51                      ;*** Inputs:                               ***
    5368   00:5B51                      ;*** HL - Expected response string         ***
    5369   00:5B51                      ;*** A - Response Size                     ***
    5370   00:5B51                      ;*** DE - TimeOut in ticks                 ***
    5371   00:5B51                      ;***                                       ***
    5372   00:5B51                      ;*** Output:                               ***
    5373   00:5B51                      ;*** A - 0 if response received            ***
    5374   00:5B51                      ;*** otherwise response not received and   ***
    5375   00:5B51                      ;*** timed-out.                            ***
    5376   00:5B51                      ;***                                       ***
    5377   00:5B51                      ;*** Changes HL, BC, AF, DE, IX            ***
    5378   00:5B51                      ;*********************************************
    5379   00:5B51                      WRFE_WAIT_DATA:
    5380   00:5B51                          LOAD_STS_PORT_IN_A
    5380   00:5B51  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    5381   00:5B54  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    5382   00:5B56  20 06                   jr  nz,WRFE_STS_NOT_AVAILABLE
    5383   00:5B58  CB 47                   bit 0,a                         ; if nz has data
    5384   00:5B5A  C0                      ret nz
    5385   00:5B5B  1B                      dec de
    5386   00:5B5C  76                      halt
    5387   00:5B5D  C9                      ret
    5388   00:5B5E                      WRFE_STS_NOT_AVAILABLE:
    5389   00:5B5E  11 00 00                ld  de,0
    5390   00:5B61  AF                      xor a
    5391   00:5B62  C9                      ret
    5392   00:5B63                      
    5393   00:5B63                      WRFE_COMPARE:
    5394   00:5B63  47                      ld  b,a
    5395   00:5B64  7E                      ld  a,(hl)
    5396   00:5B65  B8                      cp  b
    5397   00:5B66  C0                      ret nz
    5398   00:5B67  23                      inc hl
    5399   00:5B68  C9                      ret
    5400   00:5B69                      
    5401   00:5B69                      WAIT_RESPONSE_FROM_ESP:
    5402   00:5B69  4F                      ld  c,a                         ; Response size in C
    5403   00:5B6A  E5                      push    hl                      ; Save HL
    5404   00:5B6B  AF                      xor a
    5405   00:5B6C                      WRFE_ST1:
    5406   00:5B6C  DD 67                   ld  ixh,a                       ; We start at index 0
    5407   00:5B6E                      
    5408   00:5B6E                      WRFE_LOOP:
    5409   00:5B6E  CD 51 5B                call    WRFE_WAIT_DATA
    5410   00:5B71  20 07                   jr  nz,WRFE_LOOP.1
    5411   00:5B73  7B                      ld  a,e
    5412   00:5B74  B2                      or  d
    5413   00:5B75  CA 95 5B                jp  z,WRFE_RET_ERROR
    5414   00:5B78  18 F4                   jr  WRFE_LOOP
    5415   00:5B7A                      WRFE_LOOP.1:
    5416   00:5B7A                          ; nz, check the data
    5417   00:5B7A                          RECEIVE_DATA
    5417   00:5B7A  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    5418   00:5B7D                          ; Ok, now the byte is in A, let's compare
    5419   00:5B7D                      WRFE_IDXCMD:
    5420   00:5B7D  CD 63 5B                call WRFE_COMPARE
    5421   00:5B80                          ; if match
    5422   00:5B80  28 07                   jr  z,WRFE_RSP_MATCH
    5423   00:5B82                          ; did not match, let's zero the rsp index
    5424   00:5B82  AF                      xor a
    5425   00:5B83  DD 67                   ld  ixh,a                       ; re-start at index 0
    5426   00:5B85  E1                      pop hl                          ; restore the response index
    5427   00:5B86  E5                      push    hl                      ; and keep it in stack
    5428   00:5B87                          ; back to get another byte
    5429   00:5B87  18 E5                   jr  WRFE_LOOP
    5430   00:5B89                      WRFE_RSP_MATCH:
    5431   00:5B89                          ; match
    5432   00:5B89  DD 24                   inc ixh
    5433   00:5B8B  DD 7C                   ld  a,ixh
    5434   00:5B8D  B9                      cp  c
    5435   00:5B8E                          ; if a = c done and response is success
    5436   00:5B8E  28 02                   jr  z,WRFE_RET_OK
    5437   00:5B90                          ; not done, back to get more bytes
    5438   00:5B90  18 DC                   jr  WRFE_LOOP
    5439   00:5B92                      WRFE_RET_OK:
    5440   00:5B92  E1                      pop hl
    5441   00:5B93  AF                      xor a
    5442   00:5B94  C9                      ret
    5443   00:5B95                      WRFE_RET_ERROR:
    5444   00:5B95  E1                      pop hl
    5445   00:5B96  3E 01                   ld  a,1
    5446   00:5B98  C9                      ret
    5447   00:5B99                      
    5448   00:5B99                      ;*********************************************
    5449   00:5B99                      ;***              RESET ESP                ***
    5450   00:5B99                      ;*** If RESET ok, A will be 0, otherwise   ***
    5451   00:5B99                      ;*** failure                               ***
    5452   00:5B99                      ;*********************************************
    5453   00:5B99                      RESET_ESP:
    5454   00:5B99                          ; Is ESP installed?
    5455   00:5B99                          CLEAR_UART                      ; Clear UART
    5455   00:5B99  3E 14             >     ld  a,20
    5455   00:5B9B  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    5456   00:5B9E  3E 3F                   ld  a,CMD_QUERY_ESP
    5457   00:5BA0                          SEND_DATA
    5457   00:5BA0  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    5458   00:5BA3  21 38 5D                ld  hl,RSP_CMD_QUERY_ESP        ; Expected response
    5459   00:5BA6  11 3C 00                ld  de,60                       ; Up to 1s @ 60Hz
    5460   00:5BA9  3E 02                   ld  a,RSP_CMD_QUERY_ESP_SIZE    ; Size of response
    5461   00:5BAB  CD 69 5B                call    WAIT_RESPONSE_FROM_ESP
    5462   00:5BAE  B7                      or  a
    5463   00:5BAF  3E 01                   ld  a,1
    5464   00:5BB1  28 03                   jr  z,RESET_ESP_INIT            ; ESP Found
    5465   00:5BB3  06 00                   ld  b,0                         ; 0 if no response
    5466   00:5BB5  C9                      ret
    5467   00:5BB6                      RESET_ESP_INIT:
    5468   00:5BB6  06 03                   ld  b,3                         ; Retry up to 10 times
    5469   00:5BB8                      RESET_ESP_LOOP:
    5470   00:5BB8                          CLEAR_UART
    5470   00:5BB8  3E 14             >     ld  a,20
    5470   00:5BBA  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    5471   00:5BBD                          SET_SPEED
    5471   00:5BBD  AF                >     xor a
    5471   00:5BBE  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    5472   00:5BC1  76                      halt
    5473   00:5BC2  76                      halt                            ; Wait a little to make sure speed is adjusted
    5474   00:5BC3  3E 57                   ld  a,CMD_WRESET_ESP
    5475   00:5BC5                          SEND_DATA
    5475   00:5BC5  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    5476   00:5BC8  21 33 5D                ld  hl,RSP_CMD_RESET_ESP        ; Expected response
    5477   00:5BCB  11 5A 00                ld  de,90                       ; Up to 1.5s @ 60Hz
    5478   00:5BCE  3E 05                   ld  a,RSP_CMD_RESET_ESP_SIZE    ; Size of response
    5479   00:5BD0  C5                      push    bc                      ; Save retry counter
    5480   00:5BD1  CD 69 5B                call    WAIT_RESPONSE_FROM_ESP
    5481   00:5BD4  C1                      pop bc                          ; restore retry counter
    5482   00:5BD5  B7                      or  a                           ; Did WAIT RESPONSE return zero?
    5483   00:5BD6  C8                      ret z                           ; Yes, Warm Reset Ok
    5484   00:5BD7  10 DF                   djnz RESET_ESP_LOOP             ; No, decrement retry counter and let the loop check
    5485   00:5BD9                          ; No more retries? Then check if it is old ESP FW
    5486   00:5BD9                      RESET_CHK_IF_INSTALLED:
    5487   00:5BD9                          ; No more retries? Then it is old ESP FW
    5488   00:5BD9  06 01                   ld  b,1
    5489   00:5BDB  C9                      ret
    5490   00:5BDC                      
    5491   00:5BDC                      ;*********************************************
    5492   00:5BDC                      ;***              SET TIME                 ***
    5493   00:5BDC                      ;*** H - Hour                              ***
    5494   00:5BDC                      ;*** L - Minutes                           ***
    5495   00:5BDC                      ;*** D - Seconds                           ***
    5496   00:5BDC                      ;***                                       ***
    5497   00:5BDC                      ;*** A - 0 if Ok otherwise invalid time    ***
    5498   00:5BDC                      ;*********************************************
    5499   00:5BDC                      SET_TIME:
    5500   00:5BDC  7C                      ld  a,h                         ; Hour in A
    5501   00:5BDD  FE 18                   cp  24                          ; Compare to 24
    5502   00:5BDF  30 12                   jr  nc,SET_TIME_ERR             ; If 24 or more, invalid
    5503   00:5BE1  7D                      ld  a,l                         ; Minutes in A
    5504   00:5BE2  FE 3C                   cp  60                          ; Compare to 60
    5505   00:5BE4  30 0D                   jr  nc,SET_TIME_ERR             ; If 60 or more, invalid
    5506   00:5BE6  7A                      LD  a,d                         ; Seconds in D
    5507   00:5BE7  FE 3C                   cp  60                          ; Compare to 60
    5508   00:5BE9  30 08                   jr  nc,SET_TIME_ERR             ; If 60 or more invalid
    5509   00:5BEB  44                      ld  b,h                         ; Hour in B
    5510   00:5BEC  4D                      ld  c,l                         ; Minutes in C
    5511   00:5BED  5A                      ld  e,d                         ; Seconds in E
    5512   00:5BEE  CD F6 5B                call    SET_RTC_TIME            ; Set time in RTC
    5513   00:5BF1  AF                      xor a                           ; 0 in A
    5514   00:5BF2  C9                      ret                             ; Return
    5515   00:5BF3                      ;   Invalid parameter
    5516   00:5BF3                      SET_TIME_ERR:
    5517   00:5BF3  3E 01                   ld  a,1                         ; Invalid Time
    5518   00:5BF5  C9                      ret                             ; Return
    5519   00:5BF6                      
    5520   00:5BF6                      SET_RTC_TIME:
    5521   00:5BF6  6B                      ld  l,e                         ; Seconds in L
    5522   00:5BF7  61                      ld  h,c                         ; Minutes in H
    5523   00:5BF8  50                      ld  d,b                         ; Hour in D
    5524   00:5BF9  CD 51 5C                call    STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13, and set Mode / Page 0
    5525   00:5BFC  3E 0F                   ld  a,#F                        ; Register F
    5526   00:5BFE  D3 B4                   out (#B4),a
    5527   00:5C00  3E 02                   ld  a,2
    5528   00:5C02  D3 B5                   out (#B5),a                     ; Timer reset seconds and on both clock pulses
    5529   00:5C04  1E 00                   ld  e,0                         ; Start at register 0
    5530   00:5C06  C3 8C 5C                jp  SET_RTC_DATE.1              ; And save L, H and D, function will return from there
    5531   00:5C09                      
    5532   00:5C09                      ;*********************************************
    5533   00:5C09                      ;***              SET DATE                 ***
    5534   00:5C09                      ;*** HL - Year from 1980 to 2079           ***
    5535   00:5C09                      ;*** D - Month from 1 to 12                ***
    5536   00:5C09                      ;*** E - Day from 1 to 31                  ***
    5537   00:5C09                      ;***                                       ***
    5538   00:5C09                      ;*** A - 0 if Ok otherwise invalid Date    ***
    5539   00:5C09                      ;*********************************************
    5540   00:5C09                      SET_DATE:
    5541   00:5C09  01 44 F8                ld  bc,#F844
    5542   00:5C0C  09                      add hl,bc
    5543   00:5C0D  30 32                   jr  nc,SET_DATE_ERR             ; No carry -> Year is less than 1980, invalid date
    5544   00:5C0F  7C                      ld  a,h
    5545   00:5C10  B7                      or  a
    5546   00:5C11  20 2E                   jr  nz,SET_DATE_ERR             ; If H is set, means year is greater than 2235 ,invalid
    5547   00:5C13  7D                      ld  a,l
    5548   00:5C14  FE 64                   cp  100
    5549   00:5C16  30 29                   jr  nc,SET_DATE_ERR             ; If L >= 100 year is greater than 2079, invalid
    5550   00:5C18  47                      ld  b,a                         ; Year - 1980 in B
    5551   00:5C19  7A                      ld  a,d                         ; Now test month
    5552   00:5C1A  3D                      dec a
    5553   00:5C1B  FE 0C                   cp  12                          ; If 12 or less this should carry
    5554   00:5C1D  30 22                   jr  nc,SET_DATE_ERR             ; otherwise invalid
    5555   00:5C1F  21 44 5C                ld  hl,DAYS_IN_MONTH            ; Days in Month table
    5556   00:5C22  85                      add a,l                         ; add our month
    5557   00:5C23  6F                      ld  l,a                         ; back in L
    5558   00:5C24  30 01                   jr  nc,SET_DATE1                ; no carry done
    5559   00:5C26  24                      inc h                           ; otherwise increase H
    5560   00:5C27                      SET_DATE1:
    5561   00:5C27  3E 1C                   ld  a,28                        ; 28 days
    5562   00:5C29  BE                      cp  (hl)                        ; If month is 28 days, February, need to check if leap and limit is 29 in this year
    5563   00:5C2A  20 08                   jr  nz,SET_DATE2                ; if not, skip below code , so probably above check is if month is february
    5564   00:5C2C  78                      ld  a,b                         ; Year - 1980 in A again
    5565   00:5C2D  E6 03                   and 3                           ; if other than 0, non divisible per 4, so not a leap year
    5566   00:5C2F  20 03                   jr  nz,SET_DATE2                ; Regular year
    5567   00:5C31  21 50 5C                ld  hl,DAYS_IN_FEBRUARY_LEAP    ; HL has address of 29 days, maximum number of days for february in leap year
    5568   00:5C34                      SET_DATE2:
    5569   00:5C34  7B                      ld  a,e                         ; Day of month in A
    5570   00:5C35  3D                      dec a                           ; Decrement
    5571   00:5C36  BE                      cp  (hl)                        ; Compare with Days in month
    5572   00:5C37  30 08                   jr  nc,SET_DATE_ERR             ; If day is greater than how many days in month, invalid
    5573   00:5C39  6B                      ld  l,e                         ; Day of month in L
    5574   00:5C3A  62                      ld  h,d                         ; Month in H
    5575   00:5C3B  50                      ld  d,b                         ; Year - 1980 in D
    5576   00:5C3C  CD 76 5C                call    SET_RTC_DATE            ; Set date in RTC
    5577   00:5C3F  AF                      xor a                           ; A = 0
    5578   00:5C40  C9                      ret                             ; Success
    5579   00:5C41                      ;   Invalid parameter
    5580   00:5C41                      SET_DATE_ERR:
    5581   00:5C41  3E 01                   ld  a,1
    5582   00:5C43  C9                      ret
    5583   00:5C44                      
    5584   00:5C44                      ; Table of top day value for each month
    5585   00:5C44                      DAYS_IN_MONTH:          db  31,28,31,30,31,30,31,31,30,31,30,31
    5585   00:5C44  1F 1C 1F 1E 1F 1E 1F 1F 1E 1F 1E 1F 
    5586   00:5C50                      ; And top day value in February when Leap Year
    5587   00:5C50  1D                  DAYS_IN_FEBRUARY_LEAP:  db  29
    5588   00:5C51                      
    5589   00:5C51                      ; Will select Mode 00 (Date and Time page) and stop clock counting
    5590   00:5C51                      ; Register D value will be left in A
    5591   00:5C51                      STOP_RTC_COUNT_SET_MODE0:
    5592   00:5C51  3E 0D                   ld  a,#D
    5593   00:5C53  D3 B4                   out (#B4),a                     ; Select RTC register D (mode)
    5594   00:5C55  DB B5                   in  a,(#B5)                     ; read register D
    5595   00:5C57  E6 04                   and 4                           ; Save Alarm EN setting, and mode register is 00 and stop counting time
    5596   00:5C59  D3 B5                   out (#B5),a                     ; And save
    5597   00:5C5B  C9                      ret
    5598   00:5C5C                      
    5599   00:5C5C                      ; Will get a non BCD value in A, convert it to BCD and then save it in
    5600   00:5C5C                      ; a register pair that starts in the register indicated in E
    5601   00:5C5C                      ; Register E will have the next register after that register pair
    5602   00:5C5C                      RTC_SAVE_REGISTERPAIR:
    5603   00:5C5C  4F                      ld  c,a                         ; Save A in C
    5604   00:5C5D  AF                      xor a                           ; 0 in A
    5605   00:5C5E  06 08                   ld  b,8                         ; 8 in B, number of bits for conversion
    5606   00:5C60                      RTC_SAVE_REGISTERPAIR.1:
    5607   00:5C60  CB 01                   rlc c                           ; Leftmost bit in Carry
    5608   00:5C62  8F                      adc a,a                         ; A = (A * 2) + Carry
    5609   00:5C63  27                      daa                             ; decimal adjust A, shift = BCD x 2 + carry
    5610   00:5C64  10 FA                   djnz    RTC_SAVE_REGISTERPAIR.1 ; Repeat for 8 bits
    5611   00:5C66  CD 6D 5C                call    SET_RTC_REG             ; Save LSB in register and increase register address
    5612   00:5C69  0F                      rrca
    5613   00:5C6A  0F                      rrca
    5614   00:5C6B  0F                      rrca
    5615   00:5C6C  0F                      rrca                            ; now MSB is in LSB position
    5616   00:5C6D                      SET_RTC_REG:
    5617   00:5C6D  47                      ld  b,a                         ; save value to set in B
    5618   00:5C6E  7B                      ld  a,e                         ; and now register address in A
    5619   00:5C6F  D3 B4                   out (#B4),a                     ; The register we want to set
    5620   00:5C71  78                      ld  a,b                         ; restore value
    5621   00:5C72  D3 B5                   out (#B5),a                     ; save it
    5622   00:5C74  1C                      inc e                           ; increase register address, as this usually is done in pairs
    5623   00:5C75  C9                      ret
    5624   00:5C76                      
    5625   00:5C76                      ; Auxiliary function for SET_DATE and SET_TIME
    5626   00:5C76                      ; SET_RTC_DATE will save date, parameters:
    5627   00:5C76                      ; L - Day
    5628   00:5C76                      ; H - Month
    5629   00:5C76                      ; D - Years since 1980
    5630   00:5C76                      ; All values are regular values, this function will properly convert them
    5631   00:5C76                      ;
    5632   00:5C76                      ; SET_RTC_DATE.1 is used by SET_TIME as well
    5633   00:5C76                      ; It will save three register pairs, starting with the register in E
    5634   00:5C76                      ; First pair is updated with value in L
    5635   00:5C76                      ; Second pair is updated with value in H
    5636   00:5C76                      ; Third pair is updated with value in D
    5637   00:5C76                      SET_RTC_DATE:
    5638   00:5C76  CD 51 5C                call    STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13, and set Mode / Page 0
    5639   00:5C79  F6 01                   or  1                           ; Set Bit 0, so Mode / Page 1
    5640   00:5C7B  D3 B5                   out (#B5),a                     ; save it in register 13, now page 1 selected
    5641   00:5C7D  3E 0B                   ld  a,#B                        ; Leap Year Counter Register
    5642   00:5C7F  D3 B4                   out (#B4),a                     ; Select it
    5643   00:5C81  7A                      ld  a,d                         ; Load Years in leap year counter
    5644   00:5C82  D3 B5                   out (#B5),a                     ; So it has count of leap years (0 is 1980, leap, and every time it is 4, leap year again)
    5645   00:5C84  CD 51 5C                call    STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13 and set mode / page 0
    5646   00:5C87  CD 51 5C                call    STOP_RTC_COUNT_SET_MODE0; do it a second time... DOS does it, don't want to JYNX it :P
    5647   00:5C8A  1E 07                   ld  e,7                         ; Register 7
    5648   00:5C8C                      SET_RTC_DATE.1:
    5649   00:5C8C  7D                      ld  a,l                         ; A has day
    5650   00:5C8D  CD 5C 5C                call    RTC_SAVE_REGISTERPAIR   ; Will convert day to BCD and save in registers 7 and 8
    5651   00:5C90  7C                      ld  a,h                         ; A has month
    5652   00:5C91  CD 5C 5C                call    RTC_SAVE_REGISTERPAIR   ; Will convert month to BCD and save in register 9 and A
    5653   00:5C94  7A                      ld  a,d                         ; A has how many years since 1980
    5654   00:5C95  CD 5C 5C                call    RTC_SAVE_REGISTERPAIR   ; Will convert to BCD and save in register B and C
    5655   00:5C98  3E 0D                   ld  a,#D                        ; Register D
    5656   00:5C9A  D3 B4                   out (#B4),a                     ; Send it
    5657   00:5C9C  DB B5                   in  a,(#B5)                     ; Read its value
    5658   00:5C9E  F6 08                   or  8                           ; Start counting time again
    5659   00:5CA0  D3 B5                   out (#B5),a                     ; Send
    5660   00:5CA2  C9                      ret
    5661   00:5CA3                      
    5662   00:5CA3                      ; Pattern setup routine
    5663   00:5CA3                      PATTERN_SETUP:
    5664   00:5CA3  AF                      xor a                           ; Bit-16, V9938 and V9958 only
    5665   00:5CA4  21 88 00                ld  hl,#0088                    ; Bit-15 to 0, pattern base address = #0088
    5666   00:5CA7  CD 17 5D                call SET_VDP_WRITE
    5667   00:5CAA  21 B7 5C                ld  hl,PATTERN_DATA             ; Point to hl
    5668   00:5CAD  06 60                   ld  b,8*12                      ; Redraw 12 chars, max 12 chars are suggested
    5669   00:5CAF  0E 98                   ld  c,#98                       ; port #98
    5670   00:5CB1                      OUTI_TO_VRAM_TMS9918:
    5671   00:5CB1  ED A3                   outi                            ; Slower than otir but useful on TMS9918 which requires 29 T-states
    5672   00:5CB3  C2 B1 5C                jp  nz,OUTI_TO_VRAM_TMS9918     ; Therefore, don't use 'djnz' here!
    5673   00:5CB6  C9                      ret
    5674   00:5CB7                      PATTERN_DATA:
    5675   00:5CB7                      ; Pattern-01 is CHR$(1)+CHR$(81) = SCAN_TERMINATOR_OPEN
    5676   00:5CB7  06                      db  %00000110
    5677   00:5CB8  09                      db  %00001001
    5678   00:5CB9  09                      db  %00001001
    5679   00:5CBA  FC                      db  %11111100                   ; "Opened Padlock"
    5680   00:5CBB  FC                      db  %11111100
    5681   00:5CBC  FC                      db  %11111100
    5682   00:5CBD  FC                      db  %11111100
    5683   00:5CBE  00                      db  %00000000
    5684   00:5CBF                      ; Pattern-02 is CHR$(1)+CHR$(82) = SCAN_TERMINATOR_ENC
    5685   00:5CBF  30                      db  %00110000
    5686   00:5CC0  48                      db  %01001000
    5687   00:5CC1  48                      db  %01001000
    5688   00:5CC2  FC                      db  %11111100                   ; "Closed Padlock"
    5689   00:5CC3  FC                      db  %11111100
    5690   00:5CC4  FC                      db  %11111100
    5691   00:5CC5  FC                      db  %11111100
    5692   00:5CC6  00                      db  %00000000
    5693   00:5CC7                      ; Pattern-03 is CHR$(1)+CHR$(83) = Wi-Fi Connected to the AP:
    5694   00:5CC7  00                      db  %00000000
    5695   00:5CC8  00                      db  %00000000
    5696   00:5CC9  70                      db  %01110000
    5697   00:5CCA  70                      db  %01110000                   ; "Full Access Point"
    5698   00:5CCB  70                      db  %01110000
    5699   00:5CCC  20                      db  %00100000
    5700   00:5CCD  20                      db  %00100000
    5701   00:5CCE  70                      db  %01110000
    5702   00:5CCF                      ; Pattern-04 is CHR$(1)+CHR$(84) = Wi-Fi Failed to connect to:
    5703   00:5CCF  00                      db  %00000000
    5704   00:5CD0  88                      db  %10001000
    5705   00:5CD1  50                      db  %01010000
    5706   00:5CD2  20                      db  %00100000                   ; "X"
    5707   00:5CD3  50                      db  %01010000
    5708   00:5CD4  88                      db  %10001000
    5709   00:5CD5  00                      db  %00000000
    5710   00:5CD6  00                      db  %00000000
    5711   00:5CD7                      ; Pattern-05 is CHR$(1)+CHR$(85) = Requesting connection to:
    5712   00:5CD7  00                      db  %00000000
    5713   00:5CD8  00                      db  %00000000
    5714   00:5CD9  50                      db  %01010000
    5715   00:5CDA  20                      db  %00100000                   ; "Partial Access Point"
    5716   00:5CDB  50                      db  %01010000
    5717   00:5CDC  20                      db  %00100000
    5718   00:5CDD  20                      db  %00100000
    5719   00:5CDE  70                      db  %01110000
    5720   00:5CDF                      ; Pattern-06 is CHR$(1)+CHR$(86) = Wi-Fi Did not find the AP:
    5721   00:5CDF  00                      db  %00000000
    5722   00:5CE0  70                      db  %01110000
    5723   00:5CE1  88                      db  %10001000
    5724   00:5CE2  10                      db  %00010000                   ; "?"
    5725   00:5CE3  20                      db  %00100000
    5726   00:5CE4  00                      db  %00000000
    5727   00:5CE5  20                      db  %00100000
    5728   00:5CE6  00                      db  %00000000
    5729   00:5CE7                      ; Pattern-07 is CHR$(1)+CHR$(87) = Wi-Fi is Idle, AP configured:
    5730   00:5CE7  00                      db  %00000000
    5731   00:5CE8  00                      db  %00000000
    5732   00:5CE9  00                      db  %00000000
    5733   00:5CEA  20                      db  %00100000                   ; "i"
    5734   00:5CEB  00                      db  %00000000
    5735   00:5CEC  20                      db  %00100000
    5736   00:5CED  20                      db  %00100000
    5737   00:5CEE  70                      db  %01110000
    5738   00:5CEF                      ; Pattern-08 is CHR$(1)+CHR$(88) = Left Middle Wave
    5739   00:5CEF  00                      db  %00000000
    5740   00:5CF0  20                      db  %00100000
    5741   00:5CF1  40                      db  %01000000
    5742   00:5CF2  40                      db  %01000000                   ; "("
    5743   00:5CF3  40                      db  %01000000
    5744   00:5CF4  20                      db  %00100000
    5745   00:5CF5  00                      db  %00000000
    5746   00:5CF6  00                      db  %00000000
    5747   00:5CF7                      ; Pattern-09 is CHR$(1)+CHR$(89) = Right Middle Wave
    5748   00:5CF7  00                      db  %00000000
    5749   00:5CF8  20                      db  %00100000
    5750   00:5CF9  10                      db  %00010000
    5751   00:5CFA  10                      db  %00010000                   ; ")"
    5752   00:5CFB  10                      db  %00010000
    5753   00:5CFC  20                      db  %00100000
    5754   00:5CFD  00                      db  %00000000
    5755   00:5CFE  00                      db  %00000000
    5756   00:5CFF                      ; Pattern-10 is CHR$(1)+CHR$(90) = Wi-Fi is reconnecting to:
    5757   00:5CFF  00                      db  %00000000
    5758   00:5D00  00                      db  %00000000
    5759   00:5D01  00                      db  %00000000
    5760   00:5D02  A8                      db  %10101000                   ; "..."
    5761   00:5D03  00                      db  %00000000
    5762   00:5D04  00                      db  %00000000
    5763   00:5D05  00                      db  %00000000
    5764   00:5D06  00                      db  %00000000
    5765   00:5D07                      ; Pattern-11 is CHR$(1)+CHR$(91) = Double Dot
    5766   00:5D07  00                      db  %00000000
    5767   00:5D08  00                      db  %00000000
    5768   00:5D09  00                      db  %00000000
    5769   00:5D0A  00                      db  %00000000                   ; ".."
    5770   00:5D0B  00                      db  %00000000
    5771   00:5D0C  66                      db  %01100110
    5772   00:5D0D  66                      db  %01100110
    5773   00:5D0E  00                      db  %00000000
    5774   00:5D0F                      ; Pattern-12 is CHR$(1)+CHR$(92) = Copyright
    5775   00:5D0F  38                      db  %00111000
    5776   00:5D10  44                      db  %01000100
    5777   00:5D11  BA                      db  %10111010
    5778   00:5D12  A2                      db  %10100010                   ; "(c)"
    5779   00:5D13  BA                      db  %10111010
    5780   00:5D14  44                      db  %01000100
    5781   00:5D15  38                      db  %00111000
    5782   00:5D16  00                      db  %00000000
    5783   00:5D17                      ; http://map.grauw.nl/articles/vdp_tut.php
    5784   00:5D17                      ; Set VDP address counter to write from address AHL (17-bits)
    5785   00:5D17                      ; Enables the interrupts
    5786   00:5D17                      SET_VDP_WRITE:
    5787   00:5D17  CB 04                   rlc h
    5788   00:5D19  17                      rla
    5789   00:5D1A  CB 04                   rlc h
    5790   00:5D1C  17                      rla
    5791   00:5D1D  CB 3C                   srl h
    5792   00:5D1F  CB 3C                   srl h
    5793   00:5D21  F3                      di
    5794   00:5D22  D3 99                   out (#99),a
    5795   00:5D24  3E 8E                   ld  a,14+128
    5796   00:5D26  D3 99                   out (#99),a
    5797   00:5D28  7D                      ld  a,l
    5798   00:5D29  00                      nop                             ; Do not remove this 'nop' here!
    5799   00:5D2A  D3 99                   out (#99),a
    5800   00:5D2C  7C                      ld  a,h
    5801   00:5D2D  F6 40                   or  64
    5802   00:5D2F  FB                      ei
    5803   00:5D30  D3 99                   out (#99),a
    5804   00:5D32  C9                      ret
    5805   00:5D33                      
    5806   00:5D33                      ;*********************************************
    5807   00:5D33                      ;***    ESP Specific Commands/Responses    ***
    5808   00:5D33                      ;*********************************************
    5809   00:5D33                      ; Cold reset of ESP firmware
    5810   00:5D33  (00:0052)           CMD_RESET_ESP           equ 'R'
    5811   00:5D33                      ; Warm reset of ESP firmware
    5812   00:5D33  (00:0057)           CMD_WRESET_ESP          equ 'W'
    5813   00:5D33                      ; Hold Wi-Fi Connection On
    5814   00:5D33  (00:0048)           CMD_WIFIHOLD_ESP        equ 'H'
    5815   00:5D33                      ; Release Wi-Fi Connection Hold
    5816   00:5D33  (00:0068)           CMD_WIFIRELEASE_ESP     equ 'h'
    5817   00:5D33                      ; Get Updated time and date from internet
    5818   00:5D33  (00:0047)           CMD_GET_TIME            equ 'G'
    5819   00:5D33                      ; Query Auto Clock settings
    5820   00:5D33  (00:0063)           CMD_QUERY_ACLK_SETTINGS equ 'c'
    5821   00:5D33                      ; Set Auto Clock settings
    5822   00:5D33  (00:0043)           CMD_SET_ACLK_SETTINGS   equ 'C'
    5823   00:5D33                      ; Query ESP settings
    5824   00:5D33  (00:0051)           CMD_QUERY_ESP_SETTINGS  equ 'Q'
    5825   00:5D33                      ; Set Timer Value
    5826   00:5D33  (00:0054)           CMD_TIMER_SET           equ 'T'
    5827   00:5D33                      ; Turn Nagle On
    5828   00:5D33  (00:0044)           CMD_NAGLE_ON            equ 'D'
    5829   00:5D33                      ; Turn Nagle Off
    5830   00:5D33  (00:004E)           CMD_NAGLE_OFF           equ 'N'
    5831   00:5D33                      ; Turn Wi-Fi Off
    5832   00:5D33  (00:004F)           CMD_WIFI_OFF            equ 'O'
    5833   00:5D33                      ; Request to connect to a network
    5834   00:5D33  (00:0041)           CMD_WIFI_CONNECT        equ 'A'
    5835   00:5D33                      ; Request to start network scan
    5836   00:5D33  (00:0053)           CMD_SCAN_START          equ 'S'
    5837   00:5D33                      ; Request network scan result
    5838   00:5D33  (00:0073)           CMD_SCAN_RESULTS        equ 's'
    5839   00:5D33                      ; Request AP Status
    5840   00:5D33  (00:0067)           CMD_AP_STS              equ 'g'
    5841   00:5D33                      ; Get ESP firmware version
    5842   00:5D33  (00:0056)           CMD_GET_ESP_VER         equ 'V'
    5843   00:5D33                      ; After finishing Warm reset, ESP returns ready
    5844   00:5D33  52 65 61 64 79      RSP_CMD_RESET_ESP       db  "Ready"
    5845   00:5D38  (00:0005)           RSP_CMD_RESET_ESP_SIZE  equ 5
    5846   00:5D38                      ; Query ESP Presence
    5847   00:5D38  (00:003F)           CMD_QUERY_ESP           equ '?'
    5848   00:5D38                      ; Query response
    5849   00:5D38  4F 4B               RSP_CMD_QUERY_ESP       db  "OK"
    5850   00:5D3A  (00:0002)           RSP_CMD_QUERY_ESP_SIZE  equ 2
    5851   00:5D3A                      
    5852   00:5D3A                      ;--- Strings
    5853   00:5D3A                      ; Special thanks to KdL
    5854   00:5D3A                      ; He has contributed a lot to make the menus and strings
    5855   00:5D3A                      ; concise and much easier to read and understand!
    5856   00:5D3A  (00:0000)           STTERMINATOR            equ 0
    5857   00:5D3A  (00:000A)           LF                      equ 10
    5858   00:5D3A  (00:000B)           HOME                    equ 11
    5859   00:5D3A  (00:000C)           CLS                     equ 12
    5860   00:5D3A  (00:000D)           CR                      equ 13
    5861   00:5D3A  (00:001C)           GORIGHT                 equ 28
    5862   00:5D3A  (00:001D)           GOLEFT                  equ 29
    5863   00:5D3A                      
    5864   00:5D3A                      ENTERING_WIFI_SETUP:
    5865   00:5D3A  0C                      db  CLS
    5866   00:5D3B                          db  "Entering Wi-Fi Setup..."       ,CR,LF,LF,STTERMINATOR
    5866   00:5D3B  45 6E 74 65 72 69 6E 67 20 57 69 2D 46 69 20 53 
    5866   00:5D4B  65 74 75 70 2E 2E 2E 0D 0A 0A 00 
    5867   00:5D56                      ;---
    5868   00:5D56                      
    5869   00:5D56                      WELCOME:
    5870   00:5D56  0C                      db  CLS
    5871   00:5D57                          db  "MSXPICO TCP/IP UNAPI 1.3"      ,CR,LF
    5871   00:5D57  4D 53 58 50 49 43 4F 20 54 43 50 2F 49 50 20 55 
    5871   00:5D67  4E 41 50 49 20 31 2E 33 0D 0A 
    5872   00:5D71                          db  1,92," 2024 Oduvaldo Pavan Junior" ,CR,LF
    5872   00:5D71  01 5C 20 32 30 32 34 20 4F 64 75 76 61 6C 64 6F 
    5872   00:5D81  20 50 61 76 61 6E 20 4A 75 6E 69 6F 72 0D 0A 
    5873   00:5D90                          db  "ducasp@gmail.com"              ,CR,LF,LF,STTERMINATOR
    5873   00:5D90  64 75 63 61 73 70 40 67 6D 61 69 6C 2E 63 6F 6D 
    5873   00:5DA0  0D 0A 0A 00 
    5874   00:5DA4                      ;---
    5875   00:5DA4                      
    5876   00:5DA4                      WELCOME_SF:
    5877   00:5DA4                          db  "Quick Receive supported."      ,CR,LF,LF,STTERMINATOR
    5877   00:5DA4  51 75 69 63 6B 20 52 65 63 65 69 76 65 20 73 75 
    5877   00:5DB4  70 70 6F 72 74 65 64 2E 0D 0A 0A 00 
    5878   00:5DC0                      ;---
    5879   00:5DC0                      
    5880   00:5DC0                      WELCOME_SF2:
    5881   00:5DC0                          db  "Quick Receive not supported."      ,CR,LF,LF,STTERMINATOR
    5881   00:5DC0  51 75 69 63 6B 20 52 65 63 65 69 76 65 20 6E 6F 
    5881   00:5DD0  74 20 73 75 70 70 6F 72 74 65 64 2E 0D 0A 0A 00 
    5882   00:5DE0                      ;---
    5883   00:5DE0                      
    5884   00:5DE0                      WELCOME_CS:
    5885   00:5DE0                          db  "Wi-Fi is reconnecting to:    " ,GOLEFT,CR,LF
    5885   00:5DE0  57 69 2D 46 69 20 69 73 20 72 65 63 6F 6E 6E 65 
    5885   00:5DF0  63 74 69 6E 67 20 74 6F 3A 20 20 20 20 1D 0D 0A 
    5886   00:5E00                          db  "(",1,88,1,90,1,89,") "         ,STTERMINATOR
    5886   00:5E00  28 01 58 01 5A 01 59 29 20 00 
    5887   00:5E0A                      
    5888   00:5E0A                      WELCOME_NEXT:
    5889   00:5E0A  0B                      db  HOME
    5890   00:5E0B  0A                      db  LF
    5891   00:5E0C  0A                      db  LF
    5892   00:5E0D  0A 0A 00                db  LF,LF,STTERMINATOR
    5893   00:5E10                      ;---
    5894   00:5E10                      
    5895   00:5E10                      WELCOME_S_NEXT:
    5896   00:5E10  0A                      db  LF
    5897   00:5E11  0A 0A 00                db  LF,LF,STTERMINATOR
    5898   00:5E14                      ;---
    5899   00:5E14                      
    5900   00:5E14                      WELCOME_SF_NEXT:
    5901   00:5E14  0A 0A 00                db  LF,LF,STTERMINATOR
    5902   00:5E17                      ;---
    5903   00:5E17                      
    5904   00:5E17                      WELCOME_CS0_NEXT:
    5905   00:5E17                          db  "Wi-Fi is Idle, AP configured:" ,GOLEFT,CR,LF
    5905   00:5E17  57 69 2D 46 69 20 69 73 20 49 64 6C 65 2C 20 41 
    5905   00:5E27  50 20 63 6F 6E 66 69 67 75 72 65 64 3A 1D 0D 0A 
    5906   00:5E37                          db  "(",1,88,1,87,1,89,") "         ,STTERMINATOR
    5906   00:5E37  28 01 58 01 57 01 59 29 20 00 
    5907   00:5E41                      
    5908   00:5E41                      WELCOME_CS1_NEXT:
    5909   00:5E41  0D 0A                   db  CR,LF
    5910   00:5E43                          db  GORIGHT,GORIGHT,GORIGHT,GORIGHT,GORIGHT,GORIGHT,STTERMINATOR
    5910   00:5E43  1C 1C 1C 1C 1C 1C 00 
    5911   00:5E4A                      
    5912   00:5E4A                      WELCOME_CS2_NEXT:
    5913   00:5E4A                          db  "Wi-Fi Wrong Password for:    " ,GOLEFT,CR,LF
    5913   00:5E4A  57 69 2D 46 69 20 57 72 6F 6E 67 20 50 61 73 73 
    5913   00:5E5A  77 6F 72 64 20 66 6F 72 3A 20 20 20 20 1D 0D 0A 
    5914   00:5E6A                          db  "(",1,88,1,82,1,89,") "         ,STTERMINATOR
    5914   00:5E6A  28 01 58 01 52 01 59 29 20 00 
    5915   00:5E74                      
    5916   00:5E74                      WELCOME_CS3_NEXT:
    5917   00:5E74                          db  "Wi-Fi Did not find the AP:   " ,GOLEFT,CR,LF
    5917   00:5E74  57 69 2D 46 69 20 44 69 64 20 6E 6F 74 20 66 69 
    5917   00:5E84  6E 64 20 74 68 65 20 41 50 3A 20 20 20 1D 0D 0A 
    5918   00:5E94                          db  "(",1,88,1,86,1,89,") "         ,STTERMINATOR
    5918   00:5E94  28 01 58 01 56 01 59 29 20 00 
    5919   00:5E9E                      
    5920   00:5E9E                      WELCOME_CS4_NEXT:
    5921   00:5E9E                          db  "Wi-Fi Failed to connect to:  " ,GOLEFT,CR,LF
    5921   00:5E9E  57 69 2D 46 69 20 46 61 69 6C 65 64 20 74 6F 20 
    5921   00:5EAE  63 6F 6E 6E 65 63 74 20 74 6F 3A 20 20 1D 0D 0A 
    5922   00:5EBE                          db  "(",1,88,1,84,1,89,") "         ,STTERMINATOR
    5922   00:5EBE  28 01 58 01 54 01 59 29 20 00 
    5923   00:5EC8                      
    5924   00:5EC8                      WELCOME_CS5_NEXT:
    5925   00:5EC8                          db  "Wi-Fi Connected to the AP:   " ,GOLEFT,CR,LF
    5925   00:5EC8  57 69 2D 46 69 20 43 6F 6E 6E 65 63 74 65 64 20 
    5925   00:5ED8  74 6F 20 74 68 65 20 41 50 3A 20 20 20 1D 0D 0A 
    5926   00:5EE8                          db  "(",1,88,1,83,1,89,") "         ,STTERMINATOR
    5926   00:5EE8  28 01 58 01 53 01 59 29 20 00 
    5927   00:5EF2                      
    5928   00:5EF2                      MMENU_S_NEXT:
    5929   00:5EF2  0D 0A 0A                db  CR,LF,LF
    5930   00:5EF5                          db  "1 - Set Nagle Algorithm"       ,CR,LF
    5930   00:5EF5  31 20 2D 20 53 65 74 20 4E 61 67 6C 65 20 41 6C 
    5930   00:5F05  67 6F 72 69 74 68 6D 0D 0A 
    5931   00:5F0E                          db  "2 - Set Wi-Fi On Period"       ,CR,LF
    5931   00:5F0E  32 20 2D 20 53 65 74 20 57 69 2D 46 69 20 4F 6E 
    5931   00:5F1E  20 50 65 72 69 6F 64 0D 0A 
    5932   00:5F27                          db  "3 - Scan/Join Access Points"   ,CR,LF
    5932   00:5F27  33 20 2D 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 
    5932   00:5F37  63 65 73 73 20 50 6F 69 6E 74 73 0D 0A 
    5933   00:5F44                          db  "4 - Wi-Fi and Clock Settings"  ,CR,LF,LF
    5933   00:5F44  34 20 2D 20 57 69 2D 46 69 20 61 6E 64 20 43 6C 
    5933   00:5F54  6F 63 6B 20 53 65 74 74 69 6E 67 73 0D 0A 0A 
    5934   00:5F63                      ;---
    5935   00:5F63                          db  "ESC to exit setup."            ,CR,LF,LF
    5935   00:5F63  45 53 43 20 74 6F 20 65 78 69 74 20 73 65 74 75 
    5935   00:5F73  70 2E 0D 0A 0A 
    5936   00:5F78                      ;---
    5937   00:5F78                          db  "Option: "                      ,STTERMINATOR
    5937   00:5F78  4F 70 74 69 6F 6E 3A 20 00 
    5938   00:5F81                      
    5939   00:5F81                      MMENU_CLOCK_MSX2:
    5940   00:5F81  0C                      db  CLS
    5941   00:5F82                          db  "[ Wi-Fi and Clock Settings ]"  ,CR,LF,LF
    5941   00:5F82  5B 20 57 69 2D 46 69 20 61 6E 64 20 43 6C 6F 63 
    5941   00:5F92  6B 20 53 65 74 74 69 6E 67 73 20 5D 0D 0A 0A 
    5942   00:5FA1                      ;---
    5943   00:5FA1                          db  "0 - Wi-Fi & UNAPI are online"  ,CR,LF
    5943   00:5FA1  30 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5943   00:5FB1  49 20 61 72 65 20 6F 6E 6C 69 6E 65 0D 0A 
    5944   00:5FBF                          db  "1 - Also wait up to 10s for"   ,CR,LF
    5944   00:5FBF  31 20 2D 20 41 6C 73 6F 20 77 61 69 74 20 75 70 
    5944   00:5FCF  20 74 6F 20 31 30 73 20 66 6F 72 0D 0A 
    5945   00:5FDC                          db  "    internet availability and" ,GOLEFT,CR,LF
    5945   00:5FDC  20 20 20 20 69 6E 74 65 72 6E 65 74 20 61 76 61 
    5945   00:5FEC  69 6C 61 62 69 6C 69 74 79 20 61 6E 64 1D 0D 0A 
    5946   00:5FFC                          db  "    get time from SNTP server" ,GOLEFT,CR,LF
    5946   00:5FFC  20 20 20 20 67 65 74 20 74 69 6D 65 20 66 72 6F 
    5946   00:600C  6D 20 53 4E 54 50 20 73 65 72 76 65 72 1D 0D 0A 
    5947   00:601C                          db  "    adjusting the time zone"   ,CR,LF
    5947   00:601C  20 20 20 20 61 64 6A 75 73 74 69 6E 67 20 74 68 
    5947   00:602C  65 20 74 69 6D 65 20 7A 6F 6E 65 0D 0A 
    5948   00:6039                          db  "2 - The same as option 1 but"  ,CR,LF
    5948   00:6039  32 20 2D 20 54 68 65 20 73 61 6D 65 20 61 73 20 
    5948   00:6049  6F 70 74 69 6F 6E 20 31 20 62 75 74 0D 0A 
    5949   00:6057                          db  "    also will turn off Wi-Fi"  ,CR,LF
    5949   00:6057  20 20 20 20 61 6C 73 6F 20 77 69 6C 6C 20 74 75 
    5949   00:6067  72 6E 20 6F 66 66 20 57 69 2D 46 69 0D 0A 
    5950   00:6075                          db  "    when done"                 ,CR,LF
    5950   00:6075  20 20 20 20 77 68 65 6E 20 64 6F 6E 65 0D 0A 
    5951   00:6084                          db  "3 - Wi-Fi & UNAPI are offline" ,GOLEFT,CR,LF,LF
    5951   00:6084  33 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5951   00:6094  49 20 61 72 65 20 6F 66 66 6C 69 6E 65 1D 0D 0A 
    5951   00:60A4  0A 
    5952   00:60A5                      ;---
    5953   00:60A5                          db  "MSX boot will take longer if"  ,CR,LF
    5953   00:60A5  4D 53 58 20 62 6F 6F 74 20 77 69 6C 6C 20 74 61 
    5953   00:60B5  6B 65 20 6C 6F 6E 67 65 72 20 69 66 0D 0A 
    5954   00:60C3                          db  "options 1 or 2 are active."    ,CR,LF,LF,STTERMINATOR
    5954   00:60C3  6F 70 74 69 6F 6E 73 20 31 20 6F 72 20 32 20 61 
    5954   00:60D3  72 65 20 61 63 74 69 76 65 2E 0D 0A 0A 00 
    5955   00:60E1                      ;---
    5956   00:60E1                      
    5957   00:60E1                      MMENU_CLOCK_MSX1:
    5958   00:60E1  0C                      db  CLS
    5959   00:60E2                          db  "[ Wi-Fi and Clock Settings ]"  ,CR,LF,LF
    5959   00:60E2  5B 20 57 69 2D 46 69 20 61 6E 64 20 43 6C 6F 63 
    5959   00:60F2  6B 20 53 65 74 74 69 6E 67 73 20 5D 0D 0A 0A 
    5960   00:6101                      ;---
    5961   00:6101                          db  "0 - Wi-Fi & UNAPI are online"  ,CR,LF
    5961   00:6101  30 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5961   00:6111  49 20 61 72 65 20 6F 6E 6C 69 6E 65 0D 0A 
    5962   00:611F                          db  "1 - Unavailable for MSX1"      ,CR,LF
    5962   00:611F  31 20 2D 20 55 6E 61 76 61 69 6C 61 62 6C 65 20 
    5962   00:612F  66 6F 72 20 4D 53 58 31 0D 0A 
    5963   00:6139                          db  "2 - Unavailable for MSX1"      ,CR,LF
    5963   00:6139  32 20 2D 20 55 6E 61 76 61 69 6C 61 62 6C 65 20 
    5963   00:6149  66 6F 72 20 4D 53 58 31 0D 0A 
    5964   00:6153                          db  "3 - Wi-Fi & UNAPI are offline" ,GOLEFT,CR,LF,LF,STTERMINATOR
    5964   00:6153  33 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5964   00:6163  49 20 61 72 65 20 6F 66 66 6C 69 6E 65 1D 0D 0A 
    5964   00:6173  0A 00 
    5965   00:6175                      ;---
    5966   00:6175                      
    5967   00:6175                      MMENU_CLOCK_0:
    5968   00:6175                          db  "Currently: ONLINE"             ,STTERMINATOR
    5968   00:6175  43 75 72 72 65 6E 74 6C 79 3A 20 4F 4E 4C 49 4E 
    5968   00:6185  45 00 
    5969   00:6187                      
    5970   00:6187                      MMENU_CLOCK_1:
    5971   00:6187                          db  "Currently: TIME-OPT1, GMT"     ,STTERMINATOR
    5971   00:6187  43 75 72 72 65 6E 74 6C 79 3A 20 54 49 4D 45 2D 
    5971   00:6197  4F 50 54 31 2C 20 47 4D 54 00 
    5972   00:61A1                      
    5973   00:61A1                      MMENU_CLOCK_2:
    5974   00:61A1                          db  "Currently: TIME-OPT2, GMT"     ,STTERMINATOR
    5974   00:61A1  43 75 72 72 65 6E 74 6C 79 3A 20 54 49 4D 45 2D 
    5974   00:61B1  4F 50 54 32 2C 20 47 4D 54 00 
    5975   00:61BB                      
    5976   00:61BB                      MMENU_CLOCK_3:
    5977   00:61BB                          db  "Currently: OFFLINE"            ,STTERMINATOR
    5977   00:61BB  43 75 72 72 65 6E 74 6C 79 3A 20 4F 46 46 4C 49 
    5977   00:61CB  4E 45 00 
    5978   00:61CE                      
    5979   00:61CE                      MMENU_CLOCK_OPT:
    5980   00:61CE  0D 0A 0A                db  CR,LF,LF
    5981   00:61D1                      ;---
    5982   00:61D1                          db  "ESC to return to main menu."   ,CR,LF,LF
    5982   00:61D1  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    5982   00:61E1  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    5983   00:61EF                      ;---
    5984   00:61EF                          db  "Option: "                      ,STTERMINATOR
    5984   00:61EF  4F 70 74 69 6F 6E 3A 20 00 
    5985   00:61F8                      
    5986   00:61F8                      MMENU_GMT_OPT:
    5987   00:61F8  0D 0A                   db  CR,LF
    5988   00:61FA                          db  "Time Zone adjustment: "        ,STTERMINATOR
    5988   00:61FA  54 69 6D 65 20 5A 6F 6E 65 20 61 64 6A 75 73 74 
    5988   00:620A  6D 65 6E 74 3A 20 00 
    5989   00:6211                      
    5990   00:6211                      MMENU_MANUALENTRY:
    5991   00:6211  0C                      db  CLS
    5992   00:6212                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    5992   00:6212  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    5992   00:6222  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    5993   00:6230                      ;---
    5994   00:6230                          db  "ESC to return to main menu."   ,CR,LF,LF
    5994   00:6230  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    5994   00:6240  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    5995   00:624E                      ;---
    5996   00:624E                          db  "Manual entry, type SSID:"      ,CR,LF
    5996   00:624E  4D 61 6E 75 61 6C 20 65 6E 74 72 79 2C 20 74 79 
    5996   00:625E  70 65 20 53 53 49 44 3A 0D 0A 
    5997   00:6268                          db  "(",1,88,1,83,1,89,") "         ,STTERMINATOR
    5997   00:6268  28 01 58 01 53 01 59 29 20 00 
    5998   00:6272                      
    5999   00:6272                      MENU_MANUALENTRY_PWD:
    6000   00:6272  0D 0A 0A                db  CR,LF,LF
    6001   00:6275                      ;---
    6002   00:6275                          db  "Password needed (y/n)? "             ,STTERMINATOR
    6002   00:6275  50 61 73 73 77 6F 72 64 20 6E 65 65 64 65 64 20 
    6002   00:6285  28 79 2F 6E 29 3F 20 00 
    6003   00:628D                      
    6004   00:628D                      MMENU_SCAN:
    6005   00:628D  0C                      db  CLS
    6006   00:628E                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    6006   00:628E  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    6006   00:629E  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    6007   00:62AC                      ;---
    6008   00:62AC                          db  "Up to ",SCAN_MAX_PAGE_SIZE+48," APs per page." ,CR,LF,LF
    6008   00:62AC  55 70 20 74 6F 20 38 20 41 50 73 20 70 65 72 20 
    6008   00:62BC  70 61 67 65 2E 0D 0A 0A 
    6009   00:62C4                      ;---
    6010   00:62C4                          db  "Scanning networks..."          ,CR,LF,STTERMINATOR
    6010   00:62C4  53 63 61 6E 6E 69 6E 67 20 6E 65 74 77 6F 72 6B 
    6010   00:62D4  73 2E 2E 2E 0D 0A 00 
    6011   00:62DB                      
    6012   00:62DB                      MMENU_SCANF:
    6013   00:62DB  0D 0A                   db  CR,LF
    6014   00:62DD                          db  "Error or no networks found!"   ,CR,LF,STTERMINATOR
    6014   00:62DD  45 72 72 6F 72 20 6F 72 20 6E 6F 20 6E 65 74 77 
    6014   00:62ED  6F 72 6B 73 20 66 6F 75 6E 64 21 0D 0A 00 
    6015   00:62FB                      
    6016   00:62FB                      MMENU_SCANN:
    6017   00:62FB  0D 0A                   db  CR,LF
    6018   00:62FD                          db  "No networks found!"            ,CR,LF,STTERMINATOR
    6018   00:62FD  4E 6F 20 6E 65 74 77 6F 72 6B 73 20 66 6F 75 6E 
    6018   00:630D  64 21 0D 0A 00 
    6019   00:6312                      
    6020   00:6312                      MMENU_SCANS:
    6021   00:6312  0C                      db  CLS
    6022   00:6313                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    6022   00:6313  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    6022   00:6323  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    6023   00:6331                      ;---
    6024   00:6331                          db  "Networks available:"           ,CR,LF,LF,STTERMINATOR
    6024   00:6331  4E 65 74 77 6F 72 6B 73 20 61 76 61 69 6C 61 62 
    6024   00:6341  6C 65 3A 0D 0A 0A 00 
    6025   00:6348                      ;---
    6026   00:6348                      
    6027   00:6348                      MMENU_CONNECTING:
    6028   00:6348  0C                      db  CLS
    6029   00:6349                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    6029   00:6349  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    6029   00:6359  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    6030   00:6367                      ;---
    6031   00:6367                          db  "Requesting connection to:"     ,CR,LF
    6031   00:6367  52 65 71 75 65 73 74 69 6E 67 20 63 6F 6E 6E 65 
    6031   00:6377  63 74 69 6F 6E 20 74 6F 3A 0D 0A 
    6032   00:6382                          db  "(",1,88,1,85,1,89,") "         ,STTERMINATOR
    6032   00:6382  28 01 58 01 55 01 59 29 20 00 
    6033   00:638C                      
    6034   00:638C                      MMENU_ASKPWD:
    6035   00:638C  0D 0A                   db  CR,LF
    6036   00:638E                          db  "Hit DEL as first character"    ,CR,LF
    6036   00:638E  48 69 74 20 44 45 4C 20 61 73 20 66 69 72 73 74 
    6036   00:639E  20 63 68 61 72 61 63 74 65 72 0D 0A 
    6037   00:63AA                          db  "to hide/show the typing."      ,CR,LF
    6037   00:63AA  74 6F 20 68 69 64 65 2F 73 68 6F 77 20 74 68 65 
    6037   00:63BA  20 74 79 70 69 6E 67 2E 0D 0A 
    6038   00:63C4                          db  "Password: "                    ,STTERMINATOR
    6038   00:63C4  50 61 73 73 77 6F 72 64 3A 20 00 
    6039   00:63CF                      
    6040   00:63CF                      MMENU_SCANQ:
    6041   00:63CF  0D 0A                   db  CR,LF
    6042   00:63D1                          db  "ESC to return to main menu."   ,CR,LF
    6042   00:63D1  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6042   00:63E1  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 
    6043   00:63EE                          db  "SPACE BAR to scan again."  ,CR,LF
    6043   00:63EE  53 50 41 43 45 20 42 41 52 20 74 6F 20 73 63 61 
    6043   00:63FE  6E 20 61 67 61 69 6E 2E 0D 0A 
    6044   00:6408                          db  "ENTER to type SSID/AP name."   ,CR,LF,LF
    6044   00:6408  45 4E 54 45 52 20 74 6F 20 74 79 70 65 20 53 53 
    6044   00:6418  49 44 2F 41 50 20 6E 61 6D 65 2E 0D 0A 0A 
    6045   00:6426                      ;---
    6046   00:6426                          db  "Number to connect: "       ,STTERMINATOR
    6046   00:6426  4E 75 6D 62 65 72 20 74 6F 20 63 6F 6E 6E 65 63 
    6046   00:6436  74 3A 20 00 
    6047   00:643A                      
    6048   00:643A                      MMENU_SCANQM:
    6049   00:643A  0D 0A                   db  CR,LF
    6050   00:643C                          db  "ESC to return to main menu."   ,CR,LF
    6050   00:643C  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6050   00:644C  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 
    6051   00:6459                          db  "SPACE BAR to show next page."  ,CR,LF
    6051   00:6459  53 50 41 43 45 20 42 41 52 20 74 6F 20 73 68 6F 
    6051   00:6469  77 20 6E 65 78 74 20 70 61 67 65 2E 0D 0A 
    6052   00:6477                          db  "ENTER to type SSID/AP name."   ,CR,LF,LF
    6052   00:6477  45 4E 54 45 52 20 74 6F 20 74 79 70 65 20 53 53 
    6052   00:6487  49 44 2F 41 50 20 6E 61 6D 65 2E 0D 0A 0A 
    6053   00:6495                      ;---
    6054   00:6495                          db  "Number to connect: "       ,STTERMINATOR
    6054   00:6495  4E 75 6D 62 65 72 20 74 6F 20 63 6F 6E 6E 65 63 
    6054   00:64A5  74 3A 20 00 
    6055   00:64A9                      
    6056   00:64A9                      SCAN_TERMINATOR_CUT:
    6057   00:64A9                          db  GOLEFT,GOLEFT,1,91," ",GOLEFT,STTERMINATOR
    6057   00:64A9  1D 1D 01 5B 20 1D 00 
    6058   00:64B0                      
    6059   00:64B0                      SCAN_TERMINATOR_OPEN:
    6060   00:64B0                          db  " ",1,81,GOLEFT,CR,LF,STTERMINATOR
    6060   00:64B0  20 01 51 1D 0D 0A 00 
    6061   00:64B7                      
    6062   00:64B7                      SCAN_TERMINATOR_ENC:
    6063   00:64B7                          db  " ",1,82,GOLEFT,CR,LF,STTERMINATOR
    6063   00:64B7  20 01 52 1D 0D 0A 00 
    6064   00:64BE                      
    6065   00:64BE                      MMENU_TIMEOUT:
    6066   00:64BE  0C                      db  CLS
    6067   00:64BF                          db  "   [ Set Wi-Fi On Period ]"    ,CR,LF,LF
    6067   00:64BF  20 20 20 5B 20 53 65 74 20 57 69 2D 46 69 20 4F 
    6067   00:64CF  6E 20 50 65 72 69 6F 64 20 5D 0D 0A 0A 
    6068   00:64DC                      ;---
    6069   00:64DC                          db  "Wi-Fi On Period allows to set" ,GOLEFT,CR,LF
    6069   00:64DC  57 69 2D 46 69 20 4F 6E 20 50 65 72 69 6F 64 20 
    6069   00:64EC  61 6C 6C 6F 77 73 20 74 6F 20 73 65 74 1D 0D 0A 
    6070   00:64FC                          db  "a given period of time of"     ,CR,LF
    6070   00:64FC  61 20 67 69 76 65 6E 20 70 65 72 69 6F 64 20 6F 
    6070   00:650C  66 20 74 69 6D 65 20 6F 66 0D 0A 
    6071   00:6517                          db  "inactivity to turn off Wi-Fi"  ,CR,LF
    6071   00:6517  69 6E 61 63 74 69 76 69 74 79 20 74 6F 20 74 75 
    6071   00:6527  72 6E 20 6F 66 66 20 57 69 2D 46 69 0D 0A 
    6072   00:6535                          db  "automatically."                ,CR,LF,LF
    6072   00:6535  61 75 74 6F 6D 61 74 69 63 61 6C 6C 79 2E 0D 0A 
    6072   00:6545  0A 
    6073   00:6546                      ;---
    6074   00:6546                          db  "0         - Always on"         ,CR,LF
    6074   00:6546  30 20 20 20 20 20 20 20 20 20 2D 20 41 6C 77 61 
    6074   00:6556  79 73 20 6F 6E 0D 0A 
    6075   00:655D                          db  "1 to 30   - 30s"               ,CR,LF
    6075   00:655D  31 20 74 6F 20 33 30 20 20 20 2D 20 33 30 73 0D 
    6075   00:656D  0A 
    6076   00:656E                          db  "31 to 600 - Use given period"  ,CR,LF
    6076   00:656E  33 31 20 74 6F 20 36 30 30 20 2D 20 55 73 65 20 
    6076   00:657E  67 69 76 65 6E 20 70 65 72 69 6F 64 0D 0A 
    6077   00:658C                          db  "> 600     - 600s"              ,CR,LF,LF,STTERMINATOR
    6077   00:658C  3E 20 36 30 30 20 20 20 20 20 2D 20 36 30 30 73 
    6077   00:659C  0D 0A 0A 00 
    6078   00:65A0                      ;---
    6079   00:65A0                      
    6080   00:65A0                      MMENU_TIMEOUT_ALWAYSON:
    6081   00:65A0                          db  "Wi-Fi is currently: ALWAYS ON" ,GOLEFT,CR,LF,LF
    6081   00:65A0  57 69 2D 46 69 20 69 73 20 63 75 72 72 65 6E 74 
    6081   00:65B0  6C 79 3A 20 41 4C 57 41 59 53 20 4F 4E 1D 0D 0A 
    6081   00:65C0  0A 
    6082   00:65C1                      ;---
    6083   00:65C1                          db  "ESC to return to main menu."   ,CR,LF,LF
    6083   00:65C1  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6083   00:65D1  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    6084   00:65DF                      ;---
    6085   00:65DF                          db  "Type desired period: "         ,STTERMINATOR
    6085   00:65DF  54 79 70 65 20 64 65 73 69 72 65 64 20 70 65 72 
    6085   00:65EF  69 6F 64 3A 20 00 
    6086   00:65F5                      
    6087   00:65F5                      MMENU_TIMEOUT_NOTALWAYSON1:
    6088   00:65F5                          db  "Wi-Fi period set to: "         ,STTERMINATOR
    6088   00:65F5  57 69 2D 46 69 20 70 65 72 69 6F 64 20 73 65 74 
    6088   00:6605  20 74 6F 3A 20 00 
    6089   00:660B                      
    6090   00:660B                      MMENU_TIMEOUT_NOTALWAYSON2:
    6091   00:660B  73 0D 0A 0A             db  "s"                             ,CR,LF,LF
    6092   00:660F                      ;---
    6093   00:660F                          db  "ESC to return to main menu."   ,CR,LF,LF
    6093   00:660F  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6093   00:661F  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    6094   00:662D                      ;---
    6095   00:662D                          db  "Type desired period: "         ,STTERMINATOR
    6095   00:662D  54 79 70 65 20 64 65 73 69 72 65 64 20 70 65 72 
    6095   00:663D  69 6F 64 3A 20 00 
    6096   00:6643                      
    6097   00:6643                      MMENU_NAGLE:
    6098   00:6643  0C                      db  CLS
    6099   00:6644                          db  "   [ Set Nagle Algorithm ]"    ,CR,LF,LF
    6099   00:6644  20 20 20 5B 20 53 65 74 20 4E 61 67 6C 65 20 41 
    6099   00:6654  6C 67 6F 72 69 74 68 6D 20 5D 0D 0A 0A 
    6100   00:6661                      ;---
    6101   00:6661                          db  "Nagle Algorithm might lower"   ,CR,LF
    6101   00:6661  4E 61 67 6C 65 20 41 6C 67 6F 72 69 74 68 6D 20 
    6101   00:6671  6D 69 67 68 74 20 6C 6F 77 65 72 0D 0A 
    6102   00:667E                          db  "performance but create less"   ,CR,LF
    6102   00:667E  70 65 72 66 6F 72 6D 61 6E 63 65 20 62 75 74 20 
    6102   00:668E  63 72 65 61 74 65 20 6C 65 73 73 0D 0A 
    6103   00:669B                          db  "network congestion."           ,CR,LF
    6103   00:669B  6E 65 74 77 6F 72 6B 20 63 6F 6E 67 65 73 74 69 
    6103   00:66AB  6F 6E 2E 0D 0A 
    6104   00:66B0                          db  "Nowadays it is mostly not"     ,CR,LF
    6104   00:66B0  4E 6F 77 61 64 61 79 73 20 69 74 20 69 73 20 6D 
    6104   00:66C0  6F 73 74 6C 79 20 6E 6F 74 0D 0A 
    6105   00:66CB                          db  "needed and is the cause of"    ,CR,LF
    6105   00:66CB  6E 65 65 64 65 64 20 61 6E 64 20 69 73 20 74 68 
    6105   00:66DB  65 20 63 61 75 73 65 20 6F 66 0D 0A 
    6106   00:66E7                          db  "latency and low performance"   ,CR,LF
    6106   00:66E7  6C 61 74 65 6E 63 79 20 61 6E 64 20 6C 6F 77 20 
    6106   00:66F7  70 65 72 66 6F 72 6D 61 6E 63 65 0D 0A 
    6107   00:6704                          db  "on packet-driven protocols."   ,CR,LF,LF
    6107   00:6704  6F 6E 20 70 61 63 6B 65 74 2D 64 72 69 76 65 6E 
    6107   00:6714  20 70 72 6F 74 6F 63 6F 6C 73 2E 0D 0A 0A 
    6108   00:6722                      ;---
    6109   00:6722                          db  "O - Turn it on/off"            ,CR,LF,LF,STTERMINATOR
    6109   00:6722  4F 20 2D 20 54 75 72 6E 20 69 74 20 6F 6E 2F 6F 
    6109   00:6732  66 66 0D 0A 0A 00 
    6110   00:6738                      ;---
    6111   00:6738                      
    6112   00:6738                      MMENU_NAGLE_ON:
    6113   00:6738                          db  "Nagle is currently: ON"        ,CR,LF,LF
    6113   00:6738  4E 61 67 6C 65 20 69 73 20 63 75 72 72 65 6E 74 
    6113   00:6748  6C 79 3A 20 4F 4E 0D 0A 0A 
    6114   00:6751                      ;---
    6115   00:6751                          db  "ESC to return to main menu."   ,CR,LF,LF
    6115   00:6751  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6115   00:6761  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    6116   00:676F                      ;---
    6117   00:676F                          db  "Option: "                      ,STTERMINATOR
    6117   00:676F  4F 70 74 69 6F 6E 3A 20 00 
    6118   00:6778                      
    6119   00:6778                      MMENU_NAGLE_OFF:
    6120   00:6778                          db  "Nagle is currently: OFF"       ,CR,LF,LF
    6120   00:6778  4E 61 67 6C 65 20 69 73 20 63 75 72 72 65 6E 74 
    6120   00:6788  6C 79 3A 20 4F 46 46 0D 0A 0A 
    6121   00:6792                      ;---
    6122   00:6792                          db  "ESC to return to main menu."   ,CR,LF,LF
    6122   00:6792  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6122   00:67A2  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    6123   00:67B0                      ;---
    6124   00:67B0                          db  "Option: "                      ,STTERMINATOR
    6124   00:67B0  4F 70 74 69 6F 6E 3A 20 00 
    6125   00:67B9                      
    6126   00:67B9                      STR_SENDING:
    6127   00:67B9                          db  "Sending command, wait..."      ,CR,LF,STTERMINATOR
    6127   00:67B9  53 65 6E 64 69 6E 67 20 63 6F 6D 6D 61 6E 64 2C 
    6127   00:67C9  20 77 61 69 74 2E 2E 2E 0D 0A 00 
    6128   00:67D4                      
    6129   00:67D4                      STR_SENDING_OK:
    6130   00:67D4                          db  "Command sent Ok, done!"        ,CR,LF,STTERMINATOR
    6130   00:67D4  43 6F 6D 6D 61 6E 64 20 73 65 6E 74 20 4F 6B 2C 
    6130   00:67E4  20 64 6F 6E 65 21 0D 0A 00 
    6131   00:67ED                      
    6132   00:67ED                      STR_SENDING_OK_JN:
    6133   00:67ED                          db  CR,GORIGHT,GORIGHT,1,83,CR,LF,LF
    6133   00:67ED  0D 1C 1C 01 53 0D 0A 0A 
    6134   00:67F5                      ;---
    6135   00:67F5                          db  "Successfully connected!"       ,CR,LF,STTERMINATOR
    6135   00:67F5  53 75 63 63 65 73 73 66 75 6C 6C 79 20 63 6F 6E 
    6135   00:6805  6E 65 63 74 65 64 21 0D 0A 00 
    6136   00:680F                      
    6137   00:680F                      STR_SENDING_NOK_JN:
    6138   00:680F                          db  CR,GORIGHT,GORIGHT,1,84,CR,LF,LF
    6138   00:680F  0D 1C 1C 01 54 0D 0A 0A 
    6139   00:6817                      ;---
    6140   00:6817                          db  "Fail to connect, if protected" ,GOLEFT,CR,LF
    6140   00:6817  46 61 69 6C 20 74 6F 20 63 6F 6E 6E 65 63 74 2C 
    6140   00:6827  20 69 66 20 70 72 6F 74 65 63 74 65 64 1D 0D 0A 
    6141   00:6837                          db  "network check password!"       ,CR,LF,STTERMINATOR
    6141   00:6837  6E 65 74 77 6F 72 6B 20 63 68 65 63 6B 20 70 61 
    6141   00:6847  73 73 77 6F 72 64 21 0D 0A 00 
    6142   00:6851                      
    6143   00:6851                      STR_SENDING_FAIL:
    6144   00:6851                          db  "Command failure..."            ,CR,LF,STTERMINATOR
    6144   00:6851  43 6F 6D 6D 61 6E 64 20 66 61 69 6C 75 72 65 2E 
    6144   00:6861  2E 2E 0D 0A 00 
    6145   00:6866                      
    6146   00:6866                      STR_CLKUPDT_FAIL:
    6147   00:6866                          db  "Failure retrieving date and"   ,CR,LF
    6147   00:6866  46 61 69 6C 75 72 65 20 72 65 74 72 69 65 76 69 
    6147   00:6876  6E 67 20 64 61 74 65 20 61 6E 64 0D 0A 
    6148   00:6883                          db  "time from SNTP server!"        ,CR,LF,LF
    6148   00:6883  74 69 6D 65 20 66 72 6F 6D 20 53 4E 54 50 20 73 
    6148   00:6893  65 72 76 65 72 21 0D 0A 0A 
    6149   00:689C                      ;---
    6150   00:689C                          db  "Press and hold F1 during"      ,CR,LF
    6150   00:689C  50 72 65 73 73 20 61 6E 64 20 68 6F 6C 64 20 46 
    6150   00:68AC  31 20 64 75 72 69 6E 67 0D 0A 
    6151   00:68B6                          db  "system boot to enter setup."   ,CR,LF,STTERMINATOR
    6151   00:68B6  73 79 73 74 65 6D 20 62 6F 6F 74 20 74 6F 20 65 
    6151   00:68C6  6E 74 65 72 20 73 65 74 75 70 2E 0D 0A 00 
    6152   00:68D4                      
    6153   00:68D4                      OK_S:
    6154   00:68D4                          db  "Installed successfully!"       ,CR,LF,LF,STTERMINATOR
    6154   00:68D4  49 6E 73 74 61 6C 6C 65 64 20 73 75 63 63 65 73 
    6154   00:68E4  73 66 75 6C 6C 79 21 0D 0A 0A 00 
    6155   00:68EF                      ;---
    6156   00:68EF                      
    6157   00:68EF                      FAIL_S:
    6158   00:68EF  0C                      db  CLS
    6159   00:68F0                          db  "ESP8266 Not Found!"            ,CR,LF,LF
    6159   00:68F0  45 53 50 38 32 36 36 20 4E 6F 74 20 46 6F 75 6E 
    6159   00:6900  64 21 0D 0A 0A 
    6160   00:6905                      ;---
    6161   00:6905                          db  "Check that it is properly"     ,CR,LF
    6161   00:6905  43 68 65 63 6B 20 74 68 61 74 20 69 74 20 69 73 
    6161   00:6915  20 70 72 6F 70 65 72 6C 79 0D 0A 
    6162   00:6920                          db  "inserted in its connector."    ,CR,LF,STTERMINATOR
    6162   00:6920  69 6E 73 65 72 74 65 64 20 69 6E 20 69 74 73 20 
    6162   00:6930  63 6F 6E 6E 65 63 74 6F 72 2E 0D 0A 00 
    6163   00:693D                      
    6164   00:693D                      FAIL_F:
    6165   00:693D  0C                      db  CLS
    6166   00:693E                          db  "ESP8266 FW Update Required!"   ,CR,LF,STTERMINATOR
    6166   00:693E  45 53 50 38 32 36 36 20 46 57 20 55 70 64 61 74 
    6166   00:694E  65 20 52 65 71 75 69 72 65 64 21 0D 0A 00 
    6167   00:695C                      
    6168   00:695C                      STR_WAITING:
    6169   00:695C  0B                      db  HOME
    6170   00:695D                          db  "Waiting for connection..."     ,GOLEFT,CR,LF,LF,LF,STTERMINATOR
    6170   00:695D  57 61 69 74 69 6E 67 20 66 6F 72 20 63 6F 6E 6E 
    6170   00:696D  65 63 74 69 6F 6E 2E 2E 2E 1D 0D 0A 0A 0A 00 
    6171   00:697C                      ;---
    6172   00:697C                      ;---
    6173   00:697C                      
    6174   00:697C                      STR_OOPS:
    6175   00:697C  0C                      db  CLS
    6176   00:697D                          db  "Oops! An unexpected error"     ,CR,LF
    6176   00:697D  4F 6F 70 73 21 20 41 6E 20 75 6E 65 78 70 65 63 
    6176   00:698D  74 65 64 20 65 72 72 6F 72 0D 0A 
    6177   00:6998                          db  "occurred on the last reboot."  ,CR,LF,STTERMINATOR
    6177   00:6998  6F 63 63 75 72 72 65 64 20 6F 6E 20 74 68 65 20 
    6177   00:69A8  6C 61 73 74 20 72 65 62 6F 6F 74 2E 0D 0A 00 
    6178   00:69B7                      
    6179   00:69B7                      ;============================
    6180   00:69B7                      ;===  UNAPI related data  ===
    6181   00:69B7                      ;============================
    6182   00:69B7                      
    6183   00:69B7                      ;--- Specification identifier (up to 15 chars)
    6184   00:69B7                      
    6185   00:69B7                      UNAPI_ID:               db  "TCP/IP",0
    6185   00:69B7  54 43 50 2F 49 50 00 
    6186   00:69BE                      UNAPI_ID_END:
    6187   00:69BE                      
    6188   00:69BE                      ;--- Implementation name (up to 63 chars and zero terminated)
    6189   00:69BE                      
    6190   00:69BE                      APIINFO:                db  "MSXPICO Wi-Fi UNAPI",0
    6190   00:69BE  4D 53 58 50 49 43 4F 20 57 69 2D 46 69 20 55 4E 
    6190   00:69CE  41 50 49 00 
    6191   00:69D2                      
    6192   00:69D2  C9 (5646)           ID_END: ds  #7FE0-ID_END,#C9
    6193   00:7FE0                      ;--- FS-A1GT compliant BIOS without logo (not for FS-A1ST BIOS)
    6194   00:7FE0                      BUILD_NAME:             db  "[ ESP8266P.ROM ]"
    6194   00:7FE0  5B 20 45 53 50 38 32 36 36 50 2E 52 4F 4D 20 5D 
    6195   00:7FF0                      ;--- Build date to be viewed via Hex Editor (16 bytes)
    6196   00:7FF0                      
    6197   00:7FF0                      BUILD_DATE:             db  "BUILD 2024/09/10"
    6197   00:7FF0  42 55 49 4C 44 20 32 30 32 34 2F 30 39 2F 31 30 
    6198   00:8000                      
    6199   00:8000                      SEG_CODE_END:
    6200   00:8000                      ; Final size must be 16384 bytes

    LABELS
-------------------------------------------------
00:00000000 X NON_VERBOSE_ROM
00:00000001 X USE_MEM_IO
00:0000005F   CHGMOD
00:0000009C   CHSNS
00:0000009F   CHGET
00:000000A2   CHPUT
00:000000C0   BEEP
00:00000141   SNSMAT
00:00000156   KILBUF
00:0000F3B0   LINLEN
00:0000F3DB   CLIKSW
00:0000F3E1   REG2SAV
00:0000F3E3   REG4SAV
00:0000F676   TXTTAB
00:0000F847   ARG
00:0000FB20   HOKVLD
00:0000FC4A   HIMEM
00:0000FCA9   CSRSW
00:0000FCC1   EXPTBL
00:0000FD09   SLTWRK
00:0000FD9F   H_TIMI
00:0000FED0 X H_CLEA
00:0000FFCA   EXTBIO
00:00007F06   MEM_OUT_CMD_PORT
00:00007F07   MEM_OUT_TX_PORT
00:00007F06   MEM_IN_DATA_PORT
00:00007F07   MEM_IN_STS_PORT
00:00007F05   MEM_PORT_F2
00:00000006 X OUT_CMD_PORT
00:00000007 X OUT_TX_PORT
00:00000006 X IN_DATA_PORT
00:00000007 X IN_STS_PORT
00:000000F2 X PORT_F2
00:00000001   API_V_P
00:00000002   API_V_S
00:00000001   ROM_V_P
00:00000003   ROM_V_S
00:0000001E   HIMEM_RESERVED_SIZE
00:00000000 X H_TIM_BACKUP_OFFSET
00:00000005   MEMORY_COUNTER_OFFSET
00:00000007   MEMORY_SB_VAR_OFFSET
00:00000008   MEMORY_DNS_READY_OFFSET
00:00000009   MEMORY_DNS_RES_OFFSET
00:0000000B   MEMORY_DB_VAR_OFFSET
00:0000000D   MEMORY_REGBACKUP_OFFSET
00:0000000D   MEMORY_BCBACKUP_OFFSET
00:0000000F X MEMORY_DEBACKUP_OFFSET
00:00000011   MEMORY_HLBACKUP_OFFSET
00:00000008   SCAN_MAX_PAGE_SIZE
00:0000001D   MAX_FN
00:00000000 X MAX_IMPFN
00:00000000 X ERR_OK
00:00000001   ERR_NOT_IMP
00:00000002 X ERR_NO_NETWORK
00:00000003 X ERR_NO_DATA
00:00000004   ERR_INV_PARAM
00:00000005 X ERR_QUERY_EXISTS
00:00000006 X ERR_INV_IP
00:00000007 X ERR_NO_DNS
00:00000008   ERR_DNS
00:00000009 X ERR_NO_FREE_CONN
00:0000000A X ERR_CONN_EXISTS
00:0000000B   ERR_NO_CONN
00:0000000C X ERR_CONN_STATE
00:0000000D X ERR_BUFFER
00:0000000E X ERR_LARGE_DGRAM
00:0000000F   ERR_INV_OPER
00:00000000 X UNAPI_TCPIP_NS_CLOSED
00:00000001 X UNAPI_TCPIP_NS_OPENING
00:00000002 X UNAPI_TCPIP_NS_OPEN
00:000000FF X UNAPI_TCPIP_NS_UNKNOWN
00:00004010   INIT
00:00004032   SCREEN_SETUP
00:00004038   IS_SCREEN1
00:00004061   NOT_DISABLED_BY_F2
00:00004078   F2_IS_NOT_F0
00:0000408E   WAIT_2S
00:00004096   BOOT_FROM_POWER_OFF
00:000040B5   BOOT_FROM_POWER_OFF.1
00:000040BB   BOOT_FROM_POWER_OFF.2
00:000040C5   F2_IS_PRESSED
00:000040D1   ESP_NOT_FOUND
00:000040DB   INIT_F_MSG
00:000040DE X INIT_F_WAIT
00:000040E0   INIT_F_LOOP_WAIT
00:000040E3 X AND_DONE
00:000040E9   INIT_UNAPI
00:00004116   INIT_UNAPI2
00:00004132   TRY_AGAIN
00:0000414B   STOP_TRYING
00:00004153   WAIT_4S
00:00004159   INIT_CLOCKUPDATE
00:00004198   INIT_NOCLOCKUPDATE
00:000041A2   INIT_NOCLOCKUPDAT2
00:000041B4   SAVE_HOOK2
00:000041C7   PATCH
00:000041DD   PATCH2
00:000041E7 X INIT_OK
00:000041F3   HIMEM_ALLOC
00:00004213 X PATCH_H_TIMI
00:00004230   ESPSETUP.EXIT
00:00004238   ENTERING_ESPSETUP
00:00004254   ESPSETUP
00:00004270   ESPSETUP.2NF
00:00004276   ESPSETUP.3NF
00:0000427C   ESPSETUP_NEXT
00:000042BA   ESPSETUP_NEXT.2F
00:000042C6   ESPSETUP_NEXT.1G
00:000042CC   MM_CURSOR_BLINK
00:000042CF   CONN_CHG_LOOP
00:000042E7   MM_WAIT_INPUT
00:0000430D   MM_CURSOR_SW
00:00004321   GET_AP_STAT
00:00004339   CLK_MSX1_GO
00:00004351   CLK_MSX1_ADAPTERDIS
00:00004357   CLK_MSX1_OPT
00:0000435D   CLK_MSX1_WAIT_OPT_INPUT
00:00004375   CLK_MSX1_SEND_CMD
00:0000438A   START_CLK_AUTO
00:00004399 X CLK_AUTO_GO
00:000043B0   CLK_AUTO_CHK1
00:000043BB   CLK_AUTO_CHK2
00:000043C6   CLK_AUTO_3
00:000043CE   CLK_AUTO_GMT
00:000043E3   CLK_AUTO_GMTP
00:000043E8   CLK_AUTO_GMTM
00:000043FE   CLK_AUTO_GMTD
00:00004409   CLK_AUTO_GMT_OPT
00:0000440F   CLK_AUTO_WAIT_OPT_INPUT
00:00004431   CLK_AUTO_WAIT_GMT
00:00004450   CLK_AUTO_WAIT_GMT_INPUT
00:00004474   CLK_AUTO_GMT_CHK_BS
00:0000447F   CLK_AUTO_GMT_CHK_BS_MIN
00:00004483   CLK_AUTO_GMT_CHK_DIGIT
00:00004495   CLK_AUTO_GMT_BAD_INPUT
00:000044A3   CLK_AUTO_GMT_CHK_INPUT
00:000044B9   CLK_AUTO_GMT_CHK_CR
00:000044CC   CLK_AUTO_GMT_CHK_CD
00:000044E5   CLK_AUTO_SKIP_SIGN
00:000044EA   CLK_AUTO_GMT_CHK_CD.1
00:000044F3   CLK_AUTO_GMT_CHK_CSD
00:0000450B   CLK_AUTO_GMT_CHK_CSD1
00:0000451C   CLK_AUTO_GMT_CHK_CSD2
00:00004528   CLK_AUTO_GMT_CHK_DONE
00:00004568   CLK_AUTO_GMT_CHK_RESULT
00:0000456E   START_WIFI_SCAN
00:00004576   START_WIFI_RESCAN
00:0000458A   WIFI_SCAN_WAIT_END
00:000045A5   WIFI_SCAN_WAITHS
00:000045B2   WIFI_SCAN_SHOW_LIST
00:000045BE   WIFI_LIST_LOOP
00:000045D5   PRT_APNAMELP
00:000045E8   PRT_APNAMELP_CUT
00:000045F1   PRT_APENC
00:00004602   PRT_APNOTENC
00:0000460A   PRT_AP_CHKLOOP
00:0000461A   APLIST_OVERFLOW
00:0000462A   APLIST_NO_OVERFLOW
00:0000462D   APLIST_NOFLW
00:00004634   WIFI_SELECT_AP
00:00004652   WIFI_SELECT_SPACEBAR
00:0000465F   WIFI_CONNECT_ME_CHOOSEN
00:0000466A   WIFI_CONNECT_MANUAL_ENTRY
00:0000468B   WIFI_CONNECT_ME_CHKPRT2
00:00004691   WIFI_CONNECT_ME_CHKPRTD
00:00004697   WIFI_CONNECT_ME_0_TERM
00:000046B3   WIFI_CONNECT_ME_PWD_Y
00:000046BA   WIFI_CONNECT_ME_PWD
00:000046CB   WIFI_CONNECT_ME_BS
00:000046E2   WIFI_ME_CHECK_INPUT
00:000046E9   WIFI_CONNECT_SELECTION_OK
00:000046FD X WIFI_CONNECT_AP_SRCH
00:000046FF   WIFI_CONNECT_AP_SRCH.1
00:0000470D   WIFI_CONNECT_AP_PWDQ
00:00004712   WIFI_CONNECT_APSIZE
00:0000472D   WIFI_CONNECT_RCV_PWD
00:00004744   WIFI_CONNECT_RCV_PWD_STR
00:0000475F   WIFI_CONNECT_RCV_PWD_CHAR
00:00004768   WIFI_CONNECT_RCV_CHKPRT2
00:0000476E   WIFI_CONNECT_RCV_CHKPRTD
00:00004774   WIFI_CONNECT_RCV_PWDH
00:00004788   WIFI_CONNECT_RCV_PWD_BS
00:000047A5   WIFI_PWD_CHECK_INPUT
00:000047AC   WIFI_CONNECT_SENDCMD
00:000047CE   WIFI_CONNECT_SENDCMDLP
00:000047ED   WIFI_CONNECT_FAIL
00:000047F6   INPUT_WFSAP_BAD_INPUT
00:0000480C   WIFI_SCAN_NONETWORKS
00:00004815   WIFI_SCAN_TIMEOUT
00:0000481E   SET_WIFI_TIMEOUT
00:00004847   WIFI_SET_ALWAYS_ON
00:00004857   INPUT_TIMEOUT
00:00004885   INPUT_TIMEOUT_BAD_INPUT
00:0000488B   SET_WIFI_BS_INPUT
00:000048A5   SET_WIFI_CHECK_INPUT
00:000048E1   SET_WIFI_EXECUTE_SET_COMMAND
00:000048E4   SET_NAGLE
00:000048FD   SET_NAGLE_WI_ON
00:00004915   NAGLE_IS_ON
00:0000491B   SET_NAGLE_WI_OFF
00:00004933   SET_ESP_WIFI_TIMEOUT
00:00004973   SET_NAGLE_OFF
00:000049A4   STARTWIFISCAN
00:000049C2   SET_NAGLE_ON
00:000049F3   WAIT_4S_AND_THEN_MAINMENU
00:000049F7   WAIT_2S_AND_THEN_MAINMENU
00:000049F9   WAIT_AND_THEN_MAINMENU
00:000049FF   WAIT_250MS_AND_THEN_CONTINUE
00:00004A01   WAIT_BEFORE_CONTINUING
00:00004A06   ISCLKAUTO
00:00004A22   CHECKNAGLE
00:00004A57   CHECK_NAGLE_OFF
00:00004A70   CHECKTIMEOUT
00:00004AA2   CHECKTIMEOUT.1
00:00004AB3   CHECKTIMEOUT.2
00:00004AD9   CHECKTIMEOUT.3
00:00004B12   CHECKTIMEOUT.END
00:00004B16   MENU_SUB_BAD_END_1S
00:00004B17   MENU_SUB_BAD_END
00:00004B18   MENU_BAD_END
00:00004B21   WAIT_MENU_QCMD_RESPONSE
00:00004B23   WAIT_MENU_QCMD_RESPONSE_ST1
00:00004B37   WAIT_MENU_QCMD_RESPONSE_ST1.1
00:00004B3D   WAIT_MENU_QCMD_RESPONSE_RC
00:00004B4C   WAIT_MENU_QCMD_RESPONSE_RC.1
00:00004B53 X WAIT_MENU_QCMD_RESPONSE_END_OK
00:00004B56   WAIT_MENU_QCMD_RESPONSE_END
00:00004B58   WAIT_MENU_QCMD_RESPONSE_END_NOK
00:00004B5E   WAIT_MENU_CMD_RESPONSE
00:00004B62   WAIT_MENU_CMD_RESPONSE_ST1
00:00004B76   WAIT_MENU_CMD_RESPONSE_ST1.1
00:00004B7C   WAIT_MENU_CMD_RESPONSE_RC
00:00004B8B   WAIT_MENU_CMD_RESPONSE_RC.1
00:00004B92   WAIT_MENU_CMD_RESPONSE_ST2A
00:00004BA1   WAIT_MENU_CMD_RESPONSE_ST2A.1
00:00004BA5   WAIT_MENU_CMD_RESPONSE_ST2B
00:00004BB4   WAIT_MENU_CMD_RESPONSE_ST2B.1
00:00004BBD   WAIT_MENU_CMD_RESPONSE_GET_DATA
00:00004BCC   WAIT_MENU_CMD_RESPONSE_GET_DATA.1
00:00004BD9   WAIT_MENU_CMD_RESPONSE_END_OK
00:00004BE0   WAIT_MENU_CMD_RESPONSE_END
00:00004BE6   WAIT_MENU_CMD_RESPONSE_END_NOK
00:00004BEF   WAIT_MENU_SCMD_RESPONSE
00:00004BF3   WAIT_MENU_SCMD_RESPONSE_ST1
00:00004C07   WAIT_MENU_SCMD_RESPONSE_ST1.1
00:00004C0D   WAIT_MENU_SCMD_RESPONSE_RC
00:00004C1C   WAIT_MENU_SCMD_RESPONSE_RC.1
00:00004C23   WAIT_MENU_SCMD_RESPONSE_ST2A
00:00004C32   WAIT_MENU_SCMD_RESPONSE_ST2A.1
00:00004C37   WAIT_MENU_SCMD_RESPONSE_ST2B
00:00004C46   WAIT_MENU_SCMD_RESPONSE_ST2B.1
00:00004C51   WAIT_MENU_SCMD_RESPONSE_GET_ENC
00:00004C60   WAIT_MENU_SCMD_RESPONSE_GET_ENC.1
00:00004C6F X WAIT_MENU_SCMD_RESPONSE_END_OK
00:00004C73   WAIT_MENU_SCMD_RESPONSE_END
00:00004C77   WAIT_MENU_SCMD_RESPONSE_END_NOK
00:00004C80   HLTIMEOUT
00:00004C86   PRINTHL
00:00004C90   PRINTHLINE
00:00004C93   PHLINEL
00:00004CB6   PHLINESPC
00:00004CBD   PHLINELR
00:00004CC7   DO_HTIMI
00:00004CD3   DO_HTIMI_END
00:00004CDB   DO_EXTBIO
00:00004CEC   LOOP
00:00004D0E   DO_EXTBIO2
00:00004D1E   DO_EXTBIO3
00:00004D23   JUMP_OLD2
00:00004D26   JUMP_OLD
00:00004D32   UNAPI_ENTRY
00:00004D42   OK_FNUM
00:00004D50   UNDEFINED
00:00004D53   FN_TABLE
00:00004D53 X FN_0
00:00004D55 X FN_1
00:00004D57 X FN_2
00:00004D59 X FN_3
00:00004D5B X FN_4
00:00004D5D X FN_5
00:00004D5F X FN_6
00:00004D61 X FN_7
00:00004D63 X FN_8
00:00004D65 X FN_9
00:00004D67 X FN_10
00:00004D69 X FN_11
00:00004D6B X FN_12
00:00004D6D X FN_13
00:00004D6F X FN_14
00:00004D71 X FN_15
00:00004D73 X FN_16
00:00004D75 X FN_17
00:00004D77 X FN_18
00:00004D79 X FN_19
00:00004D7B X FN_20
00:00004D7D X FN_21
00:00004D7F X FN_22
00:00004D81 X FN_23
00:00004D83 X FN_24
00:00004D85 X FN_25
00:00004D87 X FN_26
00:00004D89 X FN_27
00:00004D8B X FN_28
00:00004D8D X FN_29
00:00004D8F   FN_NOT_IMP
00:00004D92   END_OK
00:00004D94   TCPIP_GENERIC_CHECK_TIME_OUT
00:00004DA4   UNAPI_GET_INFO
00:00004DAF   TCPIP_GET_CAPAB
00:00004DC7   TCPIP_GET_CAPAB_ST1
00:00004DD3   TCPIP_GET_CAPAB_ST1.1
00:00004DDA   TCPIP_GET_CAPAB_RC
00:00004DE6   TCPIP_GET_CAPAB_RC.1
00:00004DED   TCPIP_GET_CAPAB_ST2
00:00004DF9   TCPIP_GET_CAPAB_ST2.1
00:00004E11   TCPIP_GET_CAPAB_BLK3
00:00004E11   TCPIP_GET_CAPAB_BLK3_ST1
00:00004E1D   TCPIP_GET_CAPAB_BLK3_ST1.1
00:00004E21   TCPIP_GET_CAPAB_BLK3_ST2
00:00004E2D   TCPIP_GET_CAPAB_BLK3_ST2.1
00:00004E31   TCPIP_GET_CAPAB_BLK3_ST3
00:00004E3D   TCPIP_GET_CAPAB_BLK3_ST3.1
00:00004E41   TCPIP_GET_CAPAB_BLK3_ST4
00:00004E4D   TCPIP_GET_CAPAB_BLK3_ST4.1
00:00004E53   TCPIP_GET_CAPAB_BLK2
00:00004E53   TCPIP_GET_CAPAB_BLK2_ST1
00:00004E5F   TCPIP_GET_CAPAB_BLK2_ST1.1
00:00004E63   TCPIP_GET_CAPAB_BLK2_ST2
00:00004E6F   TCPIP_GET_CAPAB_BLK2_ST2.1
00:00004E73   TCPIP_GET_CAPAB_BLK2_ST3
00:00004E7F   TCPIP_GET_CAPAB_BLK2_ST3.1
00:00004E83   TCPIP_GET_CAPAB_BLK2_ST4
00:00004E8F   TCPIP_GET_CAPAB_BLK2_ST4.1
00:00004E93   TCPIP_GET_CAPAB_BLK2_ST5
00:00004E9F   TCPIP_GET_CAPAB_BLK2_ST5.1
00:00004EA3   TCPIP_GET_CAPAB_BLK2_ST6
00:00004EAF   TCPIP_GET_CAPAB_BLK2_ST6.1
00:00004EB5   TCPIP_GET_CAPAB_BLK1
00:00004EB5   TCPIP_GET_CAPAB_BLK1_ST1
00:00004EC1   TCPIP_GET_CAPAB_BLK1_ST1.1
00:00004EC5   TCPIP_GET_CAPAB_BLK1_ST2
00:00004ED1   TCPIP_GET_CAPAB_BLK1_ST2.1
00:00004ED5   TCPIP_GET_CAPAB_BLK1_ST3
00:00004EE1   TCPIP_GET_CAPAB_BLK1_ST3.1
00:00004EE5   TCPIP_GET_CAPAB_BLK1_ST4
00:00004EF1   TCPIP_GET_CAPAB_BLK1_ST4.1
00:00004EF5   TCPIP_GET_CAPAB_BLK1_ST5
00:00004F01   TCPIP_GET_CAPAB_BLK1_ST5.1
00:00004F07   TCPIP_GET_IPINFO
00:00004F1C   TCPIP_GET_IPINFO_ST1
00:00004F28   TCPIP_GET_IPINFO_ST1.1
00:00004F2F   TCPIP_GET_IPINFO_RC
00:00004F3B   TCPIP_GET_IPINFO_RC.1
00:00004F42   TCPIP_GET_IPINFO_ST2
00:00004F4E   TCPIP_GET_IPINFO_ST2.1
00:00004F54   TCPIP_GET_IPINFO_IP_ST1
00:00004F60   TCPIP_GET_IPINFO_IP_ST1.1
00:00004F64   TCPIP_GET_IPINFO_IP_ST2
00:00004F70   TCPIP_GET_IPINFO_IP_ST2.1
00:00004F74   TCPIP_GET_IPINFO_IP_ST3
00:00004F80   TCPIP_GET_IPINFO_IP_ST3.1
00:00004F84   TCPIP_GET_IPINFO_IP_ST4
00:00004F90   TCPIP_GET_IPINFO_IP_ST4.1
00:00004F96   TCPIP_NET_STATE
00:00004FA6   TCPIP_NET_STATE_ST1
00:00004FB2   TCPIP_NET_STATE_ST1.1
00:00004FB9   TCPIP_NET_STATE_RC
00:00004FC5   TCPIP_NET_STATE_RC.1
00:00004FCC   TCPIP_NET_STATE_ST2
00:00004FD8   TCPIP_NET_STATE_ST2.1
00:00004FDE   TCPIP_NET_STATE_NS_ST1
00:00004FEA   TCPIP_NET_STATE_NS_ST1.1
00:00004FF0   TCPIP_DNS_Q
00:00004FF4   TCPIP_DNS_Q_SIZE_LOOP
00:00004FFD   TCPIP_DNS_Q_SEND
00:0000501A   TCPIP_DNS_Q_SENDLP
00:00005025   TCPIP_DNS_Q_WAIT_RSP
00:0000502B   TCPIP_DNSQ_SEND_ST1
00:00005037   TCPIP_DNSQ_SEND_ST1.1
00:0000503E   TCPIP_DNSQ_SEND_RC
00:0000504A   TCPIP_DNSQ_SEND_RC.1
00:00005053   TCPIP_DNSQ_SEND_RC_ST2
00:0000505F   TCPIP_DNSQ_SEND_RC_ST2.1
00:00005065   TCPIP_DNSQ_IP_ST1
00:00005071   TCPIP_DNSQ_IP_ST1.1
00:00005075   TCPIP_DNSQ_IP_ST2
00:00005081   TCPIP_DNSQ_IP_ST2.1
00:00005085   TCPIP_DNSQ_IP_ST3
00:00005091   TCPIP_DNSQ_IP_ST3.1
00:00005095   TCPIP_DNSQ_IP_ST4
00:000050A1   TCPIP_DNSQ_IP_ST4.1
00:000050B1   TCPIP_DNS_S
00:000050C7   TCP_IP_DNS_S_NOCLR
00:000050CC   TCPIP_DNS_S_HASRESULT
00:000050D7   TCP_IP_DNS_S_RES_NOCLR
00:000050DA   TCPIP_DNS_S_NORESULT
00:000050DE   TCPIP_UDP_OPEN
00:000050FC   TCPIP_UDP_OPEN_ST1
00:00005108   TCPIP_UDP_OPEN_ST1.1
00:0000510F   TCPIP_UDP_OPEN_RC
00:0000511B   TCPIP_UDP_OPEN_RC.1
00:00005122   TCPIP_UDP_OPEN_ST2
00:0000512E   TCPIP_UDP_OPEN_ST2.1
00:00005134   TCPIP_UDP_OPEN_CONN_ST1
00:00005140   TCPIP_UDP_OPEN_CONN_ST1.1
00:00005146   TCPIP_UDP_CLOSE
00:0000515C   TCPIP_UDP_CLOSE_ST1
00:00005168   TCPIP_UDP_CLOSE_ST1.1
00:0000516F   TCPIP_UDP_CLOSE_RC
00:0000517B   TCPIP_UDP_CLOSE_RC.1
00:00005182   TCPIP_UDP_CLOSE_ST2
00:0000518E   TCPIP_UDP_CLOSE_ST2.1
00:00005196   TCPIP_UDP_STATE
00:000051AB   TCPIP_UDP_STATE_ST1
00:000051B7   TCPIP_UDP_STATE_ST1.1
00:000051BE   TCPIP_UDP_STATE_RC
00:000051CA   TCPIP_UDP_STATE_RC.1
00:000051D1   TCPIP_UDP_STATE_ST2
00:000051DD   TCPIP_UDP_STATE_ST2.1
00:000051E3   TCPIP_UDP_STATE_RESP_ST1
00:000051EF   TCPIP_UDP_STATE_RESP_ST1.1
00:000051F3   TCPIP_UDP_STATE_RESP_ST2
00:000051FF   TCPIP_UDP_STATE_RESP_ST2.1
00:00005203   TCPIP_UDP_STATE_RESP_ST3
00:0000520F   TCPIP_UDP_STATE_RESP_ST3.1
00:00005213   TCPIP_UDP_STATE_RESP_ST4
00:0000521F   TCPIP_UDP_STATE_RESP_ST4.1
00:00005223   TCPIP_UDP_STATE_RESP_ST5
00:0000522F   TCPIP_UDP_STATE_RESP_ST5.1
00:00005235   TCPIP_UDP_SEND
00:0000527C   TCPIP_UDP_SEND_R
00:0000528C   TCPIP_UDP_SEND_ST1
00:00005298   TCPIP_UDP_SEND_ST1.1
00:0000529F   TCPIP_UDP_SEND_RC
00:000052AB   TCPIP_UDP_SEND_RC.1
00:000052B2   TCPIP_UDP_SEND_ST2
00:000052BE   TCPIP_UDP_SEND_ST2.1
00:000052C6   TCPIP_UDP_RCV_CHECK_TIME_OUT
00:000052D3   TCPIP_TCP_UDP_RETRY_QRCV
00:000052E5   TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY
00:000052E8   TCPIP_UDP_RCV
00:0000530A   TCPIP_UDP_RCV.RXRETRY
00:00005310   TCPIP_UDP_RCV_ST1
00:0000531C   TCPIP_UDP_RCV_ST1.1
00:0000532B   TCPIP_UDP_RCV_RC
00:00005337   TCPIP_UDP_RCV_RC.1
00:0000533C   TCPIP_UDP_RCV_ST2A
00:00005348   TCPIP_UDP_RCV_ST2A.1
00:0000534C   TCPIP_UDP_RCV_ST2B
00:00005358   TCPIP_UDP_RCV_ST2B.1
00:00005364   TCPIP_UDP_RCV_IP_ST1
00:00005370   TCPIP_UDP_RCV_IP_ST1.1
00:00005374   TCPIP_UDP_RCV_IP_ST2
00:00005380   TCPIP_UDP_RCV_IP_ST2.1
00:00005384   TCPIP_UDP_RCV_IP_ST3
00:00005390   TCPIP_UDP_RCV_IP_ST3.1
00:00005394   TCPIP_UDP_RCV_IP_ST4
00:000053A0   TCPIP_UDP_RCV_IP_ST4.1
00:000053A4   TCPIP_UDP_RCV_PORT_ST1
00:000053B0   TCPIP_UDP_RCV_PORT_ST1.1
00:000053B5   TCPIP_UDP_RCV_PORT_ST2
00:000053C1   TCPIP_UDP_RCV_PORT_ST2.1
00:000053D8   TCPIP_UDP_RCV_R
00:000053EF   TCPIP_UDP_RCV_R_NSF
00:000053FB   TCPIP_UDP_RCV_R_NSF.1
00:0000540B   TCPIP_TCP_OPEN_ERROR
00:0000540E   TCPIP_TCP_OPEN_ERROR2
00:0000541A   TCPIP_TCP_OPEN_ERROR2.1
00:00005425   TCPIP_TCP_OPEN_ERROR3
00:00005431   TCPIP_TCP_OPEN_ERROR3.1
00:00005435   TCPIP_TCP_OPEN_ERROR4
00:00005439   TCPIP_TCP_OPEN
00:00005465   TCPIP_TCP_OPEN_CHECK_HOSTOF
00:0000546C X TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME
00:0000547C   TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME_LOOP_PARAM
00:0000548F   TCPIP_TCP_OPEN_SENDHOSTNAME
00:0000549C   TCPIP_TCP_OPEN_NO_TLS
00:0000549C   TCPIP_TCP_OPEN_NO_CHECKHOST
00:000054B2   TCPIP_TCP_OPEN_R
00:000054BC   TCPIP_TCP_OPEN_WAIT_RESPONSE
00:000054C2   TCPIP_TCP_OPEN_ST1
00:000054CE   TCPIP_TCP_OPEN_ST1.1
00:000054D5   TCPIP_TCP_OPEN_RC
00:000054E1   TCPIP_TCP_OPEN_RC.1
00:000054EA   TCPIP_TCP_OPEN_ST2
00:000054F6   TCPIP_TCP_OPEN_ST2.1
00:000054FC   TCPIP_TCP_OPEN_CONN_ST1
00:00005508   TCPIP_TCP_OPEN_CONN_ST1.1
00:0000550E   TCPIP_TCP_CLOSE
00:00005524   TCPIP_TCP_CLOSE_ST1
00:00005530   TCPIP_TCP_CLOSE_ST1.1
00:00005537   TCPIP_TCP_CLOSE_RC
00:00005543   TCPIP_TCP_CLOSE_RC.1
00:0000554A   TCPIP_TCP_CLOSE_ST2
00:00005556   TCPIP_TCP_CLOSE_ST2.1
00:0000555E   TCPIP_TCP_ABORT
00:00005574   TCPIP_TCP_ABORT_ST1
00:00005580   TCPIP_TCP_ABORT_ST1.1
00:00005587   TCPIP_TCP_ABORT_RC
00:00005593   TCPIP_TCP_ABORT_RC.1
00:0000559A   TCPIP_TCP_ABORT_ST2
00:000055A6   TCPIP_TCP_ABORT_ST2.1
00:000055AE   TCPIP_TCP_STATE_ERROR
00:000055B1   TCPIP_TCP_STATE_ERROR2
00:000055BD   TCPIP_TCP_STATE_ERROR2.1
00:000055D3   TCPIP_TCP_STATE
00:000055DD   TCPIP_TCP_STATE_NOINFOBLOCK
00:000055F7   TCPIP_TCP_STATE_ST1
00:00005603   TCPIP_TCP_STATE_ST1.1
00:0000560A   TCPIP_TCP_STATE_RC
00:00005616   TCPIP_TCP_STATE_RC.1
00:0000561E   TCPIP_TCP_STATE_ST2
00:0000562A   TCPIP_TCP_STATE_ST2.1
00:00005630   TCPIP_TCP_STATE_RESP_ST1
00:0000563C   TCPIP_TCP_STATE_RESP_ST1.1
00:00005640   TCPIP_TCP_STATE_RESP_ST2
00:0000564C   TCPIP_TCP_STATE_RESP_ST2.1
00:00005650   TCPIP_TCP_STATE_RESP_ST3
00:0000565C   TCPIP_TCP_STATE_RESP_ST3.1
00:00005660   TCPIP_TCP_STATE_RESP_ST4
00:0000566C   TCPIP_TCP_STATE_RESP_ST4.1
00:00005670   TCPIP_TCP_STATE_RESP_ST5
00:0000567C   TCPIP_TCP_STATE_RESP_ST5.1
00:00005680   TCPIP_TCP_STATE_RESP_ST6
00:0000568C   TCPIP_TCP_STATE_RESP_ST6.1
00:00005690   TCPIP_TCP_STATE_RESP_ST7
00:0000569C   TCPIP_TCP_STATE_RESP_ST7.1
00:000056A1   TCPIP_TCP_STATE_RESP_ST8
00:000056AD   TCPIP_TCP_STATE_RESP_ST8.1
00:000056BD   TCPIP_TCP_STATE_DISCARD_IBLOCK
00:000056C9   TCPIP_TCP_STATE_DISCARD_IBLOCK.1
00:000056D4   TCPIP_TCP_STATE_GET_IBLOCK
00:000056DA   TCPIP_TCP_STATE_SAVE_IBLOCK
00:000056E6   TCPIP_TCP_STATE_SAVE_IBLOCK.1
00:000056F6 X TCPIP_TCP_SEND_ERROR
00:000056F9   TCPIP_TCP_SEND_ERROR2
00:00005705   TCPIP_TCP_SEND_ERROR2.1
00:0000570D   TCPIP_TCP_SEND
00:0000572B   TCPIP_TCP_SEND_R
00:0000573B   TCPIP_TCP_SEND_ST1
00:00005747   TCPIP_TCP_SEND_R.1
00:0000574E   TCPIP_TCP_SEND_RC
00:0000575A   TCPIP_TCP_SEND_RC.1
00:00005761   TCPIP_TCP_SEND_ST2
00:0000576D   TCPIP_TCP_SEND_ST2.1
00:00005775   TCPIP_TCP_RCV_CHECK_TIME_OUT
00:00005782   TCPIP_TCP_RCV_RETRY_QRCV
00:00005794   TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY
00:00005797   TCPIP_TCP_RCV_RET_ERR
00:0000579A   TCPIP_TCP_RCV_RET_ERR2
00:000057A6   TCPIP_TCP_RCV_RET_ERR2.1
00:000057AD   TCPIP_TCP_RCV_RET_NODATA
00:000057B4   TCPIP_TCP_RCV
00:000057D8   TCPIP_TCP_RCV.RXRETRY
00:000057DE   TCPIP_TCP_RCV_ST1
00:000057EA   TCPIP_TCP_RCV_ST1.1
00:000057F9   TCPIP_TCP_RCV_RC
00:00005805   TCPIP_TCP_RCV_RC.1
00:0000580B   TCPIP_TCP_RCV_ST2A
00:00005817   TCPIP_TCP_RCV_ST2A.1
00:0000581B   TCPIP_TCP_RCV_ST2B
00:00005827   TCPIP_TCP_RCV_ST2B.1
00:00005836   TCPIP_TCP_RCV_UDC_ST1
00:00005842   TCPIP_TCP_RCV_UDC_ST1.1
00:00005845   TCPIP_TCP_RCV_UDC_ST2
00:00005851   TCPIP_TCP_RCV_UDC_ST2.1
00:00005865   TCPIP_TCP_RCV_R
00:0000587F   TCPIP_TCP_RCV_R_NSF
00:0000588B   TCPIP_TCP_RCV_R_NSF.1
00:0000589E   TCPIP_CONFIG_AUTOIP
00:000058B8   TCPIP_CONFIG_AUTOIP_ST1
00:000058C4   TCPIP_CONFIG_AUTOIP_ST1.1
00:000058CB   TCPIP_CONFIG_AUTOIP_RC
00:000058D7   TCPIP_CONFIG_AUTOIP_RC.1
00:000058DE   TCPIP_CONFIG_AUTOIP_ST2
00:000058EA   TCPIP_CONFIG_AUTOIP_ST2.1
00:000058F0   TCPIP_CONFIG_AUTOIP_CONF_ST1
00:000058FC   TCPIP_CONFIG_AUTOIP_CONF_ST1.1
00:00005902   TCPIP_CONFIG_IP
00:00005928   TCPIP_CONFIG_IP_ST1
00:00005934   TCPIP_CONFIG_IP_ST1.1
00:0000593B   TCPIP_CONFIG_IP_RC
00:00005947   TCPIP_CONFIG_IP_RC.1
00:0000594B   TCPIP_CONFIG_TTL
00:0000595D   TCPIP_CONFIG_PING
00:0000596D   GETSLT
00:0000598D   GETSLTT
00:000059AE   GETSLTT1
00:000059C2   GETSLTTRET
00:000059C6   GETWRK
00:000059DA   GETMEMPOINTERADDR
00:000059ED   GETMEM_1
00:000059F6   GETMEMPOINTER
00:000059FE   GETCOUNTER
00:00005A0D   SETCOUNTER
00:00005A1D   GETBYTE
00:00005A2F   SETBYTE
00:00005A43   GETWORD
00:00005A56   SETWORD
00:00005A6B   REGRESTORE
00:00005A82   REGBACKUP
00:00005AA4   BCRESTORE
00:00005AB6   BCBACKUP
00:00005ACA   HLRESTORE
00:00005ADD   HLBACKUP
00:00005AF2   GETDNSREADY
00:00005B04   SETDNSREADY
00:00005B18   GETDNSRESULT
00:00005B2E   SETDNSRESULT
00:00005B48   TOUPPER
00:00005B51   WRFE_WAIT_DATA
00:00005B5E   WRFE_STS_NOT_AVAILABLE
00:00005B63   WRFE_COMPARE
00:00005B69   WAIT_RESPONSE_FROM_ESP
00:00005B6C X WRFE_ST1
00:00005B6E   WRFE_LOOP
00:00005B7A   WRFE_LOOP.1
00:00005B7D X WRFE_IDXCMD
00:00005B89   WRFE_RSP_MATCH
00:00005B92   WRFE_RET_OK
00:00005B95   WRFE_RET_ERROR
00:00005B99   RESET_ESP
00:00005BB6   RESET_ESP_INIT
00:00005BB8   RESET_ESP_LOOP
00:00005BD9 X RESET_CHK_IF_INSTALLED
00:00005BDC   SET_TIME
00:00005BF3   SET_TIME_ERR
00:00005BF6   SET_RTC_TIME
00:00005C09   SET_DATE
00:00005C27   SET_DATE1
00:00005C34   SET_DATE2
00:00005C41   SET_DATE_ERR
00:00005C44   DAYS_IN_MONTH
00:00005C50   DAYS_IN_FEBRUARY_LEAP
00:00005C51   STOP_RTC_COUNT_SET_MODE0
00:00005C5C   RTC_SAVE_REGISTERPAIR
00:00005C60   RTC_SAVE_REGISTERPAIR.1
00:00005C6D   SET_RTC_REG
00:00005C76   SET_RTC_DATE
00:00005C8C   SET_RTC_DATE.1
00:00005CA3   PATTERN_SETUP
00:00005CB1   OUTI_TO_VRAM_TMS9918
00:00005CB7   PATTERN_DATA
00:00005D17   SET_VDP_WRITE
00:00000052 X CMD_RESET_ESP
00:00000057   CMD_WRESET_ESP
00:00000048   CMD_WIFIHOLD_ESP
00:00000068   CMD_WIFIRELEASE_ESP
00:00000047   CMD_GET_TIME
00:00000063   CMD_QUERY_ACLK_SETTINGS
00:00000043   CMD_SET_ACLK_SETTINGS
00:00000051   CMD_QUERY_ESP_SETTINGS
00:00000054   CMD_TIMER_SET
00:00000044   CMD_NAGLE_ON
00:0000004E   CMD_NAGLE_OFF
00:0000004F   CMD_WIFI_OFF
00:00000041   CMD_WIFI_CONNECT
00:00000053   CMD_SCAN_START
00:00000073   CMD_SCAN_RESULTS
00:00000067   CMD_AP_STS
00:00000056 X CMD_GET_ESP_VER
00:00005D33   RSP_CMD_RESET_ESP
00:00000005   RSP_CMD_RESET_ESP_SIZE
00:0000003F   CMD_QUERY_ESP
00:00005D38   RSP_CMD_QUERY_ESP
00:00000002   RSP_CMD_QUERY_ESP_SIZE
00:00000000   STTERMINATOR
00:0000000A   LF
00:0000000B   HOME
00:0000000C   CLS
00:0000000D   CR
00:0000001C   GORIGHT
00:0000001D   GOLEFT
00:00005D3A   ENTERING_WIFI_SETUP
00:00005D56   WELCOME
00:00005DA4   WELCOME_SF
00:00005DC0   WELCOME_SF2
00:00005DE0   WELCOME_CS
00:00005E0A   WELCOME_NEXT
00:00005E10 X WELCOME_S_NEXT
00:00005E14   WELCOME_SF_NEXT
00:00005E17   WELCOME_CS0_NEXT
00:00005E41   WELCOME_CS1_NEXT
00:00005E4A   WELCOME_CS2_NEXT
00:00005E74   WELCOME_CS3_NEXT
00:00005E9E   WELCOME_CS4_NEXT
00:00005EC8   WELCOME_CS5_NEXT
00:00005EF2   MMENU_S_NEXT
00:00005F81   MMENU_CLOCK_MSX2
00:000060E1   MMENU_CLOCK_MSX1
00:00006175   MMENU_CLOCK_0
00:00006187   MMENU_CLOCK_1
00:000061A1   MMENU_CLOCK_2
00:000061BB   MMENU_CLOCK_3
00:000061CE   MMENU_CLOCK_OPT
00:000061F8   MMENU_GMT_OPT
00:00006211   MMENU_MANUALENTRY
00:00006272   MENU_MANUALENTRY_PWD
00:0000628D   MMENU_SCAN
00:000062DB   MMENU_SCANF
00:000062FB   MMENU_SCANN
00:00006312   MMENU_SCANS
00:00006348   MMENU_CONNECTING
00:0000638C   MMENU_ASKPWD
00:000063CF   MMENU_SCANQ
00:0000643A   MMENU_SCANQM
00:000064A9   SCAN_TERMINATOR_CUT
00:000064B0   SCAN_TERMINATOR_OPEN
00:000064B7   SCAN_TERMINATOR_ENC
00:000064BE   MMENU_TIMEOUT
00:000065A0   MMENU_TIMEOUT_ALWAYSON
00:000065F5   MMENU_TIMEOUT_NOTALWAYSON1
00:0000660B   MMENU_TIMEOUT_NOTALWAYSON2
00:00006643   MMENU_NAGLE
00:00006738   MMENU_NAGLE_ON
00:00006778   MMENU_NAGLE_OFF
00:000067B9   STR_SENDING
00:000067D4   STR_SENDING_OK
00:000067ED   STR_SENDING_OK_JN
00:0000680F   STR_SENDING_NOK_JN
00:00006851   STR_SENDING_FAIL
00:00006866   STR_CLKUPDT_FAIL
00:000068D4   OK_S
00:000068EF   FAIL_S
00:0000693D   FAIL_F
00:0000695C   STR_WAITING
00:0000697C   STR_OOPS
00:000069B7   UNAPI_ID
00:000069BE X UNAPI_ID_END
00:000069BE   APIINFO
00:000069D2   ID_END
00:00007FE0 X BUILD_NAME
00:00007FF0 X BUILD_DATE
00:00008000 X SEG_CODE_END


 Output: ESP8266P.rom
-------------------------------------------------

 Page: 00
  Org: 00004000  Size: *  Used: 00004000

   Address   Length Align   Label
   00004000   16384         INIT
