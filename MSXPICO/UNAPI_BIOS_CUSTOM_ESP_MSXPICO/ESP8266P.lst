Sjasm Z80 Assembler v0.42c - www.xl2s.tk             [2024.09.08 - 10:00:26]

ESP8266_memio.asm
Errors: 0

       1   00:4000                      ; ESP8266 TCP/IP UNAPI BIOS v.1.3
       2   00:4000                      ; MSX PICO UART version
       3   00:4000                      ; Oduvaldo Pavan Junior
       4   00:4000                      ; ducasp@gmail.com
       5   00:4000                      ;    This code implements TCP/IP UNAPI Specification for MSX-SM
       6   00:4000                      ;
       7   00:4000                      ; Pieces of this code were based on DENYOTCP.ASM (Denyonet ROM)
       8   00:4000                      ; made by Konamiman
       9   00:4000                      ;
      10   00:4000                      ; This code also has contributions from KdL, most specifically in the Wi-Fi
      11   00:4000                      ; setup menus and functionality, he has helped quite a lot to get it to the
      12   00:4000                      ; final format and functionality, thanks!
      13   00:4000                      ;
      14   00:4000                      ; Note: this implementation depends upon ESP8266 having the UNAPI
      15   00:4000                      ; firmware flashed. This firmware has been developed by me as well.
      16   00:4000                      ;
      17   00:4000                      ; Comercial usage of this code or derivative works of this code are
      18   00:4000                      ; allowed ONLY upon agreement with the author.
      19   00:4000                      ; Non-comercial usage is free as long as you publish your code changes.
      20   00:4000                      ;
      21   00:4000                      ; Design details:
      22   00:4000                      ; There are five instances of this ROM
      23   00:4000                      ;
      24   00:4000                      ; 1 - If configured as disabled in set-up menu item 4, or through setting F2
      25   00:4000                      ;     device to EF or keeping DEL pressed during boot, it won't load at all.
      26   00:4000                      ; 2 - F1 is pressed during boot, or through setting F2 device to F1, it will
      27   00:4000                      ;     show a setup menu, ESC resume boot.
      28   00:4000                      ; 3 - F2 is pressed during a soft reset, or trhough setting F2 device to F2 it
      29   00:4000                      ;     will force re-set of the ESP and re-connection to the AP.
      30   00:4000                      ; 4 - No key is pressed during a warm boot and F2 device is set to F0, UNAPI 
      31   00:4000                      ;     is enabled (default), EXTBIO HOOK for UNAPI calls is installed and HTIM_I
      32   00:4000                      ;     hook for internal usage and a few bytes at top of TPA are reserved upon
      33   00:4000                      ;     the first UNAPI function being called. No ESP reset or tries to set-up the
      34   00:4000                      ;     the RTC are done, so it is a quick warm-boot.
      35   00:4000                      ; 5 - No key is pressed during a cold boot or F2 is set to FE or any unknown
      36   00:4000                      ;     value, UNAPI is enabled (default), EXTBIO HOOK for UNAPI calls is installed
      37   00:4000                      ;     and HTIM_I hook for internal usage and a few bytes at top of TPA are reserved
      38   00:4000                      ;     upon the first UNAPI function being called. ESP is reset and if BIOS is set
      39   00:4000                      ;     up to do so, SNTP connection attempt is made and RTC is updated
      40   00:4000                      ;
      41   00:4000                      ; As a ROM, our segment is read only, so for RAM needs we need to use RAM not
      42   00:4000                      ; in our page. This ROM will do the following:
      43   00:4000                      ;
      44   00:4000                      ; If running the SETUP menu, we are going to "borrow" BASIC program area, that
      45   00:4000                      ; is saved at TXTTAB. We can't allocate memory at this point as any possible
      46   00:4000                      ; disk rom might be sitting on a slot that has not been initialized and results
      47   00:4000                      ; could be bad. The BASIC program area trick should be safe, unless some other
      48   00:4000                      ; cartridge runs a BASIC software for something (i.e.: wait disks be initialized
      49   00:4000                      ; ), in such case, that BASIC software or trick will most likely be corrupted
      50   00:4000                      ; after running our setup.
      51   00:4000                      ;
      52   00:4000                      ; After boot, we need RAM in the 4th page. We have the SLOT WORK AREA for free,
      53   00:4000                      ; it is 8 bytes reserved for our slot, and that is certainly not enough, just
      54   00:4000                      ; the EXTBIOS HOOK backup cost us 5 bytes, so we have three bytes remaining. Of
      55   00:4000                      ; those, we use two to indicate the bottom of the memory reserved in the 4th
      56   00:4000                      ; page. Whenever more memory is needed, HIMEM_RESERVED_SIZE must change, just
      57   00:4000                      ; remember that more memory reserved means less memory available to
      58   00:4000                      ; applications and BASIC, so use it wisely.
      59   00:4000                      ;
      60   00:4000                      ; Slot Work Area Details
      61   00:4000                      ; 0000 - 0004   : EXTBIO hook backup
      62   00:4000                      ; 0005 - 0006   : HIMEM Allocated area (starts with 00 xx, once allocated goes
      63   00:4000                      ;                 to Fxxx or Exxx so checking 0005 if 00 is enough)
      64   00:4000                      ; 007           : Unused
      65   00:4000                      ;
      66   00:4000                      ; Current HIMEM mapping offset related to the address stored in the 6th and 7th
      67   00:4000                      ; bytes of our slot work area:
      68   00:4000                      ;
      69   00:4000                      ; 0000 - 0004   : HTIM_I hook backup
      70   00:4000                      ; 0005 - 0006   : Counter that our HTIM_I hook updates
      71   00:4000                      ; 0007          : Store Single Byte some functions need
      72   00:4000                      ; 0008          : Stores whether DNS is ready or not
      73   00:4000                      ; 0009 - 000A   : Stores last DNS result
      74   00:4000                      ; 000B - 000C   : Stores a 16 bits value
      75   00:4000                      ; 000D - 0012   : Store a backup of BC / DE / HL
      76   00:4000                      ;   000D - 000E : C and B
      77   00:4000                      ;   000F - 0010 : D and E
      78   00:4000                      ;   0011 - 0012 : H and L
      79   00:4000                      ; 0013 - 001D   : Unused
      80   00:4000                      ;
      81   00:4000                      ; As this is sitting on a slot, there is a resoanable chance that this is initialized
      82   00:4000                      ; before any disk controllers. If that is the case, allocating memory at HIMEM is bad
      83   00:4000                      ; and might have two bad behaviors:
      84   00:4000                      ;
      85   00:4000                      ; 1 - Disk Controller is smart enough to determine HIMEM was moved and simply do not
      86   00:4000                      ; initialize. No disk available...
      87   00:4000                      ; 2 - Disk Controller doesn't care and simply wipe-out memory below original HIMEM at
      88   00:4000                      ; boot to create the disk interfaces static work area, thus, causing our allocated
      89   00:4000                      ; memory to be overwritten and MSX will most likely crash on ther first VDP interrupt
      90   00:4000                      ; after that...
      91   00:4000                      ;
      92   00:4000                      ; So, allocating memory at cartridge startup will make MSX freeze or misbehave or not
      93   00:4000                      ; have the disk available if our ROM is sitting in a slot lower than the disk. There
      94   00:4000                      ; are a few possibilities:
      95   00:4000                      ;
      96   00:4000                      ; 1 - Hook to H_STKE, it is called once all slots have been initialized... But, using
      97   00:4000                      ; this hook will make ESE SCSI to not work and halt with a "No enough memory" message,
      98   00:4000                      ; so I do not consider it a good option as the intention is to re-use code for other
      99   00:4000                      ; adapters.
     100   00:4000                      ; 2 - On any UNAPI call check the slot work area if the allocated area is other than 00
     101   00:4000                      ; and if it is, execute, otherwise, first execute our allocation routine. This has an
     102   00:4000                      ; overhead of a dozen instructions at every UNAPI function we execute, does not seem to
     103   00:4000                      ; impact performance compared to the UNAPI RAM driver that doesn't has it
     104   00:4000                      ; 3 - Try to go crazy and check for dos roms on slots above us, initialize those first
     105   00:4000                      ; if found... Too much trouble for a dozen instructions.
     106   00:4000                      ;
     107   00:4000                      ; So, for the moment the design decision is option #2
     108   00:4000                      ;
     109   00:4000                      ; F2 Device by KdL
     110   00:4000                      ; That device, present on recent OCM implementations, allow a byte to be saved and
     111   00:4000                      ; read from IO address F2. It has FF on start-up, and KdL devised the following
     112   00:4000                      ; values/states:
     113   00:4000                      ;
     114   00:4000                      ; FF - Default, meaning cold boot
     115   00:4000                      ; FE - Set this when an unexpected error occurred
     116   00:4000                      ; F2 - Equivalent to keeping F2 pressed at boot time, force the next warm boot
     117   00:4000                      ;      to try to detect the ESP8266
     118   00:4000                      ; F1 - Will force the Wi-Fi setup at next warm boot, so it is not needed to
     119   00:4000                      ;      keep F1 pressed
     120   00:4000                      ; F0 - Means that RTC has date and time, so the next warm boot doesn't check
     121   00:4000                      ;      for F1/F2 or try to update RTC, being faster
     122   00:4000                      ; EF - Set when ESP8266 was not found or by user at runtime to disable UNAPI
     123   00:4000                      ;      next warm boot
     124   00:4000                      
     125   00:4000                      ;*************************
     126   00:4000                      ;***  BUILD DEFINITIONS **
     127   00:4000                      ;*************************
     128   00:4000                      
     129   00:4000                      ;--- verbose rom...?
     130   00:4000  (00:0000)           VERBOSE_ROM:            equ 0
     131   00:4000                      ;--- Use memory mapped IO or not...
     132   00:4000  (00:0001)           USE_MEM_IO:             equ 1
     133   00:4000                      
     134   00:4000                      ;*******************
     135   00:4000                      ;***  CONSTANTS  ***
     136   00:4000                      ;*******************
     137   00:4000                      
     138   00:4000                      ;--- System variables and routines:
     139   00:4000  (00:005F)           CHGMOD:                 equ #005F
     140   00:4000  (00:009C)           CHSNS:                  equ #009C
     141   00:4000  (00:009F)           CHGET:                  equ #009F
     142   00:4000  (00:00A2)           CHPUT:                  equ #00A2
     143   00:4000  (00:00C0)           BEEP:                   equ #00C0
     144   00:4000  (00:0141)           SNSMAT:                 equ #0141
     145   00:4000  (00:0156)           KILBUF:                 equ #0156
     146   00:4000  (00:F3B0)           LINLEN:                 equ #F3B0
     147   00:4000  (00:F3DB)           CLIKSW:                 equ #F3DB
     148   00:4000  (00:F3E1)           REG2SAV:                equ #F3E1
     149   00:4000  (00:F3E3)           REG4SAV:                equ #F3E3
     150   00:4000  (00:F676)           TXTTAB:                 equ #F676
     151   00:4000  (00:F847)           ARG:                    equ #F847
     152   00:4000  (00:FB20)           HOKVLD:                 equ #FB20
     153   00:4000  (00:FC4A)           HIMEM:                  equ #FC4A
     154   00:4000  (00:FCA9)           CSRSW:                  equ #FCA9
     155   00:4000  (00:FCC1)           EXPTBL:                 equ #FCC1
     156   00:4000  (00:FD09)           SLTWRK:                 equ #FD09
     157   00:4000  (00:FD9F)           H_TIMI:                 equ #FD9F
     158   00:4000  (00:FED0)           H_CLEA:                 equ #FED0
     159   00:4000  (00:FFCA)           EXTBIO:                 equ #FFCA
     160   00:4000                      
     161   00:4000                      
     162   00:4000                      ;--- Memory ports:
     163   00:4000  (00:7F06)           MEM_OUT_CMD_PORT:       equ #7F06
     164   00:4000  (00:7F07)           MEM_OUT_TX_PORT:        equ #7F07
     165   00:4000  (00:7F06)           MEM_IN_DATA_PORT:       equ #7F06
     166   00:4000  (00:7F07)           MEM_IN_STS_PORT:        equ #7F07
     167   00:4000  (00:7FF2)           MEM_PORT_F2:            equ #7FF2
     168   00:4000                      
     169   00:4000                      ;--- I/O ports:
     170   00:4000  (00:0006)           OUT_CMD_PORT:           equ #06
     171   00:4000  (00:0007)           OUT_TX_PORT:            equ #07
     172   00:4000  (00:0006)           IN_DATA_PORT:           equ #06
     173   00:4000  (00:0007)           IN_STS_PORT:            equ #07
     174   00:4000  (00:00F2)           PORT_F2:                equ #F2
     175   00:4000                      
     176   00:4000                      
     177   00:4000                          if USE_MEM_IO = 1
     178   00:4000                        MACRO SET_SPEED
     179   00:4000                    <     xor a
     180   00:4000                    <     ld  (MEM_OUT_CMD_PORT),a            ; Clear UART
     181   00:4000                    <   ENDM
     182   00:4000                      
     183   00:4000                        MACRO CLEAR_UART
     184   00:4000                    <     ld  a,20
     185   00:4000                    <     ld  (MEM_OUT_CMD_PORT),a            ; Clear UART
     186   00:4000                    <   ENDM
     187   00:4000                      
     188   00:4000                        MACRO SEND_DATA
     189   00:4000                    <     ld  (MEM_OUT_TX_PORT),a             ; Just send, no need to wait response
     190   00:4000                    <   ENDM
     191   00:4000                      
     192   00:4000                        MACRO RECEIVE_DATA
     193   00:4000                    <     ld a,(MEM_IN_DATA_PORT)
     194   00:4000                    <   ENDM
     195   00:4000                      
     196   00:4000                        MACRO LOAD_STS_PORT_IN_A
     197   00:4000                    <     ld  a,(MEM_IN_STS_PORT)
     198   00:4000                    <   ENDM
     199   00:4000                      
     200   00:4000                        MACRO CHECK_DATA
     201   00:4000                    <     ld  a,(MEM_IN_STS_PORT)
     202   00:4000                    <     bit 0,a                         ; If nz has data
     203   00:4000                    <   ENDM
     204   00:4000                      
     205   00:4000                        MACRO CHECK_BUFFER_UNDERRUN
     206   00:4000                    <     ld  a,(MEM_IN_STS_PORT)
     207   00:4000                    <     bit 4,a                         ; Buffer underrun?
     208   00:4000                    <   ENDM
     209   00:4000                      
     210   00:4000                        MACRO READ_F2
     211   00:4000                    <     ld  a,(MEM_PORT_F2)
     212   00:4000                    <   ENDM
     213   00:4000                      
     214   00:4000                        MACRO WRITE_F2
     215   00:4000                    <     ld  (MEM_PORT_F2),a
     216   00:4000                    <   ENDM
     217   00:4000                          else
     218   00:4000                    ~ 
     219   00:4000                    ~   MACRO SET_SPEED
     220   00:4000                    ~     xor a
     221   00:4000                    ~     out (OUT_CMD_PORT),a            ; Clear UART
     222   00:4000                    ~   ENDM
     223   00:4000                    ~ 
     224   00:4000                    ~   MACRO CLEAR_UART
     225   00:4000                    ~     ld  a,20
     226   00:4000                    ~     out (OUT_CMD_PORT),a            ; Clear UART
     227   00:4000                    ~   ENDM
     228   00:4000                    ~ 
     229   00:4000                    ~   MACRO SEND_DATA
     230   00:4000                    ~     out (OUT_TX_PORT),a             ; Just send, no need to wait response
     231   00:4000                    ~   ENDM
     232   00:4000                    ~ 
     233   00:4000                    ~   MACRO RECEIVE_DATA
     234   00:4000                    ~     in a,(IN_DATA_PORT)
     235   00:4000                    ~   ENDM
     236   00:4000                    ~ 
     237   00:4000                    ~   MACRO LOAD_STS_PORT_IN_A
     238   00:4000                    ~     in  a,(IN_STS_PORT)
     239   00:4000                    ~   ENDM
     240   00:4000                    ~ 
     241   00:4000                    ~   MACRO CHECK_DATA
     242   00:4000                    ~     in  a,(IN_STS_PORT)
     243   00:4000                    ~     bit 0,a                         ; If nz has data
     244   00:4000                    ~   ENDM
     245   00:4000                    ~ 
     246   00:4000                    ~   MACRO CHECK_BUFFER_UNDERRUN
     247   00:4000                    ~     in  a,(IN_STS_PORT)
     248   00:4000                    ~     bit 4,a                         ; Buffer underrun?
     249   00:4000                    ~   ENDM
     250   00:4000                    ~ 
     251   00:4000                    ~   MACRO READ_F2
     252   00:4000                    ~     in  a,(PORT_F2)
     253   00:4000                    ~   ENDM
     254   00:4000                    ~ 
     255   00:4000                    ~   MACRO WRITE_F2
     256   00:4000                    ~     out (PORT_F2),a
     257   00:4000                    ~   ENDM
     258   00:4000                    ~     endif
     259   00:4000                      
     260   00:4000                      ;--- API version and implementation version:
     261   00:4000  (00:0001)           API_V_P:                equ 1
     262   00:4000  (00:0002)           API_V_S:                equ 2
     263   00:4000  (00:0001)           ROM_V_P:                equ 1
     264   00:4000  (00:0003)           ROM_V_S:                equ 3
     265   00:4000                      
     266   00:4000                      ;--- Size of memory to reserve in upper TPA:
     267   00:4000  (00:001E)           HIMEM_RESERVED_SIZE     equ 30
     268   00:4000                      
     269   00:4000                      ;--- Layout of our TPA area:
     270   00:4000  (00:0000)           H_TIM_BACKUP_OFFSET     equ 0
     271   00:4000  (00:0005)           MEMORY_COUNTER_OFFSET   equ 5
     272   00:4000  (00:0007)           MEMORY_SB_VAR_OFFSET    equ 7
     273   00:4000  (00:0008)           MEMORY_DNS_READY_OFFSET equ 8
     274   00:4000  (00:0009)           MEMORY_DNS_RES_OFFSET   equ 9
     275   00:4000  (00:000B)           MEMORY_DB_VAR_OFFSET    equ #0B
     276   00:4000  (00:000D)           MEMORY_REGBACKUP_OFFSET equ #0D
     277   00:4000  (00:000D)           MEMORY_BCBACKUP_OFFSET  equ #0D
     278   00:4000  (00:000F)           MEMORY_DEBACKUP_OFFSET  equ #0F
     279   00:4000  (00:0011)           MEMORY_HLBACKUP_OFFSET  equ #11
     280   00:4000                      
     281   00:4000                      ;--- Scan Page Size
     282   00:4000  (00:0008)           SCAN_MAX_PAGE_SIZE      equ 8
     283   00:4000                      
     284   00:4000                      ;--- Maximum number of available standard and implementation-specific function
     285   00:4000                      ;--- numbers. Must be 0 to 127.
     286   00:4000  (00:001D)           MAX_FN:                 equ 29
     287   00:4000                      
     288   00:4000                      ;--- Must be either zero (if no implementation-specific functions available),
     289   00:4000                      ;--- or 128 to 254.
     290   00:4000  (00:0000)           MAX_IMPFN:              equ 0
     291   00:4000                      
     292   00:4000                      ;--- TCP/IP UNAPI error codes:
     293   00:4000  (00:0000)           ERR_OK:                 equ 0
     294   00:4000  (00:0001)           ERR_NOT_IMP:            equ 1
     295   00:4000  (00:0002)           ERR_NO_NETWORK:         equ 2
     296   00:4000  (00:0003)           ERR_NO_DATA:            equ 3
     297   00:4000  (00:0004)           ERR_INV_PARAM:          equ 4
     298   00:4000  (00:0005)           ERR_QUERY_EXISTS:       equ 5
     299   00:4000  (00:0006)           ERR_INV_IP:             equ 6
     300   00:4000  (00:0007)           ERR_NO_DNS:             equ 7
     301   00:4000  (00:0008)           ERR_DNS:                equ 8
     302   00:4000  (00:0009)           ERR_NO_FREE_CONN:       equ 9
     303   00:4000  (00:000A)           ERR_CONN_EXISTS:        equ 10
     304   00:4000  (00:000B)           ERR_NO_CONN:            equ 11
     305   00:4000  (00:000C)           ERR_CONN_STATE:         equ 12
     306   00:4000  (00:000D)           ERR_BUFFER:             equ 13
     307   00:4000  (00:000E)           ERR_LARGE_DGRAM:        equ 14
     308   00:4000  (00:000F)           ERR_INV_OPER:           equ 15
     309   00:4000                      
     310   00:4000                      ;--- TCP/IP UNAPI connection Status
     311   00:4000  (00:0000)           UNAPI_TCPIP_NS_CLOSED   equ 0
     312   00:4000  (00:0001)           UNAPI_TCPIP_NS_OPENING  equ 1
     313   00:4000  (00:0002)           UNAPI_TCPIP_NS_OPEN     equ 2
     314   00:4000  (00:00FF)           UNAPI_TCPIP_NS_UNKNOWN  equ 255
     315   00:4000                      
     316   00:4000                      ;************************
     317   00:4000                      ;***  MSX ROM HEADER  ***
     318   00:4000                      ;************************
     319   00:4000                          org #4000
     320   00:4000  41 42                   db                  #41,#42
     321   00:4002  10 40                   dw                  INIT        ; Initialize ESP, if not found, won't install hook
     322   00:4004  00 00                   dw                  0           ; Statement
     323   00:4006  00 00                   dw                  0           ; Device
     324   00:4008  00 00                   dw                  0           ; Text
     325   00:400A  00 (6)                  ds                  6           ; Reserved
     326   00:4010                      
     327   00:4010                      ;==================
     328   00:4010                      ;===  Start-up  ===
     329   00:4010                      ;==================
     330   00:4010                      
     331   00:4010                      INIT:
     332   00:4010  7C                      ld  a,h                         ; Let's test if we are mirrored and being executed in wrong page
     333   00:4011  FE 40                   cp  #40                         ; is MSB 0x40?
     334   00:4013  C0                      ret nz                          ; if not, return, it is a mirror
     335   00:4014                          ; Let's set some System Variables
     336   00:4014  AF                      xor a                           ; a = #00
     337   00:4015  32 A9 FC                ld  (CSRSW),a                   ; cursor display is disabled
     338   00:4018  32 DB F3                ld  (CLIKSW),a                  ; when key press, key click disabled
     339   00:401B                          ; Let's intercept [DEL] key
     340   00:401B  3E 08                   ld  a,8
     341   00:401D  CD 41 01                call    SNSMAT
     342   00:4020  CB 5F                   bit 3,a                         ; Test [DEL]
     343   00:4022  C8                      ret z                           ; If DEL is pressed, UNAPI driver is not loaded and exits
     344   00:4023                          ; Let's check the Screen Mode, ref. https://www.msx.org/wiki/VDP_Table_Base_Address_Registers
     345   00:4023  3A E1 F3                ld  a,(REG2SAV)
     346   00:4026  FE 02                   cp  2
     347   00:4028  CA 32 40                jp  z,SCREEN_SETUP              ; If yes, is SCREEN 3
     348   00:402B  3A E3 F3                ld  a,(REG4SAV)
     349   00:402E  FE 00                   cp  0
     350   00:4030  28 06                   jr  z,IS_SCREEN1                ; If yes, is SCREEN 1
     351   00:4032                      SCREEN_SETUP:
     352   00:4032                          ; Let's set the SCREEN 1
     353   00:4032  3E 01                   ld  a,1                         ; a = #01
     354   00:4034  F7                      rst #30
     355   00:4035  00                      db  0
     356   00:4036  5F 00                   dw  CHGMOD                      ; SCREEN 1
     357   00:4038                      IS_SCREEN1:
     358   00:4038  3E 1D                   ld  a,29                        ; WIDTH 29
     359   00:403A  32 B0 F3                ld  (LINLEN),a
     360   00:403D                          ; We check if the Port F2 device is available
     361   00:403D                          READ_F2                         ; a = #FF, default value if it comes from power off or hard reset
     361   00:403D  3A F2 7F          >     ld  a,(MEM_PORT_F2)
     362   00:4040  2F                      cpl                             ; a = #FF - a
     363   00:4041  4F                      ld  c,a                         ; c = #00
     364   00:4042                          WRITE_F2                        ; a = #00
     364   00:4042  32 F2 7F          >     ld  (MEM_PORT_F2),a
     365   00:4045                          ; Wait 250ms to ensure a successful hard reset even if you press the button very quickly
     366   00:4045  CD E7 49                call    WAIT_250MS_AND_THEN_CONTINUE
     367   00:4048                          READ_F2                         ; a = #00?
     367   00:4048  3A F2 7F          >     ld  a,(MEM_PORT_F2)
     368   00:404B  2F                      cpl                             ; a = #FF - a
     369   00:404C                          WRITE_F2                        ; a = #FF?
     369   00:404C  32 F2 7F          >     ld  (MEM_PORT_F2),a
     370   00:404F  F5                      push    af
     371   00:4050  3E FE                   ld  a,#FE                       ; Preset #FE, unexpected error
     372   00:4052                          WRITE_F2                        ; on port #F2
     372   00:4052  32 F2 7F          >     ld  (MEM_PORT_F2),a
     373   00:4055  F1                      pop af
     374   00:4056  B9                      cp  c                           ; If not a = c, port #F2 is writable and available
     375   00:4057  28 3D                   jr  z,BOOT_FROM_POWER_OFF       ; If a = c, port #F2 is not available, let's proceed as "boot from power off"
     376   00:4059                          ; Ok, Port F2 device available
     377   00:4059  FE EF                   cp  #EF                         ; UNAPI driver has been disabled
     378   00:405B  20 04                   jr  nz,NOT_DISABLED_BY_F2       ; No, let's continue checking
     379   00:405D                          WRITE_F2                        ; If yes, UNAPI driver is not loaded and exits, but need to restore F2 port to not have a false error
     379   00:405D  32 F2 7F          >     ld  (MEM_PORT_F2),a
     380   00:4060  C9                      ret                             ; And our work is done
     381   00:4061                      NOT_DISABLED_BY_F2:
     382   00:4061  FE F0                   cp  #F0                         ; UNAPI driver has been loaded at least once
     383   00:4063  C2 78 40                jp  nz, F2_IS_NOT_F0            ; Ok, has not been loaded
     384   00:4066                          ; Let's intercept [F1] key
     385   00:4066  3E 06                   ld  a,6
     386   00:4068  CD 41 01                call    SNSMAT
     387   00:406B  CB 6F                   bit 5,a                         ; Test [F1]
     388   00:406D  CA 29 42                jp  z,ENTERING_ESPSETUP         ; If F1 is pressed, let's execute our setup menu
     389   00:4070                          ; F1 is not pressed, continue
     390   00:4070  CB 77                   bit 6,a                         ; Test [F2]
     391   00:4072  C2 DA 40                jp  nz,INIT_UNAPI               ; If F2 is not pressed, let's proceed to INIT_UNAPI
     392   00:4075                          ; F2 is not pressed, continue
     393   00:4075  C3 93 41                jp  INIT_NOCLOCKUPDAT2          ; If yes, proceed without affecting the connection or the date and time
     394   00:4078                      F2_IS_NOT_F0:
     395   00:4078  FE F1                   cp  #F1                         ; User requested to go directly to Wi-Fi Setup
     396   00:407A  CA 29 42                jp  z,ENTERING_ESPSETUP         ; If yes, let's execute our setup menu
     397   00:407D  FE F2                   cp  #F2                         ; User forces to check if ESP is installed
     398   00:407F  CA B6 40                jp  z,F2_IS_PRESSED             ; If yes, let's go check it out
     399   00:4082  FE FE                   cp  #FE                         ; Unexpected error from the previous reboot
     400   00:4084  20 10                   jr  nz,BOOT_FROM_POWER_OFF      ; If no one is confirmed, let's proceed as "boot from power off"
     401   00:4086                          ; Oops! An unexpected error occurred on the last reboot
     402   00:4086  21 FB 68                ld  hl,STR_OOPS                 ; Print Oops! An unexpected error message
     403   00:4089  CD 6E 4C                call    PRINTHL                 ; and let's proceed as "boot from power off"
     404   00:408C  06 78                   ld  b,120                       ; Wait 2 seconds with message on screen
     405   00:408E                      WAIT_2S:
     406   00:408E  76                      halt
     407   00:408F  10 FD                   djnz    WAIT_2S                 ; If not zero, our time out has not elapsed
     408   00:4091  3E 0C                   ld  a,CLS
     409   00:4093  CD A2 00                call    CHPUT
     410   00:4096                      BOOT_FROM_POWER_OFF:
     411   00:4096                          ; Let's intercept [F1] key
     412   00:4096  3E 06                   ld  a,6
     413   00:4098  CD 41 01                call    SNSMAT
     414   00:409B  CB 6F                   bit 5,a                         ; Test [F1]
     415   00:409D  CA 29 42                jp  z,ENTERING_ESPSETUP         ; If F1 is pressed, let's execute our setup menu
     416   00:40A0                          ; F1 is not pressed, continue
     417   00:40A0                          if  VERBOSE_ROM = 0
     418   00:40A0  21 F5 5C                ld  hl,WELCOME
     419   00:40A3  CD 6E 4C                call    PRINTHL
     420   00:40A6  21 43 5D                ld  hl,WELCOME_SF
     421   00:40A9  CD 6E 4C                call    PRINTHL
     422   00:40AC                          endif
     423   00:40AC  3E 06                   ld  a,6
     424   00:40AE  CD 41 01                call    SNSMAT
     425   00:40B1  CB 77                   bit 6,a                         ; Test [F2]
     426   00:40B3  C2 DA 40                jp  nz,INIT_UNAPI               ; If F2 is not pressed, let's proceed to INIT_UNAPI
     427   00:40B6                          ; F2 is pressed, continue
     428   00:40B6                      F2_IS_PRESSED:
     429   00:40B6  CD 38 5B                call    RESET_ESP
     430   00:40B9  B7                      or  a
     431   00:40BA  20 06                   jr  nz,ESP_NOT_FOUND
     432   00:40BC  21 53 68                ld  hl,OK_S                     ; Properly detected
     433   00:40BF  C3 CC 40                jp  INIT_F_MSG                  ; Well, if reset successful, continue
     434   00:40C2                      ESP_NOT_FOUND:
     435   00:40C2                          ; If here, ESP was not found, so, exit with an error message
     436   00:40C2  78                      ld  a,b
     437   00:40C3  B7                      or  a
     438   00:40C4  21 6E 68                ld  hl,FAIL_S                   ; If 0, non responsive
     439   00:40C7  28 03                   jr  z,INIT_F_MSG
     440   00:40C9  21 BC 68                ld  hl,FAIL_F                   ; Otherwise, firmware is old
     441   00:40CC                      INIT_F_MSG:
     442   00:40CC  CD 6E 4C                call    PRINTHL
     443   00:40CF                      INIT_F_WAIT:
     444   00:40CF  06 B4                   ld  b,180                       ; 3s
     445   00:40D1                      INIT_F_LOOP_WAIT:
     446   00:40D1  76                      halt
     447   00:40D2  10 FD                   djnz    INIT_F_LOOP_WAIT
     448   00:40D4                      AND_DONE:
     449   00:40D4  3E EF                   ld  a,#EF                       ; Set #EF, ESP Not Found
     450   00:40D6                          WRITE_F2                        ; on port #F2
     450   00:40D6  32 F2 7F          >     ld  (MEM_PORT_F2),a
     451   00:40D9  C9                      ret                             ; And done
     452   00:40DA                      INIT_UNAPI:
     453   00:40DA                          CLEAR_UART
     453   00:40DA  3E 14             >     ld  a,20
     453   00:40DC  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     454   00:40DF  3E 63                   ld  a,CMD_QUERY_ACLK_SETTINGS
     455   00:40E1                          SEND_DATA
     455   00:40E1  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     456   00:40E4  21 3C 00                ld  hl,60                       ; Wait Up To 1s
     457   00:40E7  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
     458   00:40EB  DD 6B                   ld  ixl,e
     459   00:40ED  DD 62                   ld  ixh,d                       ; Address in IX
     460   00:40EF  CD 46 4B                call    WAIT_MENU_CMD_RESPONSE
     461   00:40F2  CA 89 41                jp  z,INIT_NOCLOCKUPDATE        ; If error, just skip
     462   00:40F5                          ; Response received, IX+0 and IX+1 has Auto Clock and GMT
     463   00:40F5  3E 03                   ld  a,3
     464   00:40F7  DD BE 00                cp  (ix+0)
     465   00:40FA  20 0B                   jr  nz,INIT_UNAPI2              ; If not disabled continue on INIT_UNAPI2
     466   00:40FC                          ; Disabled, ok, so let's ensure connection is not locked (just in case it was setup as disabled right now)
     467   00:40FC                          CLEAR_UART
     467   00:40FC  3E 14             >     ld  a,20
     467   00:40FE  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     468   00:4101  3E 68                   ld  a,CMD_WIFIRELEASE_ESP
     469   00:4103                          SEND_DATA                       ; Just send, no need to wait response
     469   00:4103  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     470   00:4106  C9                      ret
     471   00:4107                      INIT_UNAPI2:
     472   00:4107  3A 2D 00                ld  a,(#002D)                   ; Check MSX Version
     473   00:410A  B7                      or  a
     474   00:410B  28 7C                   jr  z,INIT_NOCLOCKUPDATE        ; If zero, MSX1, can't set clock
     475   00:410D  AF                      xor a
     476   00:410E  DD B6 00                or  (ix+0)
     477   00:4111  28 76                   jr  z,INIT_NOCLOCKUPDATE        ; if turned off, skip
     478   00:4113                          ; Ok, not zero, so we are going to simply request the time, it might take up to 10s
     479   00:4113  DD 23                   inc ix
     480   00:4115  DD 23                   inc ix                          ; ok, leave IX+0 and IX+1 intact
     481   00:4117                          ; b = number of response check attempts
     482   00:4117  06 05                   ld  b,5                         ; 5 * 2s = 10s
     483   00:4119                          CLEAR_UART
     483   00:4119  3E 14             >     ld  a,20
     483   00:411B  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     484   00:411E  3E 47                   ld  a,CMD_GET_TIME
     485   00:4120                          SEND_DATA
     485   00:4120  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     486   00:4123                      TRY_AGAIN:
     487   00:4123  C5                      push    bc
     488   00:4124  21 78 00                ld  hl,120                      ; Wait Up To 2s per attempt
     489   00:4127  CD 46 4B                call    WAIT_MENU_CMD_RESPONSE
     490   00:412A  20 1E                   jr  nz,INIT_CLOCKUPDATE         ; if ok, follow up
     491   00:412C  21 DB 68                ld  hl,STR_WAITING              ; Print Waiting for connection message
     492   00:412F  CD 6E 4C                call    PRINTHL
     493   00:4132  3E FF                   ld  a,#ff
     494   00:4134  B8                      cp  b                           ; Was time-out the failure reason?
     495   00:4135  C1                      pop bc                          ; Restore stack ballance and retry counter
     496   00:4136  20 04                   jr  nz,STOP_TRYING              ; If error return code and not time-out, no more checks needed
     497   00:4138  3E 47                   ld  a,CMD_GET_TIME              ; Needed for retries
     498   00:413A  10 E7                   djnz    TRY_AGAIN
     499   00:413C                      STOP_TRYING:
     500   00:413C                          ; Leave a message that clock has not been updated
     501   00:413C  21 E5 67                ld  hl,STR_CLKUPDT_FAIL
     502   00:413F  CD 6E 4C                call    PRINTHL
     503   00:4142  3E F0                   ld  a,240                       ; Wait 4 seconds with message on screen
     504   00:4144                      WAIT_4S:
     505   00:4144  76                      halt
     506   00:4145  3D                      dec a
     507   00:4146                          ; If not zero, our time out has not elapsed
     508   00:4146  20 FC                   jr  nz,WAIT_4S
     509   00:4148  18 3F                   jr  INIT_NOCLOCKUPDATE          ; error, just skip to not set garbage in clock
     510   00:414A                      INIT_CLOCKUPDATE:
     511   00:414A  C1                      pop bc
     512   00:414B  DD 2B                   dec ix
     513   00:414D  DD 2B                   dec ix                          ; ix back where it should
     514   00:414F                          ; ix + 0 -> 0 If no need to set clock, 1 if set clock, 2 if set clock and request to turn Wi-Fi Off
     515   00:414F                          ; ix + 1 -> GMT setting, well, not going to use it
     516   00:414F                          ; ix + 2 -> Seconds
     517   00:414F                          ; ix + 3 -> Minutes
     518   00:414F                          ; ix + 4 -> Hours
     519   00:414F                          ; ix + 5 -> Day
     520   00:414F                          ; ix + 6 -> Month
     521   00:414F                          ; ix + 7 -> Year LSB
     522   00:414F                          ; ix + 8 -> Year MSB
     523   00:414F  DD 66 04                ld  h,(ix+4)
     524   00:4152  DD 6E 03                ld  l,(ix+3)
     525   00:4155  DD 56 02                ld  d,(ix+2)
     526   00:4158  CD 7B 5B                call    SET_TIME
     527   00:415B  20 2C                   jr  nz,INIT_NOCLOCKUPDATE       ; if error, just skip
     528   00:415D  DD 66 08                ld  h,(ix+8)
     529   00:4160  DD 6E 07                ld  l,(ix+7)
     530   00:4163  DD 56 06                ld  d,(ix+6)
     531   00:4166  DD 5E 05                ld  e,(ix+5)
     532   00:4169  CD A8 5B                call    SET_DATE
     533   00:416C  3E 02                   ld  a,2
     534   00:416E  DD BE 00                cp  (ix+0)
     535   00:4171  20 16                   jr  nz,INIT_NOCLOCKUPDATE
     536   00:4173                          ; First, release any hold to Wi-Fi Connection
     537   00:4173                          CLEAR_UART
     537   00:4173  3E 14             >     ld  a,20
     537   00:4175  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     538   00:4178  3E 68                   ld  a,CMD_WIFIRELEASE_ESP
     539   00:417A                          SEND_DATA                       ; Just send, no need to wait response
     539   00:417A  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     540   00:417D                          ; And, turn off Wi-Fi Immediatelly
     541   00:417D                          CLEAR_UART
     541   00:417D  3E 14             >     ld  a,20
     541   00:417F  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     542   00:4182  3E 4F                   ld  a,CMD_WIFI_OFF
     543   00:4184                          SEND_DATA                       ; Just send, no need to wait response
     543   00:4184  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     544   00:4187  18 0A                   jr  INIT_NOCLOCKUPDAT2
     545   00:4189                      INIT_NOCLOCKUPDATE:
     546   00:4189                          ; Release any hold to Wi-Fi Connection
     547   00:4189                          CLEAR_UART
     547   00:4189  3E 14             >     ld  a,20
     547   00:418B  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     548   00:418E  3E 68                   ld  a,CMD_WIFIRELEASE_ESP
     549   00:4190                          SEND_DATA                       ; Just send, no need to wait response
     549   00:4190  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     550   00:4193                      INIT_NOCLOCKUPDAT2:
     551   00:4193                          ; Save existing EXTBIO hook if it exists
     552   00:4193  3A 20 FB                ld  a,(HOKVLD)
     553   00:4196  CB 47                   bit 0,a
     554   00:4198  20 0B                   jr  nz,SAVE_HOOK2               ; HOKVLD tells us if there is an extended BIOS already or not, if yes, save it
     555   00:419A                          ; If here, no extended BIOS
     556   00:419A  CD 0C 59                call    GETSLT
     557   00:419D  CD 65 59                call    GETWRK                  ; Our ROM work area address is at HL (we can use up to 8 bytes)
     558   00:41A0  3E C9                   ld  a,#c9                       ; RET, as we are the first extended BIOS
     559   00:41A2  77                      ld  (hl),a
     560   00:41A3  18 13                   jr  PATCH                       ; And now all we need to do is patch the EXTBIO hook :)
     561   00:41A5                      
     562   00:41A5                      SAVE_HOOK2:
     563   00:41A5                          ; If here, we are not the first to extend bios, so we need to save the previous one
     564   00:41A5  CD 0C 59                call    GETSLT
     565   00:41A8  CD 65 59                call    GETWRK                  ; Our ROM work area address is at HL (we can use up to 8 bytes)
     566   00:41AB  EB                      ex  de,hl                       ; It is the destination for....
     567   00:41AC  21 CA FF                ld  hl,EXTBIO                   ; The actual EXTBIO hook
     568   00:41AF  01 05 00                ld  bc,5                        ; That is 5 bytes large
     569   00:41B2  ED B0                   ldir                            ; And move to our work area
     570   00:41B4  AF                      xor a
     571   00:41B5  12                      ld  (de),a                      ; Not initialized (de is at the sixth byte) of our slot work area
     572   00:41B6  13                      inc de
     573   00:41B7  12                      ld  (de),a                      ; Not initialized (de is at the seventh byte) of our slot work area
     574   00:41B8                      
     575   00:41B8                          ; Patch EXTBIO
     576   00:41B8                      PATCH:
     577   00:41B8  3E F7                   ld  a,#F7                       ; RST #30
     578   00:41BA  32 CA FF                ld  (EXTBIO),a                  ; In EXTBIO hook
     579   00:41BD  CD 0C 59                call    GETSLT                  ; Our Slot in A
     580   00:41C0  32 CB FF                ld  (EXTBIO+1),a                ; Next EXTBIO hook byte
     581   00:41C3  21 C3 4C                ld  hl,DO_EXTBIO                ; Our EXTBIO routine address
     582   00:41C6  22 CC FF                ld  (EXTBIO+2),hl               ; Goes to the following two bytes in the hook
     583   00:41C9                      
     584   00:41C9  21 CF FF                ld  hl,EXTBIO+5                 ; Must patch DISINT and ENAINT as well
     585   00:41CC  06 0A                   ld  b,5*2
     586   00:41CE                      PATCH2:
     587   00:41CE  36 C9                   ld  (hl),#C9
     588   00:41D0  23                      inc hl
     589   00:41D1  10 FB                   djnz    PATCH2                  ; So patch all 10 bytes with return
     590   00:41D3                      
     591   00:41D3  21 20 FB                ld  hl,HOKVLD
     592   00:41D6  CB C6                   set 0,(hl)                      ; And set HOKVLD properly to indicate an EXTBIOS is installed
     593   00:41D8                      INIT_OK:
     594   00:41D8                          if  VERBOSE_ROM = 0
     595   00:41D8  21 53 68                ld  hl,OK_S                     ; All done and set, nice exit message
     596   00:41DB  CD 6E 4C                call    PRINTHL
     597   00:41DE                          endif
     598   00:41DE  3E F0                   ld  a,#F0                       ; Set #F0, UNAPI driver has been loaded at least once
     599   00:41E0                          WRITE_F2
     599   00:41E0  32 F2 7F          >     ld  (MEM_PORT_F2),a
     600   00:41E3  C9                      ret
     601   00:41E4                      
     602   00:41E4                      ;==============================
     603   00:41E4                      ;===  TPA Memory Allocation  ==
     604   00:41E4                      ;==============================
     605   00:41E4                      HIMEM_ALLOC:
     606   00:41E4                          ; Now let's reserve memory in the 4th page for our usage
     607   00:41E4  2A 4A FC                ld hl,(HIMEM)                   ; Get HIMEM
     608   00:41E7  B7                      or  a                           ; Clear Carry
     609   00:41E8  11 1E 00                ld  de,HIMEM_RESERVED_SIZE      ; Reserve How much memory we need
     610   00:41EB  ED 52                   sbc hl,de                       ; New HIMEM
     611   00:41ED  22 4A FC                ld  (HIMEM),hl                  ; Save it
     612   00:41F0  23                      inc hl                          ; To be safe
     613   00:41F1  EB                      ex  de,hl                       ; now in DE
     614   00:41F2  CD 0C 59                call    GETSLT
     615   00:41F5  CD 79 59                call    GETMEMPOINTERADDR       ; This is where we are going to store our memory area address
     616   00:41F8                          ; GETSLT and GETMEMPOINTER do not change DE, so it still has the our memory area address
     617   00:41F8  73                      ld  (hl),e
     618   00:41F9  23                      inc hl
     619   00:41FA  72                      ld  (hl),d                      ; And save our memory area there
     620   00:41FB                          ; Ok, DE has our memory area, let's save old H_TIMI hook there
     621   00:41FB  21 9F FD                ld  hl,H_TIMI                   ; The actual H_TIMI hook
     622   00:41FE  01 05 00                ld  bc,5                        ; That is 5 bytes large
     623   00:4201  ED B0                   ldir                            ; And move to our memory area
     624   00:4203  F3                      di                              ; Turn of interrupts as we are going to patch H_TIMI
     625   00:4204                      PATCH_H_TIMI:
     626   00:4204  3E F7                   ld  a,#F7                       ; RST #30
     627   00:4206  32 9F FD                ld  (H_TIMI),a                  ; In H_TIMI hook
     628   00:4209  CD 0C 59                call    GETSLT                  ; Our Slot in A
     629   00:420C  32 A0 FD                ld  (H_TIMI+1),a                ; Next H_TIMI hook byte
     630   00:420F  21 AF 4C                ld  hl,DO_HTIMI                 ; Our H_TIMI routine address
     631   00:4212  22 A1 FD                ld  (H_TIMI+2),hl               ; Goes to the following two bytes in the hook
     632   00:4215  FB                      ei                              ; done, so re-enable interrupts
     633   00:4216                      
     634   00:4216                          ; Set DNS_READY to zero
     635   00:4216  AF                      xor a
     636   00:4217  CD A3 5A                call    SETDNSREADY
     637   00:421A                          ; Set TIME-OUT counter to zero
     638   00:421A  21 00 00                ld  hl,0
     639   00:421D  CD AC 59                call    SETCOUNTER
     640   00:4220  C9                      ret
     641   00:4221                      
     642   00:4221                      ;============================
     643   00:4221                      ;===  SETUP Menu Routines  ==
     644   00:4221                      ;===       Main Menu       ==
     645   00:4221                      ;============================
     646   00:4221                      ESPSETUP.EXIT:
     647   00:4221  3E 0C                   ld  a,CLS
     648   00:4223  CD A2 00                call    CHPUT
     649   00:4226  C3 DA 40                jp  INIT_UNAPI                  ; When done, resume initialization
     650   00:4229                      ENTERING_ESPSETUP:
     651   00:4229  21 D9 5C                ld  hl,ENTERING_WIFI_SETUP
     652   00:422C  CD 6E 4C                call    PRINTHL
     653   00:422F  CD 42 5C                call    PATTERN_SETUP
     654   00:4232  CD E7 49                call    WAIT_250MS_AND_THEN_CONTINUE
     655   00:4235                          ; Hold Wi-Fi Connection On
     656   00:4235                          CLEAR_UART
     656   00:4235  3E 14             >     ld  a,20
     656   00:4237  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     657   00:423A  3E 48                   ld  a,CMD_WIFIHOLD_ESP
     658   00:423C                          SEND_DATA
     658   00:423C  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     659   00:423F  21 3C 00                ld  hl,60                       ; Up to 1s time-out
     660   00:4242  CD 46 4B                call    WAIT_MENU_CMD_RESPONSE  ; Wait response
     661   00:4245                          ; We do not want to error here, just in case user still need to upgrade ESP firmware
     662   00:4245                      ESPSETUP:
     663   00:4245  CD 38 5B                call    RESET_ESP
     664   00:4248  B7                      or  a
     665   00:4249  C2 C2 40                jp  nz,ESP_NOT_FOUND            ; Not well, ESP was not found
     666   00:424C                          ; Well, if reset successful, continue
     667   00:424C  21 F5 5C                ld  hl,WELCOME
     668   00:424F  CD 6E 4C                call    PRINTHL
     669   00:4252  21 F5 5C                ld  hl,WELCOME
     670   00:4255  CD 6E 4C                call    PRINTHL
     671   00:4258  21 43 5D                ld  hl,WELCOME_SF
     672   00:425B  CD 6E 4C                call    PRINTHL                 ; Print Welcome message
     673   00:425E  21 5F 5D                ld  hl,WELCOME_CS
     674   00:4261  CD 6E 4C                call    PRINTHL                 ; Print Wi-Fi is reconnecting to:
     675   00:4264                      ESPSETUP_NEXT:
     676   00:4264  CD 56 01                call    KILBUF                  ; Clear Keyboard Buffer
     677   00:4267  21 89 5D                ld  hl,WELCOME_NEXT
     678   00:426A  CD 6E 4C                call    PRINTHL
     679   00:426D  21 93 5D                ld  hl,WELCOME_SF_NEXT
     680   00:4270  CD 6E 4C                call    PRINTHL                 ; Print Empty Welcome message
     681   00:4273  CD 09 43                call    GET_AP_STAT
     682   00:4276  CA AE 42                jp  z,ESPSETUP_NEXT.1G          ; Won't block in case of error
     683   00:4279                          ; Success, so connection state is in IX+0, then, zero terminated string with SSID starting at IX+1
     684   00:4279  DD 7E 00                ld  a,(ix+0)
     685   00:427C  21 96 5D                ld  hl,WELCOME_CS0_NEXT
     686   00:427F  FE 00                   cp  0
     687   00:4281  28 1F                   jr  z,ESPSETUP_NEXT.2F
     688   00:4283  21 C0 5D                ld  hl,WELCOME_CS1_NEXT
     689   00:4286  FE 01                   cp  1
     690   00:4288  28 18                   jr  z,ESPSETUP_NEXT.2F
     691   00:428A  21 C9 5D                ld  hl,WELCOME_CS2_NEXT
     692   00:428D  FE 02                   cp  2
     693   00:428F  28 11                   jr  z,ESPSETUP_NEXT.2F
     694   00:4291  21 F3 5D                ld  hl,WELCOME_CS3_NEXT
     695   00:4294  FE 03                   cp  3
     696   00:4296  28 0A                   jr  z,ESPSETUP_NEXT.2F
     697   00:4298  21 1D 5E                ld  hl,WELCOME_CS4_NEXT
     698   00:429B  FE 04                   cp  4
     699   00:429D  28 03                   jr  z,ESPSETUP_NEXT.2F
     700   00:429F  21 47 5E                ld  hl,WELCOME_CS5_NEXT
     701   00:42A2                      ESPSETUP_NEXT.2F:
     702   00:42A2  FD 67                   ld  iyh,a                       ; Save current conn status in iyh
     703   00:42A4  CD 6E 4C                call    PRINTHL                 ; Print Status
     704   00:42A7  DD E5                   push    ix
     705   00:42A9  E1                      pop hl
     706   00:42AA  23                      inc hl                          ; HL has AP Name
     707   00:42AB  CD 78 4C                call    PRINTHLINE              ; Print AP Name
     708   00:42AE                      ESPSETUP_NEXT.1G:
     709   00:42AE  21 71 5E                ld  hl,MMENU_S_NEXT
     710   00:42B1  CD 6E 4C                call    PRINTHL                 ; Print Main Menu
     711   00:42B4                      MM_CURSOR_BLINK:
     712   00:42B4  CD F5 42                call    MM_CURSOR_SW            ; Cursor On
     713   00:42B7                      CONN_CHG_LOOP:
     714   00:42B7  CD 9C 00                call    CHSNS
     715   00:42BA  20 13                   jr  nz,MM_WAIT_INPUT            ; If not zero, there is a key in buffer
     716   00:42BC                          ; Ok, there is not, we can check if connection status changed
     717   00:42BC  CD 09 43                call    GET_AP_STAT
     718   00:42BF  CA B7 42                jp  z,CONN_CHG_LOOP             ; Won't block in case of error
     719   00:42C2                          ; Success, so connection state is in IX+0
     720   00:42C2  DD 7E 00                ld  a,(ix+0)
     721   00:42C5  FD BC                   cp  iyh                         ; If same, zero
     722   00:42C7  28 EE                   jr  z,CONN_CHG_LOOP             ; Keep loop
     723   00:42C9  CD F5 42                call    MM_CURSOR_SW            ; Cursor Off
     724   00:42CC  C3 64 42                jp  ESPSETUP_NEXT               ; Changed, re-build menu
     725   00:42CF                      MM_WAIT_INPUT:
     726   00:42CF  CD 9F 00                call    CHGET
     727   00:42D2  FE 1B                   cp  #1b                         ; ESC?
     728   00:42D4  CA 21 42                jp  z,ESPSETUP.EXIT             ; When done, resume initialization
     729   00:42D7  FE 31                   cp  '1'                         ; Setup Nagle?
     730   00:42D9  CA CC 48                jp  z,SET_NAGLE
     731   00:42DC  FE 32                   cp  '2'                         ; Setup Wi-Fi On Period?
     732   00:42DE  CA 06 48                jp  z,SET_WIFI_TIMEOUT
     733   00:42E1  FE 33                   cp  '3'                         ; Scan networks?
     734   00:42E3  CA 56 45                jp  z,START_WIFI_SCAN
     735   00:42E6  FE 34                   cp  '4'                         ; Automatic Setting of Clock?
     736   00:42E8  CA 72 43                jp  z,START_CLK_AUTO
     737   00:42EB  CD C0 00                call    BEEP                    ; Wrong Input, beep
     738   00:42EE  CD F5 42                call    MM_CURSOR_SW            ; Cursor Off
     739   00:42F1  76                      halt
     740   00:42F2  C3 B4 42                jp  MM_CURSOR_BLINK             ; And return, waiting another key
     741   00:42F5                      MM_CURSOR_SW:                       ; Cursor workaround for CONN_CHG_LOOP
     742   00:42F5  3E 1D                   ld  a,GOLEFT
     743   00:42F7  CD A2 00                call    CHPUT
     744   00:42FA  3E 01                   ld  a,1
     745   00:42FC  32 A9 FC                ld  (CSRSW),a
     746   00:42FF  3E 20                   ld  a,' '
     747   00:4301  CD A2 00                call    CHPUT                   ; Switch the cursor display mode
     748   00:4304  AF                      xor a
     749   00:4305  32 A9 FC                ld  (CSRSW),a
     750   00:4308  C9                      ret
     751   00:4309                      GET_AP_STAT:                        ; Use 'call GET_AP_STAT'
     752   00:4309                          CLEAR_UART
     752   00:4309  3E 14             >     ld  a,20
     752   00:430B  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
     753   00:430E  3E 67                   ld  a,CMD_AP_STS
     754   00:4310                          SEND_DATA                       ; Get AP conn status and name
     754   00:4310  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
     755   00:4313  21 3C 00                ld  hl,60                       ; Wait Up To 1s
     756   00:4316  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
     757   00:431A  DD 6B                   ld  ixl,e
     758   00:431C  DD 62                   ld  ixh,d                       ; Address in IX
     759   00:431E  C3 46 4B                jp  WAIT_MENU_CMD_RESPONSE
     760   00:4321                      
     761   00:4321                      ;============================
     762   00:4321                      ;===  SETUP Menu Routines  ==
     763   00:4321                      ;===  Wi-Fi and Clock Menu ==
     764   00:4321                      ;============================
     765   00:4321                      CLK_MSX1_GO:
     766   00:4321  21 60 60                ld  hl,MMENU_CLOCK_MSX1
     767   00:4324  CD 6E 4C                call    PRINTHL                 ; Print Main Clock MSX1 message
     768   00:4327  CD EE 49                call    ISCLKAUTO
     769   00:432A  DD 7E 00                ld  a,(ix+0)                    ; Auto Clock Current setting
     770   00:432D  FE 03                   cp  3                           ; If 3 adapter disabled
     771   00:432F  28 08                   jr  z,CLK_MSX1_ADAPTERDIS
     772   00:4331  21 F4 60                ld  hl,MMENU_CLOCK_0
     773   00:4334  CD 6E 4C                call    PRINTHL
     774   00:4337  18 06                   jr  CLK_MSX1_OPT
     775   00:4339                      CLK_MSX1_ADAPTERDIS:
     776   00:4339  21 3A 61                ld  hl,MMENU_CLOCK_3
     777   00:433C  CD 6E 4C                call    PRINTHL
     778   00:433F                      CLK_MSX1_OPT:
     779   00:433F  21 4D 61                ld  hl,MMENU_CLOCK_OPT
     780   00:4342  CD 6E 4C                call    PRINTHL
     781   00:4345                      CLK_MSX1_WAIT_OPT_INPUT:
     782   00:4345  CD 9F 00                call    CHGET
     783   00:4348  FE 1B                   cp  #1b                         ; ESC?
     784   00:434A  CA 45 42                jp  z,ESPSETUP                  ; Back to main menu
     785   00:434D  FE 30                   cp  '0'
     786   00:434F  CA 5D 43                jp  z,CLK_MSX1_SEND_CMD
     787   00:4352  FE 33                   cp  '3'
     788   00:4354  CA 19 44                jp  z,CLK_AUTO_WAIT_GMT
     789   00:4357  CD C0 00                call    BEEP                    ; Wrong Input, beep
     790   00:435A  C3 45 43                jp  CLK_MSX1_WAIT_OPT_INPUT     ; And return, waiting another key
     791   00:435D                      CLK_MSX1_SEND_CMD:
     792   00:435D  CD A2 00                call    CHPUT                   ; Print option
     793   00:4360  D6 30                   sub '0'                         ; Adjust format
     794   00:4362  DD 77 00                ld  (ix+0),a                    ; Save it
     795   00:4365  3E 0D                   ld  a,#0d
     796   00:4367  CD A2 00                call    CHPUT
     797   00:436A  3E 0A                   ld  a,#0a
     798   00:436C  CD A2 00                call    CHPUT
     799   00:436F  C3 10 45                jp  CLK_AUTO_GMT_CHK_DONE       ; And sending the command will be done there
     800   00:4372                      
     801   00:4372                      START_CLK_AUTO:
     802   00:4372  3E 34                   ld  a,'4'
     803   00:4374  CD A2 00                call    CHPUT
     804   00:4377  CD E7 49                call    WAIT_250MS_AND_THEN_CONTINUE
     805   00:437A  3A 2D 00                ld  a,(#002D)                   ; Check MSX Version
     806   00:437D  B7                      or  a
     807   00:437E  CA 21 43                jp  z,CLK_MSX1_GO               ; If zero, MSX1, so can just enable or disable adapter
     808   00:4381                      CLK_AUTO_GO:
     809   00:4381  21 00 5F                ld  hl,MMENU_CLOCK_MSX2
     810   00:4384  CD 6E 4C                call    PRINTHL                 ; Print Main Clock MSX2 message
     811   00:4387  CD EE 49                call    ISCLKAUTO
     812   00:438A  DD 7E 00                ld  a,(ix+0)                    ; Auto Clock Current setting
     813   00:438D  B7                      or  a                           ; If zero, off
     814   00:438E  20 08                   jr  nz,CLK_AUTO_CHK1
     815   00:4390  21 F4 60                ld  hl,MMENU_CLOCK_0
     816   00:4393  CD 6E 4C                call    PRINTHL
     817   00:4396  18 59                   jr  CLK_AUTO_GMT_OPT
     818   00:4398                      CLK_AUTO_CHK1:
     819   00:4398  3D                      dec a                           ; If 1, on and keep wifi on
     820   00:4399  20 08                   jr  nz,CLK_AUTO_CHK2
     821   00:439B  21 06 61                ld  hl,MMENU_CLOCK_1
     822   00:439E  CD 6E 4C                call    PRINTHL
     823   00:43A1  18 13                   jr  CLK_AUTO_GMT
     824   00:43A3                      CLK_AUTO_CHK2:
     825   00:43A3  3D                      dec a                           ; If 2, on and turn wifi off
     826   00:43A4  20 08                   jr  nz,CLK_AUTO_3
     827   00:43A6  21 20 61                ld  hl,MMENU_CLOCK_2
     828   00:43A9  CD 6E 4C                call    PRINTHL
     829   00:43AC  18 08                   jr  CLK_AUTO_GMT
     830   00:43AE                      CLK_AUTO_3:
     831   00:43AE  21 3A 61                ld  hl,MMENU_CLOCK_3
     832   00:43B1  CD 6E 4C                call    PRINTHL
     833   00:43B4  18 3B                   jr  CLK_AUTO_GMT_OPT
     834   00:43B6                      CLK_AUTO_GMT:
     835   00:43B6  DD 66 01                ld  h,(ix+1)                    ; Save it for now
     836   00:43B9  DD 7E 01                ld  a,(ix+1)                    ; GMT current setting
     837   00:43BC  CB 7F                   bit 7,a                         ; If set, is -
     838   00:43BE  28 0B                   jr  z,CLK_AUTO_GMTP
     839   00:43C0  3E 2D                   ld  a,'-'
     840   00:43C2  CD A2 00                call    CHPUT
     841   00:43C5  DD CB 01 BE             res 7,(ix+1)                    ; Clear - indicator
     842   00:43C9  18 05                   jr  CLK_AUTO_GMTM
     843   00:43CB                      CLK_AUTO_GMTP:
     844   00:43CB  3E 2B                   ld  a,'+'
     845   00:43CD  CD A2 00                call    CHPUT
     846   00:43D0                      CLK_AUTO_GMTM:
     847   00:43D0  3E 09                   ld  a,9
     848   00:43D2  DD BE 01                cp  (ix+1)                      ; Greater than 9?
     849   00:43D5  30 0F                   jr  nc,CLK_AUTO_GMTD            ; If not, just print what is in A + '0'
     850   00:43D7  3E 31                   ld  a,'1'                       ; It is 1
     851   00:43D9  CD A2 00                call    CHPUT
     852   00:43DC  DD 7E 01                ld  a,(ix+1)
     853   00:43DF  C6 26                   add '0'-10                      ; Need to subtract 10 and add '0' to print
     854   00:43E1  CD A2 00                call    CHPUT
     855   00:43E4  18 0B                   jr  CLK_AUTO_GMT_OPT
     856   00:43E6                      CLK_AUTO_GMTD:
     857   00:43E6  3E 30                   ld  a,'0'
     858   00:43E8  DD 86 01                add a,(ix+1)                    ; Our value
     859   00:43EB  CD A2 00                call    CHPUT
     860   00:43EE  DD 74 01                ld  (ix+1),h                    ; Restore original value
     861   00:43F1                      CLK_AUTO_GMT_OPT:
     862   00:43F1  21 4D 61                ld  hl,MMENU_CLOCK_OPT
     863   00:43F4  CD 6E 4C                call    PRINTHL
     864   00:43F7                      CLK_AUTO_WAIT_OPT_INPUT:
     865   00:43F7  CD 9F 00                call    CHGET
     866   00:43FA  FE 1B                   cp  #1b                         ; ESC?
     867   00:43FC  CA 45 42                jp  z,ESPSETUP                  ; Back to main menu
     868   00:43FF  FE 30                   cp  '0'
     869   00:4401  CA 19 44                jp  z,CLK_AUTO_WAIT_GMT
     870   00:4404  FE 31                   cp  '1'
     871   00:4406  CA 19 44                jp  z,CLK_AUTO_WAIT_GMT
     872   00:4409  FE 32                   cp  '2'
     873   00:440B  CA 19 44                jp  z,CLK_AUTO_WAIT_GMT
     874   00:440E  FE 33                   cp  '3'
     875   00:4410  CA 19 44                jp  z,CLK_AUTO_WAIT_GMT
     876   00:4413  CD C0 00                call    BEEP                    ; Wrong Input, beep
     877   00:4416  C3 F7 43                jp  CLK_AUTO_WAIT_OPT_INPUT     ; And return, waiting another key
     878   00:4419                      CLK_AUTO_WAIT_GMT:
     879   00:4419  CD A2 00                call    CHPUT                   ; Print option
     880   00:441C  D6 30                   sub '0'                         ; Adjust format
     881   00:441E  DD 77 00                ld  (ix+0),a                    ; Save it
     882   00:4421  B7                      or  a
     883   00:4422  CA 10 45                jp  z,CLK_AUTO_GMT_CHK_DONE     ; And send the command if just disabling clock auto set
     884   00:4425  FE 03                   cp  3
     885   00:4427  CA 10 45                jp  z,CLK_AUTO_GMT_CHK_DONE     ; Or send the command if just disabling the adapter
     886   00:442A  21 77 61                ld  hl,MMENU_GMT_OPT
     887   00:442D  CD 6E 4C                call    PRINTHL
     888   00:4430  16 00                   ld  d,0                         ; # of digits entered
     889   00:4432  1E 00                   ld  e,0                         ; # of characters printed
     890   00:4434  DD 36 01 00             ld  (ix+1),0                    ; GMT 0
     891   00:4438                      CLK_AUTO_WAIT_GMT_INPUT:
     892   00:4438  CD 9F 00                call    CHGET
     893   00:443B  FE 1B                   cp  #1b                         ; ESC?
     894   00:443D  CA 45 42                jp  z,ESPSETUP                  ; Back to main menu
     895   00:4440  FE 0D                   cp  #0d                         ; ENTER?
     896   00:4442  CA 8B 44                jp  z,CLK_AUTO_GMT_CHK_INPUT    ; Check if ok to send command
     897   00:4445  FE 08                   cp  #08                         ; Backspace?
     898   00:4447  CA 5C 44                jp  z,CLK_AUTO_GMT_CHK_BS       ; Check if there is something to erase
     899   00:444A  FE 2D                   cp  '-'                         ; Negative value?
     900   00:444C  CA 8B 44                jp  z,CLK_AUTO_GMT_CHK_INPUT
     901   00:444F  FE 30                   cp  '0'                         ; >=0?
     902   00:4451  DA 7D 44                jp  c,CLK_AUTO_GMT_BAD_INPUT    ; If not, bad input
     903   00:4454  FE 3A                   cp  '9'+1                       ; <= 9
     904   00:4456  D2 7D 44                jp  nc,CLK_AUTO_GMT_BAD_INPUT   ; If not, bad input
     905   00:4459  C3 8B 44                jp  CLK_AUTO_GMT_CHK_INPUT      ; Otherwise, validate digit
     906   00:445C                      CLK_AUTO_GMT_CHK_BS:
     907   00:445C  AF                      xor a
     908   00:445D  BB                      cp  e                           ; Anything on screen?
     909   00:445E  28 1D                   jr  z,CLK_AUTO_GMT_BAD_INPUT    ; Nothing to erase
     910   00:4460  1D                      dec e                           ; One less character on the screen
     911   00:4461  BA                      cp  d                           ; Any digit?
     912   00:4462  28 03                   jr  z,CLK_AUTO_GMT_CHK_BS_MIN   ; If not, just erase - sign
     913   00:4464                          ; There is, so it is one less digit
     914   00:4464  15                      dec d
     915   00:4465  18 04                   jr  CLK_AUTO_GMT_CHK_DIGIT
     916   00:4467                      CLK_AUTO_GMT_CHK_BS_MIN:
     917   00:4467  DD 36 01 00             ld  (ix+1),0                    ; Reset sign
     918   00:446B                      CLK_AUTO_GMT_CHK_DIGIT:
     919   00:446B  3E 08                   ld  a,8                         ; Backspace
     920   00:446D  CD A2 00                call    CHPUT                   ; Print it
     921   00:4470  3E 20                   ld  a,' '                       ; Space
     922   00:4472  CD A2 00                call    CHPUT                   ; Print it
     923   00:4475  3E 08                   ld  a,8                         ; Backspace
     924   00:4477  CD A2 00                call    CHPUT                   ; Print it
     925   00:447A  C3 38 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; Return
     926   00:447D                      CLK_AUTO_GMT_BAD_INPUT:
     927   00:447D                          ; Beep might use sub rom, and if so, all registers will be messed up, better save
     928   00:447D  C5                      push    bc
     929   00:447E  D5                      push    de
     930   00:447F  F5                      push    af
     931   00:4480  E5                      push    hl
     932   00:4481  CD C0 00                call    BEEP                    ; Wrong Input, beep
     933   00:4484  E1                      pop hl
     934   00:4485  F1                      pop af
     935   00:4486  D1                      pop de
     936   00:4487  C1                      pop bc
     937   00:4488  C3 38 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; And return, waiting another key
     938   00:448B                      CLK_AUTO_GMT_CHK_INPUT:
     939   00:448B  4F                      ld  c,a                         ; Save in C for printing if needed
     940   00:448C  FE 2D                   cp  '-'                         ; - sign?
     941   00:448E  20 11                   jr  nz,CLK_AUTO_GMT_CHK_CR      ; If not, check if enter
     942   00:4490                          ; - sign
     943   00:4490  3E 00                   ld  a,0
     944   00:4492  BB                      cp  e                           ; If not the first character, can't accept
     945   00:4493  20 E8                   jr  nz,CLK_AUTO_GMT_BAD_INPUT
     946   00:4495                          ; It is the first, so let's print it
     947   00:4495  79                      ld  a,c
     948   00:4496  CD A2 00                call    CHPUT
     949   00:4499  DD 36 01 80             ld  (ix+1),0x80                 ; Set the - sign bit, for now rest is zero
     950   00:449D  1C                      inc e                           ; Increase # of characters printed
     951   00:449E  C3 38 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; Continue waiting input
     952   00:44A1                      CLK_AUTO_GMT_CHK_CR:
     953   00:44A1  FE 0D                   cp  #0d                         ; ENTER?
     954   00:44A3  20 0F                   jr  nz,CLK_AUTO_GMT_CHK_CD      ; If not, check if digit is valid
     955   00:44A5                          ; Enter
     956   00:44A5  3E 00                   ld  a,0
     957   00:44A7  BA                      cp  d                           ; Ok, at least one digit entered?
     958   00:44A8  28 D3                   jr  z,CLK_AUTO_GMT_BAD_INPUT    ; No, so, enter is no good now
     959   00:44AA                          ; It is, if it had a digit entered and did not send, it was 1, so...
     960   00:44AA  3E 01                   ld  a,1
     961   00:44AC  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
     962   00:44AF  DD 77 01                ld  (ix+1),a                    ; Save
     963   00:44B2  18 5C                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ok, ready to send
     964   00:44B4                      CLK_AUTO_GMT_CHK_CD:
     965   00:44B4                          ; Ok, it is a digit
     966   00:44B4  06 30                   ld  b,'0'
     967   00:44B6  90                      sub a,b                         ; A has digit value
     968   00:44B7  47                      ld  b,a                         ; Save in B
     969   00:44B8  3E 00                   ld  a,0
     970   00:44BA  BA                      cp  d
     971   00:44BB  20 1E                   jr  nz,CLK_AUTO_GMT_CHK_CSD     ; If not zero, it is second digit, so almost done
     972   00:44BD                          ; 1st digit, let's check if it is other than 1, if it is, we are almost done
     973   00:44BD  3E 01                   ld  a,1
     974   00:44BF  B8                      cp  b
     975   00:44C0  28 10                   jr  z,CLK_AUTO_GMT_CHK_CD.1     ; If it is 1, wait next digit or enter
     976   00:44C2                          ; Not 1, so just adjust ix+1 and go
     977   00:44C2  79                      ld  a,c
     978   00:44C3  CD A2 00                call    CHPUT                   ; Print it
     979   00:44C6  78                      ld  a,b
     980   00:44C7  B7                      or  a
     981   00:44C8  28 03                   jr  z,CLK_AUTO_SKIP_SIGN
     982   00:44CA  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
     983   00:44CD                      CLK_AUTO_SKIP_SIGN:
     984   00:44CD  DD 77 01                ld  (ix+1),a                    ; Save
     985   00:44D0  18 3E                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ok, ready to send
     986   00:44D2                      CLK_AUTO_GMT_CHK_CD.1:
     987   00:44D2  79                      ld  a,c
     988   00:44D3  CD A2 00                call    CHPUT                   ; Print it
     989   00:44D6  14                      inc d                           ; Digits entered now is 1
     990   00:44D7  1C                      inc e                           ; Digits printed increased
     991   00:44D8  C3 38 44                jp  CLK_AUTO_WAIT_GMT_INPUT     ; Continue waiting input
     992   00:44DB                      CLK_AUTO_GMT_CHK_CSD:
     993   00:44DB                          ; Second digit, easy... First was 1, now need to check if it is 0, 1 or 2, otherwise, bad entry
     994   00:44DB  78                      ld  a,b
     995   00:44DC  06 03                   ld  b,3
     996   00:44DE  B8                      cp  b
     997   00:44DF  D2 7D 44                jp  nc,CLK_AUTO_GMT_BAD_INPUT   ; 3 or more, so, not valid
     998   00:44E2  B7                      or  a                           ; Is it zero?
     999   00:44E3  20 0E                   jr  nz,CLK_AUTO_GMT_CHK_CSD1    ; If not, check for 1
    1000   00:44E5                          ; It was zero
    1001   00:44E5  3E 0A                   ld  a,10                        ; So, 10
    1002   00:44E7  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
    1003   00:44EA  DD 77 01                ld  (ix+1),a                    ; Save
    1004   00:44ED  79                      ld  a,c
    1005   00:44EE  CD A2 00                call    CHPUT                   ; Print it
    1006   00:44F1  18 1D                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ready to
    1007   00:44F3                      CLK_AUTO_GMT_CHK_CSD1:
    1008   00:44F3  3D                      dec a                           ; Is it one?
    1009   00:44F4  20 0E                   jr  nz,CLK_AUTO_GMT_CHK_CSD2
    1010   00:44F6                          ; It was one
    1011   00:44F6  3E 0B                   ld  a,11                        ; So, eleven
    1012   00:44F8  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
    1013   00:44FB  DD 77 01                ld  (ix+1),a                    ; Save
    1014   00:44FE  79                      ld  a,c
    1015   00:44FF  CD A2 00                call    CHPUT                   ; Print it
    1016   00:4502  18 0C                   jr  CLK_AUTO_GMT_CHK_DONE       ; Ready to send
    1017   00:4504                      CLK_AUTO_GMT_CHK_CSD2:
    1018   00:4504                          ; It was two
    1019   00:4504  3E 0C                   ld  a,12                        ; So, twelve
    1020   00:4506  DD B6 01                or  a,(ix+1)                    ; Adjust sign, if needed
    1021   00:4509  DD 77 01                ld  (ix+1),a                    ; Save
    1022   00:450C  79                      ld  a,c
    1023   00:450D  CD A2 00                call    CHPUT                   ; Print it
    1024   00:4510                          ; And send command
    1025   00:4510                      CLK_AUTO_GMT_CHK_DONE:
    1026   00:4510  3E 0D                   ld  a,#0d
    1027   00:4512  CD A2 00                call    CHPUT
    1028   00:4515  3E 0A                   ld  a,#0a
    1029   00:4517  CD A2 00                call    CHPUT
    1030   00:451A  21 38 67                ld  hl,STR_SENDING
    1031   00:451D  CD 6E 4C                call    PRINTHL
    1032   00:4520                          CLEAR_UART
    1032   00:4520  3E 14             >     ld  a,20
    1032   00:4522  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1033   00:4525  3E 43                   ld  a,CMD_SET_ACLK_SETTINGS
    1034   00:4527                          SEND_DATA
    1034   00:4527  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1035   00:452A  3E 00                   ld  a,0                         ; Size MSB is 0
    1036   00:452C                          SEND_DATA
    1036   00:452C  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1037   00:452F  3E 02                   ld  a,2                         ; Size LSB is 2
    1038   00:4531                          SEND_DATA
    1038   00:4531  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1039   00:4534  DD 7E 00                ld  a,(ix+0)                    ; Option
    1040   00:4537                          SEND_DATA
    1040   00:4537  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1041   00:453A  DD 7E 01                ld  a,(ix+1)                    ; GMT
    1042   00:453D                          SEND_DATA
    1042   00:453D  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1043   00:4540  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1044   00:4543  3E 43                   ld  a,CMD_SET_ACLK_SETTINGS
    1045   00:4545  CD 09 4B                call    WAIT_MENU_QCMD_RESPONSE
    1046   00:4548  21 53 67                ld  hl,STR_SENDING_OK
    1047   00:454B  20 03                   jr  nz,CLK_AUTO_GMT_CHK_RESULT
    1048   00:454D  21 D0 67                ld  hl,STR_SENDING_FAIL
    1049   00:4550                      CLK_AUTO_GMT_CHK_RESULT:
    1050   00:4550  CD 6E 4C                call    PRINTHL
    1051   00:4553  C3 DF 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1052   00:4556                      
    1053   00:4556                      ;============================
    1054   00:4556                      ;===  SETUP Menu Routines  ==
    1055   00:4556                      ;===    Wi-Fi Scan Menu    ==
    1056   00:4556                      ;============================
    1057   00:4556                      START_WIFI_SCAN:
    1058   00:4556  3E 33                   ld  a,'3'
    1059   00:4558  CD A2 00                call    CHPUT
    1060   00:455B  CD E7 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1061   00:455E                      START_WIFI_RESCAN:
    1062   00:455E  21 0C 62                ld  hl,MMENU_SCAN
    1063   00:4561  CD 6E 4C                call    PRINTHL                 ; Print Main Scan message
    1064   00:4564  CD 8C 49                call    STARTWIFISCAN           ; Request Wi-Fi Scan to start
    1065   00:4567  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1066   00:456B  DD 6B                   ld  ixl,e
    1067   00:456D  DD 62                   ld  ixh,d                       ; Address in IX
    1068   00:456F  11 14 00                ld  de,20                       ; At least 10s waiting scan to finish, retry 20 times waiting 0.5s between attempts
    1069   00:4572                      WIFI_SCAN_WAIT_END:
    1070   00:4572                          CLEAR_UART
    1070   00:4572  3E 14             >     ld  a,20
    1070   00:4574  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1071   00:4577  3E 73                   ld  a,CMD_SCAN_RESULTS
    1072   00:4579                          SEND_DATA
    1072   00:4579  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1073   00:457C  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1074   00:457F  CD D7 4B                call    WAIT_MENU_SCMD_RESPONSE
    1075   00:4582  C2 9A 45                jp  nz,WIFI_SCAN_SHOW_LIST      ; if success show the list
    1076   00:4585  78                      ld  a,b
    1077   00:4586  FE 02                   cp  2                           ; If 2, scan is done and nothing found
    1078   00:4588  CA F4 47                jp  z,WIFI_SCAN_NONETWORKS
    1079   00:458B  2E 1E                   ld  l,30
    1080   00:458D                      WIFI_SCAN_WAITHS:
    1081   00:458D  76                      halt
    1082   00:458E  2D                      dec l
    1083   00:458F  20 FC                   jr  nz,WIFI_SCAN_WAITHS
    1084   00:4591  1B                      dec de
    1085   00:4592  7B                      ld  a,e
    1086   00:4593  B2                      or  d
    1087   00:4594  CA FD 47                jp  z,WIFI_SCAN_TIMEOUT
    1088   00:4597  C3 72 45                jp  WIFI_SCAN_WAIT_END
    1089   00:459A                      WIFI_SCAN_SHOW_LIST:
    1090   00:459A  57                      ld  d,a                         ; Save access point counter here
    1091   00:459B  1E 00                   ld  e,0                         ; And here how many were printed
    1092   00:459D  21 91 62                ld  hl,MMENU_SCANS
    1093   00:45A0  CD 6E 4C                call    PRINTHL
    1094   00:45A3  DD E5                   push    ix
    1095   00:45A5  E1                      pop hl                          ; IX in HL
    1096   00:45A6                      WIFI_LIST_LOOP:
    1097   00:45A6  7B                      ld  a,e
    1098   00:45A7  C6 30                   add a,'0'                       ; Convert to number
    1099   00:45A9  CD A2 00                call    CHPUT
    1100   00:45AC  3E 20                   ld  a,' '                       ; Space
    1101   00:45AE  CD A2 00                call    CHPUT
    1102   00:45B1  3E 2D                   ld  a,'-'                       ; Dash
    1103   00:45B3  CD A2 00                call    CHPUT
    1104   00:45B6  3E 20                   ld  a,' '                       ; Space
    1105   00:45B8  CD A2 00                call    CHPUT
    1106   00:45BB  06 18                   ld  b,24                        ; Cuts AP names > 23 chars
    1107   00:45BD                      PRT_APNAMELP:
    1108   00:45BD  7E                      ld  a,(hl)
    1109   00:45BE  B7                      or  a
    1110   00:45BF  CA D9 45                jp  z,PRT_APENC
    1111   00:45C2  CD A2 00                call    CHPUT
    1112   00:45C5  23                      inc hl
    1113   00:45C6  10 F5                   djnz    PRT_APNAMELP
    1114   00:45C8  E5                      push    hl
    1115   00:45C9  21 28 64                ld  hl,SCAN_TERMINATOR_CUT
    1116   00:45CC  CD 6E 4C                call    PRINTHL
    1117   00:45CF  E1                      pop hl
    1118   00:45D0                      PRT_APNAMELP_CUT:
    1119   00:45D0  7E                      ld  a,(hl)
    1120   00:45D1  B7                      or  a
    1121   00:45D2  CA D9 45                jp  z,PRT_APENC
    1122   00:45D5  23                      inc hl
    1123   00:45D6  C3 D0 45                jp  PRT_APNAMELP_CUT
    1124   00:45D9                      PRT_APENC:
    1125   00:45D9  23                      inc hl
    1126   00:45DA  7E                      ld  a,(hl)
    1127   00:45DB  B7                      or  a
    1128   00:45DC  CA EA 45                jp  z,PRT_APNOTENC
    1129   00:45DF  E5                      push    hl
    1130   00:45E0  21 36 64                ld  hl,SCAN_TERMINATOR_ENC
    1131   00:45E3  CD 6E 4C                call    PRINTHL
    1132   00:45E6  E1                      pop hl
    1133   00:45E7  C3 F2 45                jp  PRT_AP_CHKLOOP
    1134   00:45EA                      PRT_APNOTENC:
    1135   00:45EA  E5                      push    hl
    1136   00:45EB  21 2F 64                ld  hl,SCAN_TERMINATOR_OPEN
    1137   00:45EE  CD 6E 4C                call    PRINTHL
    1138   00:45F1  E1                      pop hl
    1139   00:45F2                      PRT_AP_CHKLOOP:
    1140   00:45F2  23                      inc hl
    1141   00:45F3  1C                      inc e
    1142   00:45F4  3E 08                   ld  a,SCAN_MAX_PAGE_SIZE
    1143   00:45F6  BB                      cp  e
    1144   00:45F7  CA 02 46                jp  z,APLIST_OVERFLOW
    1145   00:45FA  15                      dec d
    1146   00:45FB  C2 A6 45                jp  nz,WIFI_LIST_LOOP
    1147   00:45FE  06 00                   ld  b,0                         ; Signal no more list data
    1148   00:4600  18 10                   jr  APLIST_NO_OVERFLOW
    1149   00:4602                      APLIST_OVERFLOW:
    1150   00:4602  15                      dec d                           ; Update remaining items
    1151   00:4603  AF                      xor a
    1152   00:4604  B2                      or  d                           ; Still has items?
    1153   00:4605  28 0B                   jr  z,APLIST_NO_OVERFLOW        ; No more items
    1154   00:4607  06 01                   ld  b,1                         ; Signal that there still is data pending to list in another page
    1155   00:4609  E5                      push    hl
    1156   00:460A  FD E1                   pop iy                          ; Save in IY the address to continue from
    1157   00:460C  4A                      ld  c,d                         ; And C has the remaining AP count
    1158   00:460D  21 B9 63                ld  hl,MMENU_SCANQM
    1159   00:4610  18 03                   jr  APLIST_NOFLW
    1160   00:4612                      APLIST_NO_OVERFLOW:
    1161   00:4612                          ; If here, current page has been printed
    1162   00:4612                          ; E has the maximum allowable AP number
    1163   00:4612                          ; B will indicate if there are more items for a next page
    1164   00:4612                          ; IY will hold the address of the following items
    1165   00:4612                          ; Let's ask which one to connect
    1166   00:4612  21 4E 63                ld  hl,MMENU_SCANQ
    1167   00:4615                      APLIST_NOFLW:
    1168   00:4615  CD 6E 4C                call    PRINTHL                 ; Show message asking which network to connect
    1169   00:4618  3E 30                   ld  a,'0'
    1170   00:461A  83                      add a,e
    1171   00:461B  5F                      ld  e,a                         ; To make it easy in the selection screen
    1172   00:461C                      WIFI_SELECT_AP:
    1173   00:461C  CD 9F 00                call    CHGET
    1174   00:461F  FE 1B                   cp  #1b                         ; ESC?
    1175   00:4621  CA 45 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1176   00:4624  FE 20                   cp  #20                         ; Spacebar?
    1177   00:4626  CA 3A 46                jp  z,WIFI_SELECT_SPACEBAR      ; Check if re-scan or next page
    1178   00:4629  FE 0D                   cp  CR                          ; ENTER?
    1179   00:462B  CA 47 46                jp  z,WIFI_CONNECT_ME_CHOOSEN   ; Request AP Name and Password if needed
    1180   00:462E  FE 30                   cp  '0'                         ; Check if A is less than 0
    1181   00:4630  DA DE 47                jp  c,INPUT_WFSAP_BAD_INPUT     ; If it is, ignore
    1182   00:4633  BB                      cp  e                           ; Check if a is greater than what is in E
    1183   00:4634  D2 DE 47                jp  nc,INPUT_WFSAP_BAD_INPUT    ; If it is, ignore
    1184   00:4637  C3 D1 46                jp  WIFI_CONNECT_SELECTION_OK   ; Selection Ok if here
    1185   00:463A                      
    1186   00:463A                      WIFI_SELECT_SPACEBAR:
    1187   00:463A  AF                      xor a
    1188   00:463B  B2                      or  d                           ; D = AP counter
    1189   00:463C  CA 5E 45                jp  z,START_WIFI_RESCAN         ; Rescan if no more items
    1190   00:463F                          ; Otherwise, more items, start at IY
    1191   00:463F  FD E5                   push    iy
    1192   00:4641  DD E1                   pop ix                          ; Restore the list from where we finished last time
    1193   00:4643  79                      ld  a,c                         ; Restore the remaining APs to list
    1194   00:4644  C3 9A 45                jp  WIFI_SCAN_SHOW_LIST         ; And show
    1195   00:4647                      
    1196   00:4647                      WIFI_CONNECT_ME_CHOOSEN:
    1197   00:4647  21 90 61                ld  hl,MMENU_MANUALENTRY
    1198   00:464A  CD 6E 4C                call    PRINTHL                 ; Show message asking AP details....
    1199   00:464D                          ; IX has the AP list, we don't care, but that address is ours to use to handle SSID Entry
    1200   00:464D  DD E5                   push    ix
    1201   00:464F  E1                      pop hl                          ; HL has the address
    1202   00:4650  0E 00                   ld  c,0                         ; AP name size
    1203   00:4652                      WIFI_CONNECT_MANUAL_ENTRY:
    1204   00:4652  CD 9F 00                call    CHGET
    1205   00:4655  FE 1B                   cp  #1b                         ; ESC?
    1206   00:4657  CA 45 42                jp  z,ESPSETUP                  ; Back to main setup
    1207   00:465A  FE 08                   cp  #08                         ; Backspace?
    1208   00:465C  28 55                   jr  z,WIFI_CONNECT_ME_BS        ; Check if there is something to erase
    1209   00:465E  FE 0D                   cp  #0d                         ; ENTER?
    1210   00:4660  28 68                   jr  z,WIFI_ME_CHECK_INPUT       ; Check if ok
    1211   00:4662                          ; Otherwise it is a digit
    1212   00:4662  77                      ld  (hl),a
    1213   00:4663  79                      ld  a,c
    1214   00:4664  D6 20                   sub 32                          ; SSID maximum is 32 characters
    1215   00:4666  28 EA                   jr  z,WIFI_CONNECT_MANUAL_ENTRY
    1216   00:4668  7E                      ld  a,(hl)
    1217   00:4669  0C                      inc c
    1218   00:466A  23                      inc hl
    1219   00:466B  FE 20                   cp  32
    1220   00:466D  30 04                   jr  nc,WIFI_CONNECT_ME_CHKPRT2  ; Ok, not below space, but is it delete?
    1221   00:466F  3E 3F                   ld  a,'?'                       ; Prints a question mark
    1222   00:4671  18 06                   jr  WIFI_CONNECT_ME_CHKPRTD
    1223   00:4673                      WIFI_CONNECT_ME_CHKPRT2:
    1224   00:4673  FE 7F                   cp  #7f
    1225   00:4675  20 02                   jr  nz,WIFI_CONNECT_ME_CHKPRTD
    1226   00:4677  3E 3F                   ld  a,'?'                       ; Prints a question mark if it is delete
    1227   00:4679                      WIFI_CONNECT_ME_CHKPRTD:
    1228   00:4679  CD A2 00                call    CHPUT                   ; Print a char
    1229   00:467C  C3 52 46                jp  WIFI_CONNECT_MANUAL_ENTRY
    1230   00:467F                      WIFI_CONNECT_ME_0_TERM:
    1231   00:467F  AF                      xor a
    1232   00:4680  77                      ld  (hl),a
    1233   00:4681  23                      inc hl
    1234   00:4682  E5                      push    hl                      ; Save it
    1235   00:4683  21 F1 61                ld  hl,MENU_MANUALENTRY_PWD
    1236   00:4686  CD 6E 4C                call    PRINTHL                 ; We are asking if password is needed
    1237   00:4689  E1                      pop hl                          ; Restore it
    1238   00:468A  CD 9F 00                call    CHGET                   ; Get key, if Y or y, needed, otherwise not
    1239   00:468D  CB AF                   res 5,a                         ; Force upper case
    1240   00:468F  FE 59                   cp  'Y'
    1241   00:4691  28 08                   jr  z,WIFI_CONNECT_ME_PWD_Y     ; And tell using encryption
    1242   00:4693  3E 6E                   ld  a,'n'
    1243   00:4695  CD A2 00                call    CHPUT                   ; Overwrite what was typed with 'n'
    1244   00:4698  AF                      xor a                           ; Ok, if here, no pwd, so no encryption
    1245   00:4699  18 07                   jr  WIFI_CONNECT_ME_PWD
    1246   00:469B                      WIFI_CONNECT_ME_PWD_Y:
    1247   00:469B  3E 79                   ld  a,'y'
    1248   00:469D  CD A2 00                call    CHPUT                   ; Print 'y'
    1249   00:46A0  3E 01                   ld  a,1                         ; Do not change flags, pwd needed
    1250   00:46A2                      WIFI_CONNECT_ME_PWD:
    1251   00:46A2  77                      ld  (hl),a                      ; Save if encryption is expected
    1252   00:46A3  DD E5                   push    ix
    1253   00:46A5  E1                      pop hl                          ; HL containing the beginning of SSID name
    1254   00:46A6  3E 0D                   ld  a,#0d
    1255   00:46A8  CD A2 00                call    CHPUT
    1256   00:46AB  3E 0A                   ld  a,#0a
    1257   00:46AD  CD A2 00                call    CHPUT
    1258   00:46B0  C3 F5 46                jp  WIFI_CONNECT_AP_PWDQ        ; And the rest is handled like if menu selected
    1259   00:46B3                      WIFI_CONNECT_ME_BS:
    1260   00:46B3  AF                      xor a
    1261   00:46B4  B9                      cp  c                           ; Has any data to delete?
    1262   00:46B5  28 9B                   jr  z,WIFI_CONNECT_MANUAL_ENTRY ; No
    1263   00:46B7                          ; Yes
    1264   00:46B7  2B                      dec hl                          ; Decrement pointer
    1265   00:46B8  0D                      dec c                           ; Decrement counter
    1266   00:46B9  3E 08                   ld  a,8                         ; Backspace
    1267   00:46BB  CD A2 00                call    CHPUT                   ; Print it
    1268   00:46BE  3E 20                   ld  a,' '                       ; Space
    1269   00:46C0  CD A2 00                call    CHPUT                   ; Print it
    1270   00:46C3  3E 08                   ld  a,8                         ; Backspace
    1271   00:46C5  CD A2 00                call    CHPUT                   ; Print it
    1272   00:46C8  18 88                   jr  WIFI_CONNECT_MANUAL_ENTRY   ; Return
    1273   00:46CA                      WIFI_ME_CHECK_INPUT:
    1274   00:46CA  AF                      xor a
    1275   00:46CB  B9                      cp  c                           ; Has received any data?
    1276   00:46CC  28 84                   jr  z,WIFI_CONNECT_MANUAL_ENTRY ; No
    1277   00:46CE  C3 7F 46                jp  WIFI_CONNECT_ME_0_TERM      ; Yes, so handle SSID input termination
    1278   00:46D1                      
    1279   00:46D1                      WIFI_CONNECT_SELECTION_OK:
    1280   00:46D1  CD A2 00                call    CHPUT                   ; Valid input, print it
    1281   00:46D4  1E 30                   ld  e,'0'
    1282   00:46D6  93                      sub a,e                         ; Get in decimal
    1283   00:46D7  5F                      ld  e,a                         ; Back in E
    1284   00:46D8                          ; IX has the AP list, A which one has been selected, now our routine will do it
    1285   00:46D8  3E 0D                   ld  a,#0d
    1286   00:46DA  CD A2 00                call    CHPUT
    1287   00:46DD  3E 0A                   ld  a,#0a
    1288   00:46DF  CD A2 00                call    CHPUT
    1289   00:46E2  DD E5                   push    ix
    1290   00:46E4  E1                      pop hl                          ; put IX in HL
    1291   00:46E5                      WIFI_CONNECT_AP_SRCH:
    1292   00:46E5  7B                      ld  a,e
    1293   00:46E6  B7                      or  a
    1294   00:46E7                      WIFI_CONNECT_AP_SRCH.1:
    1295   00:46E7  CA F5 46                jp  z,WIFI_CONNECT_AP_PWDQ
    1296   00:46EA  7E                      ld  a,(hl)
    1297   00:46EB  23                      inc hl
    1298   00:46EC  B7                      or  a
    1299   00:46ED  C2 E7 46                jp  nz,WIFI_CONNECT_AP_SRCH.1   ; Find string terminator
    1300   00:46F0                          ; Found, jump encryption byte
    1301   00:46F0  23                      inc hl
    1302   00:46F1  1D                      dec e                           ; Decrement selection, if 0 we are done
    1303   00:46F2  C2 E7 46                jp  nz,WIFI_CONNECT_AP_SRCH.1
    1304   00:46F5                      WIFI_CONNECT_AP_PWDQ:
    1305   00:46F5                          ; HL has the address of AP name string
    1306   00:46F5  54                      ld  d,h
    1307   00:46F6  5D                      ld  e,l                         ; Save copy in D
    1308   00:46F7  01 00 00                ld  bc,0                        ; BC will have the ap connection data length
    1309   00:46FA                      WIFI_CONNECT_APSIZE:
    1310   00:46FA  03                      inc bc
    1311   00:46FB  1A                      ld  a,(de)
    1312   00:46FC  13                      inc de
    1313   00:46FD  B7                      or  a
    1314   00:46FE  C2 FA 46                jp  nz,WIFI_CONNECT_APSIZE      ; Count size, including zero terminator
    1315   00:4701                          ; Check for encryption
    1316   00:4701  1A                      ld  a,(de)
    1317   00:4702  B7                      or  a
    1318   00:4703  CA 94 47                jp  z,WIFI_CONNECT_SENDCMD      ; If no password requested, good to go
    1319   00:4706                          ; Shoot, need to request password, well, let's do it
    1320   00:4706  E5                      push    hl                      ; Save HL
    1321   00:4707  21 0B 63                ld  hl,MMENU_ASKPWD
    1322   00:470A  CD 6E 4C                call    PRINTHL                 ; Inform that user need to input PWD
    1323   00:470D  E1                      pop hl                          ; Restore HL
    1324   00:470E  FD 21 00 00             ld  iy,0                        ; IY will help in backspacing
    1325   00:4712  DD 26 01                ld  ixh,1                       ; Start hidden
    1326   00:4715                      WIFI_CONNECT_RCV_PWD:
    1327   00:4715  CD 9F 00                call    CHGET
    1328   00:4718  FE 1B                   cp  #1b                         ; ESC?
    1329   00:471A  CA 45 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1330   00:471D  FE 08                   cp  #08                         ; Backspace?
    1331   00:471F  CA 70 47                jp  z,WIFI_CONNECT_RCV_PWD_BS   ; Check if there is something to erase
    1332   00:4722  FE 0D                   cp  #0d                         ; ENTER?
    1333   00:4724  CA 8D 47                jp  z,WIFI_PWD_CHECK_INPUT      ; Check if ok
    1334   00:4727  FE 7F                   cp  #7f                         ; Delete?
    1335   00:4729  CA 5C 47                jp  z,WIFI_CONNECT_RCV_PWDH     ; Change password from clear to hidden or vice versa
    1336   00:472C                      WIFI_CONNECT_RCV_PWD_STR:
    1337   00:472C                          ; Ok, so it is a digit and store
    1338   00:472C  12                      ld  (de),a
    1339   00:472D  FD 7D                   ld  a,iyl
    1340   00:472F  D6 3F                   sub 63                          ; 63 chars password limit (WPA2 encryption)
    1341   00:4731  28 E2                   jr  z,WIFI_CONNECT_RCV_PWD
    1342   00:4733  1A                      ld  a,(de)
    1343   00:4734  03                      inc bc
    1344   00:4735  13                      inc de
    1345   00:4736  FD 23                   inc iy                          ; Increment counters and pointer
    1346   00:4738  F5                      push    af                      ; Save A
    1347   00:4739  DD 7C                   ld  a,ixh
    1348   00:473B  B7                      or  a                           ; If zero, print char, otherwise print *
    1349   00:473C  28 09                   jr  z,WIFI_CONNECT_RCV_PWD_CHAR
    1350   00:473E  F1                      pop af
    1351   00:473F  3E 2A                   ld  a,'*'                       ; Print * and keep password hidden
    1352   00:4741  CD A2 00                call    CHPUT
    1353   00:4744  C3 15 47                jp  WIFI_CONNECT_RCV_PWD        ; And back to receiving digits
    1354   00:4747                      WIFI_CONNECT_RCV_PWD_CHAR:
    1355   00:4747  F1                      pop af
    1356   00:4748  FE 20                   cp  32
    1357   00:474A  30 04                   jr  nc,WIFI_CONNECT_RCV_CHKPRT2 ; Ok, not below space, but is it delete?
    1358   00:474C  3E 3F                   ld  a,'?'                       ; Prints a question mark
    1359   00:474E  18 06                   jr  WIFI_CONNECT_RCV_CHKPRTD
    1360   00:4750                      WIFI_CONNECT_RCV_CHKPRT2:
    1361   00:4750  FE 7F                   cp  #7f
    1362   00:4752  20 02                   jr  nz,WIFI_CONNECT_RCV_CHKPRTD
    1363   00:4754  3E 3F                   ld  a,'?'                       ; Prints a question mark if it is delete
    1364   00:4756                      WIFI_CONNECT_RCV_CHKPRTD:
    1365   00:4756  CD A2 00                call    CHPUT                   ; Print a char
    1366   00:4759  C3 15 47                jp  WIFI_CONNECT_RCV_PWD        ; And back to receiving digits
    1367   00:475C                      
    1368   00:475C                      WIFI_CONNECT_RCV_PWDH:
    1369   00:475C  FD 7D                   ld  a,iyl
    1370   00:475E  FD B4                   or  iyh
    1371   00:4760  C2 2C 47                jp  nz,WIFI_CONNECT_RCV_PWD_STR ; If digits entered, can't change password behavior, so it is a pass phrase char
    1372   00:4763  AF                      xor a
    1373   00:4764  DD B4                   or  ixh
    1374   00:4766  DD 26 01                ld  ixh,1
    1375   00:4769  28 AA                   jr  z,WIFI_CONNECT_RCV_PWD      ; Return if it was 0
    1376   00:476B  DD 26 00                ld  ixh,0
    1377   00:476E  28 A5                   jr  z,WIFI_CONNECT_RCV_PWD      ; Otherwise set to 0 and return
    1378   00:4770                      
    1379   00:4770                      WIFI_CONNECT_RCV_PWD_BS:
    1380   00:4770  FD 7D                   ld  a,iyl
    1381   00:4772  FD B4                   or  iyh
    1382   00:4774  CA 15 47                jp  z,WIFI_CONNECT_RCV_PWD      ; If no digits entered, nothing to erase
    1383   00:4777  FD 2B                   dec iy                          ; Decrement counter
    1384   00:4779  0B                      dec bc                          ; Decrement counter
    1385   00:477A  1B                      dec de                          ; Decrement pointer
    1386   00:477B  3E 08                   ld  a,8                         ; Backspace
    1387   00:477D  CD A2 00                call    CHPUT                   ; Print it
    1388   00:4780  3E 20                   ld  a,' '                       ; Space
    1389   00:4782  CD A2 00                call    CHPUT                   ; Print it
    1390   00:4785  3E 08                   ld  a,8                         ; Backspace
    1391   00:4787  CD A2 00                call    CHPUT                   ; Print it
    1392   00:478A  C3 15 47                jp  WIFI_CONNECT_RCV_PWD        ; Return
    1393   00:478D                      
    1394   00:478D                      WIFI_PWD_CHECK_INPUT:
    1395   00:478D  FD 7D                   ld  a,iyl
    1396   00:478F  FD B4                   or  iyh
    1397   00:4791  CA 15 47                jp  z,WIFI_CONNECT_RCV_PWD      ; If no digits entered, no password to send
    1398   00:4794                          ; Otherwise done and ready to send
    1399   00:4794                      WIFI_CONNECT_SENDCMD:
    1400   00:4794  CD E7 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1401   00:4797  E5                      push    hl
    1402   00:4798  21 C7 62                ld  HL,MMENU_CONNECTING
    1403   00:479B  CD 6E 4C                call    PRINTHL
    1404   00:479E  E1                      pop hl
    1405   00:479F                          ; Print AP name
    1406   00:479F  E5                      push    hl
    1407   00:47A0  CD 78 4C                call    PRINTHLINE              ; Print AP Name
    1408   00:47A3  E1                      pop hl
    1409   00:47A4                          ; HL has the address of our data, BC the data size, so it is just needed to send the command
    1410   00:47A4                          CLEAR_UART
    1410   00:47A4  3E 14             >     ld  a,20
    1410   00:47A6  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1411   00:47A9  3E 41                   ld  a,CMD_WIFI_CONNECT
    1412   00:47AB                          SEND_DATA
    1412   00:47AB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1413   00:47AE  78                      ld  a,b                         ; Size MSB is in B
    1414   00:47AF                          SEND_DATA
    1414   00:47AF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1415   00:47B2  79                      ld  a,c                         ; Size LSB is in c
    1416   00:47B3                          SEND_DATA
    1416   00:47B3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1417   00:47B6                      WIFI_CONNECT_SENDCMDLP:
    1418   00:47B6  7E                      ld  a,(hl)
    1419   00:47B7                          SEND_DATA
    1419   00:47B7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1420   00:47BA  23                      inc hl
    1421   00:47BB  0B                      dec bc
    1422   00:47BC  78                      ld  a,b
    1423   00:47BD  B1                      or  c
    1424   00:47BE  C2 B6 47                jp  nz,WIFI_CONNECT_SENDCMDLP
    1425   00:47C1  21 58 02                ld  hl,600                      ; Wait Up To 10s
    1426   00:47C4  3E 41                   ld  a,CMD_WIFI_CONNECT          ; Our command
    1427   00:47C6  CD 09 4B                call    WAIT_MENU_QCMD_RESPONSE
    1428   00:47C9  CA D5 47                jp  z,WIFI_CONNECT_FAIL
    1429   00:47CC  21 6C 67                ld  hl,STR_SENDING_OK_JN        ; Success
    1430   00:47CF  CD 6E 4C                call    PRINTHL
    1431   00:47D2  C3 DF 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1432   00:47D5                      WIFI_CONNECT_FAIL:
    1433   00:47D5  21 8E 67                ld  hl,STR_SENDING_NOK_JN       ; Failure
    1434   00:47D8  CD 6E 4C                call    PRINTHL
    1435   00:47DB  C3 DB 49                jp  WAIT_4S_AND_THEN_MAINMENU
    1436   00:47DE                      
    1437   00:47DE                      INPUT_WFSAP_BAD_INPUT:
    1438   00:47DE  C5                      push    bc
    1439   00:47DF  D5                      push    de
    1440   00:47E0  F5                      push    af
    1441   00:47E1  E5                      push    hl
    1442   00:47E2  DD E5                   push    ix
    1443   00:47E4  FD E5                   push    iy
    1444   00:47E6  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1445   00:47E9  FD E1                   pop iy
    1446   00:47EB  DD E1                   pop ix
    1447   00:47ED  E1                      pop hl
    1448   00:47EE  F1                      pop af
    1449   00:47EF  D1                      pop de
    1450   00:47F0  C1                      pop bc
    1451   00:47F1  C3 1C 46                jp WIFI_SELECT_AP               ; Return
    1452   00:47F4                      
    1453   00:47F4                      WIFI_SCAN_NONETWORKS:
    1454   00:47F4  21 7A 62                ld  hl,MMENU_SCANN
    1455   00:47F7  CD 6E 4C                call    PRINTHL
    1456   00:47FA  C3 DB 49                jp  WAIT_4S_AND_THEN_MAINMENU
    1457   00:47FD                      
    1458   00:47FD                      WIFI_SCAN_TIMEOUT:
    1459   00:47FD  21 5A 62                ld  hl,MMENU_SCANF
    1460   00:4800  CD 6E 4C                call    PRINTHL
    1461   00:4803  C3 DB 49                jp  WAIT_4S_AND_THEN_MAINMENU
    1462   00:4806                      
    1463   00:4806                      SET_WIFI_TIMEOUT:
    1464   00:4806  3E 32                   ld  a,'2'
    1465   00:4808  CD A2 00                call    CHPUT
    1466   00:480B  CD E7 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1467   00:480E  21 3D 64                ld  hl,MMENU_TIMEOUT
    1468   00:4811  CD 6E 4C                call    PRINTHL                 ; Print Main Timeout message
    1469   00:4814  CD 58 4A                call    CHECKTIMEOUT            ; TimeOut is on or off?
    1470   00:4817  CA 2F 48                jp  z,WIFI_SET_ALWAYS_ON        ; If 0, always on
    1471   00:481A                          ; Otherwise there is a timeout
    1472   00:481A  E5                      push    hl
    1473   00:481B  21 74 65                ld hl,MMENU_TIMEOUT_NOTALWAYSON1
    1474   00:481E  CD 6E 4C                call    PRINTHL
    1475   00:4821  E1                      pop hl
    1476   00:4822  CD 6E 4C                call    PRINTHL
    1477   00:4825  21 8A 65                ld hl,MMENU_TIMEOUT_NOTALWAYSON2
    1478   00:4828  CD 6E 4C                call    PRINTHL
    1479   00:482B  16 00                   ld  d,0                         ; Count digits
    1480   00:482D  18 10                   jr  INPUT_TIMEOUT
    1481   00:482F                      WIFI_SET_ALWAYS_ON:
    1482   00:482F  21 1F 65                ld  hl,MMENU_TIMEOUT_ALWAYSON
    1483   00:4832  CD 6E 4C                call    PRINTHL
    1484   00:4835  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1485   00:4839  DD 6B                   ld  ixl,e
    1486   00:483B  DD 62                   ld  ixh,d                       ; Address in IX
    1487   00:483D  16 00                   ld  d,0                         ; Count digits
    1488   00:483F                      INPUT_TIMEOUT:
    1489   00:483F  CD 9F 00                call    CHGET
    1490   00:4842  FE 1B                   cp  #1b                         ; ESC?
    1491   00:4844  CA 45 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1492   00:4847  FE 0D                   cp  #0d                         ; ENTER?
    1493   00:4849  CA 8D 48                jp  z,SET_WIFI_CHECK_INPUT      ; Check if ok
    1494   00:484C  FE 08                   cp  #08                         ; Backspace?
    1495   00:484E  CA 73 48                jp  z,SET_WIFI_BS_INPUT         ; Check if there is something to erase
    1496   00:4851  FE 30                   cp  '0'                         ; Check if A is less than 0
    1497   00:4853  DA 6D 48                jp  c,INPUT_TIMEOUT_BAD_INPUT   ; if it is, ignore
    1498   00:4856  FE 3A                   cp  '9'+1                       ; Check if a is greater than  9
    1499   00:4858  D2 6D 48                jp  nc,INPUT_TIMEOUT_BAD_INPUT  ; If it is, ignore
    1500   00:485B  DD 77 00                ld  (ix+0),a                    ; Save it
    1501   00:485E  CD A2 00                call    CHPUT                   ; It is valid, so print it
    1502   00:4861  14                      inc d                           ; Increment digit count
    1503   00:4862  DD 23                   inc ix                          ; Increment pointer
    1504   00:4864  3E 03                   ld  a,3
    1505   00:4866  BA                      cp  d
    1506   00:4867  CA 8D 48                jp  z,SET_WIFI_CHECK_INPUT      ; All we can do is accept up to 3 digits, check if ok
    1507   00:486A  C3 3F 48                jp  INPUT_TIMEOUT               ; Not done yet, so continue
    1508   00:486D                      
    1509   00:486D                      INPUT_TIMEOUT_BAD_INPUT:
    1510   00:486D  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1511   00:4870  C3 3F 48                jp INPUT_TIMEOUT                ; Return
    1512   00:4873                      
    1513   00:4873                      SET_WIFI_BS_INPUT:
    1514   00:4873  AF                      xor a
    1515   00:4874  B2                      or  d                           ; Counter has any digit?
    1516   00:4875  CA 3F 48                jp  z,INPUT_TIMEOUT             ; Nope, so just continue
    1517   00:4878  15                      dec d                           ; Decrement counter
    1518   00:4879  DD 2B                   dec ix                          ; Decrement pointer
    1519   00:487B  3E 08                   ld  a,8                         ; Backspace
    1520   00:487D  CD A2 00                call    CHPUT                   ; Print it
    1521   00:4880  3E 20                   ld  a,' '                       ; Space
    1522   00:4882  CD A2 00                call    CHPUT                   ; Print it
    1523   00:4885  3E 08                   ld  a,8                         ; Backspace
    1524   00:4887  CD A2 00                call    CHPUT                   ; Print it
    1525   00:488A  C3 3F 48                jp  INPUT_TIMEOUT               ; Return
    1526   00:488D                      
    1527   00:488D                      SET_WIFI_CHECK_INPUT:
    1528   00:488D  AF                      xor a
    1529   00:488E  B2                      or  d                           ; Counter has any digits
    1530   00:488F  CA 3F 48                jp  z,INPUT_TIMEOUT             ; Nope, so just continue
    1531   00:4892                          ; IX is pointing one position after last digit, so revert
    1532   00:4892  DD 2B                   dec ix
    1533   00:4894  DD 7E 00                ld  a,(ix+0)                    ; Digit in A
    1534   00:4897  D6 30                   sub '0'                         ; Convert it to decimal
    1535   00:4899  26 00                   ld  h,0                         ; First digit, so H is 0
    1536   00:489B  6F                      ld  l,a                         ; And L has the digit
    1537   00:489C  15                      dec d                           ; If digits finished, just set
    1538   00:489D  CA C9 48                jp  z,SET_WIFI_EXECUTE_SET_COMMAND
    1539   00:48A0  DD 2B                   dec ix
    1540   00:48A2  DD 7E 00                ld  a,(ix+0)                    ; Digit in A
    1541   00:48A5  D6 30                   sub '0'                         ; Convert it to decimal
    1542   00:48A7  87                      add a,a                         ; A*2
    1543   00:48A8  4F                      ld  c,a                         ; A*2 in C
    1544   00:48A9  87                      add a,a                         ; A*4
    1545   00:48AA  87                      add a,a                         ; A*8
    1546   00:48AB  81                      add a,c                         ; A*10
    1547   00:48AC                          ; Up to here, we can get 90 + 9, 99, won't go to H anyway, just add to L
    1548   00:48AC  85                      add a,l                         ; L has the first digit
    1549   00:48AD  6F                      ld  l,a                         ; And now L has the two digits
    1550   00:48AE  15                      dec d                           ; If digits finished, just set
    1551   00:48AF  CA C9 48                jp  z,SET_WIFI_EXECUTE_SET_COMMAND
    1552   00:48B2  DD 2B                   dec ix
    1553   00:48B4  DD 7E 00                ld  a,(ix+0)                    ; Digit in A
    1554   00:48B7  D6 30                   sub '0'                         ; Convert it to decimal
    1555   00:48B9  87                      add a,a                         ; A*2
    1556   00:48BA  4F                      ld  c,a                         ; A*2 in C
    1557   00:48BB  87                      add a,a                         ; A*4
    1558   00:48BC  87                      add a,a                         ; A*8
    1559   00:48BD  81                      add a,c                         ; A*10
    1560   00:48BE  EB                      ex  de,hl                       ; Get the two digits results in de
    1561   00:48BF  6F                      ld  l,a
    1562   00:48C0  26 00                   ld  h,0                         ; HL = A*10
    1563   00:48C2  29                      add hl,hl                       ; HL = A*20
    1564   00:48C3  4D                      ld  c,l
    1565   00:48C4  44                      ld  b,h                         ; BC = A*20
    1566   00:48C5  29                      add hl,hl                       ; HL = A*40
    1567   00:48C6  29                      add hl,hl                       ; HL = A*80
    1568   00:48C7  09                      add hl,bc                       ; HL = A*100
    1569   00:48C8  19                      add hl,de                       ; HL = three digits result
    1570   00:48C9                          ; This was the last digit, up to three
    1571   00:48C9                      SET_WIFI_EXECUTE_SET_COMMAND:
    1572   00:48C9  C3 1B 49                jp  SET_ESP_WIFI_TIMEOUT        ; And set and done
    1573   00:48CC                      
    1574   00:48CC                      ;============================
    1575   00:48CC                      ;===  SETUP Menu Routines  ==
    1576   00:48CC                      ;===      NAGLE Menu       ==
    1577   00:48CC                      ;============================
    1578   00:48CC                      SET_NAGLE:
    1579   00:48CC  3E 31                   ld  a,'1'
    1580   00:48CE  CD A2 00                call    CHPUT
    1581   00:48D1  CD E7 49                call    WAIT_250MS_AND_THEN_CONTINUE
    1582   00:48D4  21 C2 65                ld  hl,MMENU_NAGLE
    1583   00:48D7  CD 6E 4C                call    PRINTHL                 ; Print Main Nagle message
    1584   00:48DA  CD 0A 4A                call    CHECKNAGLE              ; Nagle is on or off?
    1585   00:48DD  20 1E                   jr  nz,NAGLE_IS_ON              ;
    1586   00:48DF  21 F7 66                ld  hl,MMENU_NAGLE_OFF          ; Show the menu telling nagle is off
    1587   00:48E2  CD 6E 4C                call    PRINTHL                 ; Print options
    1588   00:48E5                      SET_NAGLE_WI_ON:
    1589   00:48E5  CD 9F 00                call    CHGET
    1590   00:48E8  FE 1B                   cp  #1b                         ; ESC?
    1591   00:48EA  CA 45 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1592   00:48ED  FE 4F                   cp  'O'                         ; Toggle Nagle On
    1593   00:48EF  CA AA 49                jp  z,SET_NAGLE_ON              ;
    1594   00:48F2  FE 6F                   cp  'o'                         ; Toggle Nagle On
    1595   00:48F4  CA AA 49                jp  z,SET_NAGLE_ON              ;
    1596   00:48F7  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1597   00:48FA  C3 E5 48                jp  SET_NAGLE_WI_ON             ; And return waiting key
    1598   00:48FD                      
    1599   00:48FD                      NAGLE_IS_ON:
    1600   00:48FD  21 B7 66                ld  hl,MMENU_NAGLE_ON           ; Show the menu telling nagle is on
    1601   00:4900  CD 6E 4C                call    PRINTHL                 ; Print options
    1602   00:4903                      SET_NAGLE_WI_OFF:
    1603   00:4903  CD 9F 00                call    CHGET
    1604   00:4906  FE 1B                   cp  #1b                         ; ESC?
    1605   00:4908  CA 45 42                jp  z,ESPSETUP                  ; When done, back to main setup
    1606   00:490B  FE 4F                   cp  'O'                         ; Toggle Nagle Off
    1607   00:490D  CA 5B 49                jp  z,SET_NAGLE_OFF             ;
    1608   00:4910  FE 6F                   cp  'o'                         ; Toggle Nagle Off
    1609   00:4912  CA 5B 49                jp  z,SET_NAGLE_OFF             ;
    1610   00:4915  CD C0 00                call    BEEP                    ; Wrong Input, beep
    1611   00:4918  C3 03 49                jp  SET_NAGLE_WI_OFF            ; And return waiting key
    1612   00:491B                      
    1613   00:491B                      ;============================
    1614   00:491B                      ;===  SETUP Menu Routines  ==
    1615   00:491B                      ;===  Auxiliary Functions  ==
    1616   00:491B                      ;============================
    1617   00:491B                      SET_ESP_WIFI_TIMEOUT:
    1618   00:491B  EB                      ex  de,hl
    1619   00:491C  3E 0D                   ld  a,#0d
    1620   00:491E  CD A2 00                call    CHPUT
    1621   00:4921  3E 0A                   ld  a,#0a
    1622   00:4923  CD A2 00                call    CHPUT
    1623   00:4926  21 38 67                ld  hl,STR_SENDING              ; Indicate it is sending a command
    1624   00:4929  CD 6E 4C                call    PRINTHL
    1625   00:492C                          CLEAR_UART
    1625   00:492C  3E 14             >     ld  a,20
    1625   00:492E  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1626   00:4931  3E 54                   ld  a,CMD_TIMER_SET
    1627   00:4933                          SEND_DATA
    1627   00:4933  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1628   00:4936  AF                      xor a                           ; Size MSB is 0
    1629   00:4937                          SEND_DATA
    1629   00:4937  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1630   00:493A  3E 02                   ld  a,2                         ; Size LSB is 2
    1631   00:493C                          SEND_DATA
    1631   00:493C  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1632   00:493F  7A                      ld  a,d                         ; Timeout MSB
    1633   00:4940                          SEND_DATA
    1633   00:4940  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1634   00:4943  7B                      ld  a,e                         ; Timeout LSB
    1635   00:4944                          SEND_DATA
    1635   00:4944  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1636   00:4947  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1637   00:494A  3E 54                   ld  a,CMD_TIMER_SET             ; Our command
    1638   00:494C  CD 09 4B                call    WAIT_MENU_QCMD_RESPONSE
    1639   00:494F  CA 00 4B                jp  z,MENU_BAD_END
    1640   00:4952  21 53 67                ld  hl,STR_SENDING_OK           ; Success
    1641   00:4955  CD 6E 4C                call    PRINTHL
    1642   00:4958  C3 DF 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1643   00:495B                      
    1644   00:495B                      SET_NAGLE_OFF:
    1645   00:495B  3E 4F                   ld  a,'O'
    1646   00:495D  CD A2 00                call    CHPUT
    1647   00:4960  3E 0D                   ld  a,#0d
    1648   00:4962  CD A2 00                call    CHPUT
    1649   00:4965  3E 0A                   ld  a,#0a
    1650   00:4967  CD A2 00                call    CHPUT
    1651   00:496A  21 38 67                ld  hl,STR_SENDING              ; Indicate it is sending a command
    1652   00:496D  CD 6E 4C                call    PRINTHL
    1653   00:4970                          CLEAR_UART
    1653   00:4970  3E 14             >     ld  a,20
    1653   00:4972  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1654   00:4975  3E 4E                   ld  a,CMD_NAGLE_OFF
    1655   00:4977                          SEND_DATA
    1655   00:4977  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1656   00:497A  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1657   00:497D  CD 09 4B                call    WAIT_MENU_QCMD_RESPONSE
    1658   00:4980  CA 00 4B                jp  z,MENU_BAD_END
    1659   00:4983  21 53 67                ld  hl,STR_SENDING_OK           ; Success
    1660   00:4986  CD 6E 4C                call    PRINTHL
    1661   00:4989  C3 DF 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1662   00:498C                      
    1663   00:498C                      STARTWIFISCAN:
    1664   00:498C                          CLEAR_UART
    1664   00:498C  3E 14             >     ld  a,20
    1664   00:498E  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1665   00:4991  3E 53                   ld  a,CMD_SCAN_START
    1666   00:4993                          SEND_DATA
    1666   00:4993  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1667   00:4996  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1668   00:4999  CD 09 4B                call    WAIT_MENU_QCMD_RESPONSE
    1669   00:499C  C0                      ret nz                          ; If success return
    1670   00:499D  3E 0D                   ld  a,CR
    1671   00:499F  CD A2 00                call    CHPUT
    1672   00:49A2  3E 0A                   ld  a,LF
    1673   00:49A4  CD A2 00                call    CHPUT
    1674   00:49A7  C3 FF 4A                jp  MENU_SUB_BAD_END            ; If error, nothing much to do, main menu
    1675   00:49AA                      
    1676   00:49AA                      SET_NAGLE_ON:
    1677   00:49AA  3E 4F                   ld  a,'O'
    1678   00:49AC  CD A2 00                call    CHPUT
    1679   00:49AF  3E 0D                   ld  a,#0d
    1680   00:49B1  CD A2 00                call    CHPUT
    1681   00:49B4  3E 0A                   ld  a,#0a
    1682   00:49B6  CD A2 00                call    CHPUT
    1683   00:49B9  21 38 67                ld  hl,STR_SENDING              ; Indicate it is sending a command
    1684   00:49BC  CD 6E 4C                call    PRINTHL
    1685   00:49BF                          CLEAR_UART
    1685   00:49BF  3E 14             >     ld  a,20
    1685   00:49C1  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1686   00:49C4  3E 44                   ld  a,CMD_NAGLE_ON
    1687   00:49C6                          SEND_DATA
    1687   00:49C6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1688   00:49C9  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1689   00:49CC  CD 09 4B                call    WAIT_MENU_QCMD_RESPONSE
    1690   00:49CF  CA 00 4B                jp  z,MENU_BAD_END
    1691   00:49D2  21 53 67                ld  hl,STR_SENDING_OK           ; Success
    1692   00:49D5  CD 6E 4C                call    PRINTHL
    1693   00:49D8  C3 DF 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1694   00:49DB                      
    1695   00:49DB                      WAIT_4S_AND_THEN_MAINMENU:
    1696   00:49DB  3E F0                   ld  a,240                       ; Wait 4 seconds with message on screen
    1697   00:49DD  18 02                   jr  WAIT_AND_THEN_MAINMENU
    1698   00:49DF                      WAIT_2S_AND_THEN_MAINMENU:
    1699   00:49DF  3E 78                   ld  a,120                       ; Wait 2 seconds with message on screen
    1700   00:49E1                      WAIT_AND_THEN_MAINMENU:
    1701   00:49E1  CD E9 49                call    WAIT_BEFORE_CONTINUING
    1702   00:49E4  C3 45 42                jp  ESPSETUP                    ; When done, back to main setup
    1703   00:49E7                      WAIT_250MS_AND_THEN_CONTINUE:
    1704   00:49E7  3E 0F                   ld  a,15                        ; Wait 250 ms then continue
    1705   00:49E9                      WAIT_BEFORE_CONTINUING:
    1706   00:49E9  76                      halt
    1707   00:49EA  3D                      dec a
    1708   00:49EB                          ; If not zero, our time out has not elapsed
    1709   00:49EB  20 FC                   jr  nz,WAIT_BEFORE_CONTINUING
    1710   00:49ED  C9                      ret                             ; Time out and continue
    1711   00:49EE                      
    1712   00:49EE                      ; Check Auto Clock
    1713   00:49EE                      ISCLKAUTO:
    1714   00:49EE                          CLEAR_UART
    1714   00:49EE  3E 14             >     ld  a,20
    1714   00:49F0  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1715   00:49F3  3E 63                   ld  a,CMD_QUERY_ACLK_SETTINGS
    1716   00:49F5                          SEND_DATA
    1716   00:49F5  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1717   00:49F8  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1718   00:49FB  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1719   00:49FF  DD 6B                   ld  ixl,e
    1720   00:4A01  DD 62                   ld  ixh,d                       ; address in IX
    1721   00:4A03  CD 46 4B                call    WAIT_MENU_CMD_RESPONSE
    1722   00:4A06  CA FF 4A                jp  z,MENU_SUB_BAD_END
    1723   00:4A09                          ; Response received, IX+0 and IX+1 has Auto Clock and GMT, A
    1724   00:4A09  C9                      ret
    1725   00:4A0A                      
    1726   00:4A0A                      ; Check what is the current NAGLE setting
    1727   00:4A0A                      CHECKNAGLE:
    1728   00:4A0A                          CLEAR_UART
    1728   00:4A0A  3E 14             >     ld  a,20
    1728   00:4A0C  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1729   00:4A0F  3E 51                   ld  a,CMD_QUERY_ESP_SETTINGS
    1730   00:4A11                          SEND_DATA
    1730   00:4A11  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1731   00:4A14  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1732   00:4A17  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1733   00:4A1B  DD 6B                   ld  ixl,e
    1734   00:4A1D  DD 62                   ld  ixh,d                       ; Address in IX
    1735   00:4A1F  CD 46 4B                call    WAIT_MENU_CMD_RESPONSE
    1736   00:4A22  CA FF 4A                jp  z,MENU_SUB_BAD_END
    1737   00:4A25                          ; Response received, nagle is the first one, ON: or OFF:
    1738   00:4A25  3E 4F                   ld  a,'O'
    1739   00:4A27  DD BE 00                cp  (ix+0)
    1740   00:4A2A  C2 FF 4A                jp  nz,MENU_SUB_BAD_END
    1741   00:4A2D  3E 4E                   ld  a,'N'
    1742   00:4A2F  DD BE 01                cp  (ix+1)
    1743   00:4A32  C2 3F 4A                jp  nz,CHECK_NAGLE_OFF
    1744   00:4A35  3E 3A                   ld  a,':'
    1745   00:4A37  DD BE 02                cp  (ix+2)
    1746   00:4A3A  C2 FF 4A                jp  nz,MENU_SUB_BAD_END
    1747   00:4A3D  B7                      or  a                           ; It will make it NZ
    1748   00:4A3E  C9                      ret
    1749   00:4A3F                      CHECK_NAGLE_OFF:
    1750   00:4A3F  3E 46                   ld  a,'F'
    1751   00:4A41  DD BE 01                cp  (ix+1)
    1752   00:4A44  C2 FF 4A                jp  nz,MENU_SUB_BAD_END
    1753   00:4A47  3E 46                   ld  a,'F'
    1754   00:4A49  DD BE 02                cp  (ix+2)
    1755   00:4A4C  C2 FF 4A                jp  nz,MENU_SUB_BAD_END
    1756   00:4A4F  3E 3A                   ld  a,':'
    1757   00:4A51  DD BE 03                cp  (ix+3)
    1758   00:4A54  C2 FF 4A                jp  nz,MENU_SUB_BAD_END
    1759   00:4A57                          ; Already has zero, so just ret
    1760   00:4A57  C9                      ret
    1761   00:4A58                      
    1762   00:4A58                      ; Check what is the current TIMEOUT setting, return 0 if always on, otherwise there is a timeout
    1763   00:4A58                      ; Will return a zero terminated string @ HL that can be printed
    1764   00:4A58                      ; Will return the value in DE
    1765   00:4A58                      CHECKTIMEOUT:
    1766   00:4A58                          CLEAR_UART
    1766   00:4A58  3E 14             >     ld  a,20
    1766   00:4A5A  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    1767   00:4A5D  3E 51                   ld  a,CMD_QUERY_ESP_SETTINGS
    1768   00:4A5F                          SEND_DATA
    1768   00:4A5F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    1769   00:4A62  21 3C 00                ld  hl,60                       ; Wait Up To 1s
    1770   00:4A65  ED 5B 76 F6             ld  de,(TXTTAB)                 ; We will borrow Basic Program memory area for now...
    1771   00:4A69  DD 6B                   ld  ixl,e
    1772   00:4A6B  DD 62                   ld  ixh,d                       ; Address in IX
    1773   00:4A6D  CD 46 4B                call    WAIT_MENU_CMD_RESPONSE
    1774   00:4A70  CA FF 4A                jp  z,MENU_SUB_BAD_END
    1775   00:4A73                          ; Response received, nagle is the first one, ON: or OFF:
    1776   00:4A73  3E 3A                   ld  a,':'
    1777   00:4A75  DD 23                   inc ix
    1778   00:4A77  DD 23                   inc ix                          ; Nagle response is two or three bytes long, let's check
    1779   00:4A79  0B                      dec bc
    1780   00:4A7A  0B                      dec bc                          ; Remaining bytes
    1781   00:4A7B  DD BE 00                cp  (ix+0)
    1782   00:4A7E  CA 8A 4A                jp  z,CHECKTIMEOUT.1
    1783   00:4A81  DD 23                   inc ix
    1784   00:4A83  0B                      dec bc                          ; Remaining bytes
    1785   00:4A84  DD BE 00                cp  (ix+0)
    1786   00:4A87  C2 FF 4A                jp  nz,MENU_SUB_BAD_END         ; If not here, sorry to say it is an error
    1787   00:4A8A                      CHECKTIMEOUT.1:
    1788   00:4A8A  78                      ld  a,b
    1789   00:4A8B  B1                      or  c                           ; All data read?
    1790   00:4A8C  CA FF 4A                jp  z,MENU_SUB_BAD_END          ; If so, sorry to say it is an error
    1791   00:4A8F  DD 23                   inc ix                          ; At the first digit
    1792   00:4A91  0B                      dec bc                          ; Remaining bytes
    1793   00:4A92  78                      ld  a,b
    1794   00:4A93  B1                      or  c                           ; All data read?
    1795   00:4A94  CA FF 4A                jp  z,MENU_SUB_BAD_END          ; If so, sorry to say it is an error
    1796   00:4A97  DD E5                   push    ix                      ; This is the start of the string, save it
    1797   00:4A99  26 00                   ld  h,0                         ; No digit so far
    1798   00:4A9B                          ; It can have up to three digits
    1799   00:4A9B                      CHECKTIMEOUT.2:
    1800   00:4A9B  3E 3A                   ld  a,':'
    1801   00:4A9D  DD BE 00                cp  (ix+0)                      ; Check if it is the separator
    1802   00:4AA0  CA C1 4A                jp  z,CHECKTIMEOUT.3            ; If it is routine will follow through
    1803   00:4AA3  DD 7E 00                ld  a,(ix+0)                    ; Get the supposed digit in A
    1804   00:4AA6  2E 3A                   ld  l,'9'+1
    1805   00:4AA8  BD                      cp  l
    1806   00:4AA9  D2 FE 4A                jp  nc,MENU_SUB_BAD_END_1S      ; If more than '9', sorry to say it is an error
    1807   00:4AAC  2E 30                   ld  l,'0'
    1808   00:4AAE  BD                      cp  l
    1809   00:4AAF  DA FE 4A                jp  c,MENU_SUB_BAD_END_1S       ; If less than '0', sorry to say it is an error
    1810   00:4AB2  24                      inc h                           ; It is not, so it is a digit
    1811   00:4AB3  3E 03                   ld  a,3
    1812   00:4AB5  BC                      cp  h
    1813   00:4AB6  DA FE 4A                jp  c,MENU_SUB_BAD_END_1S       ; If more than three digits, sorry to say it is an error
    1814   00:4AB9  DD 23                   inc ix                          ; Increase pointer
    1815   00:4ABB  0B                      dec bc                          ; Decrease remaining
    1816   00:4ABC  78                      ld  a,b
    1817   00:4ABD  B1                      or  c                           ; All data read?
    1818   00:4ABE  C2 9B 4A                jp  nz,CHECKTIMEOUT.2           ; Not, so rinse and repeat
    1819   00:4AC1                      CHECKTIMEOUT.3:
    1820   00:4AC1  DD 36 00 00             ld  (ix+0),0                    ; Null terminate string value
    1821   00:4AC5  DD 2B                   dec ix
    1822   00:4AC7  DD 7E 00                ld  a,(ix+0)                    ; 1st Digit in A
    1823   00:4ACA  D6 30                   sub '0'                         ; Convert it to decimal value
    1824   00:4ACC  5F                      ld  e,a
    1825   00:4ACD  16 00                   ld  d,0                         ; DE has first digit
    1826   00:4ACF  25                      dec h                           ; Decrement digit counter
    1827   00:4AD0  28 28                   jr  z,CHECKTIMEOUT.END          ; If all digits, done
    1828   00:4AD2                          ; Now second digit, multiply it by 10 and add to E, even if 90 + 9, still fits E
    1829   00:4AD2  DD 2B                   dec ix
    1830   00:4AD4  DD 7E 00                ld  a,(ix+0)                    ; 2nd Digit
    1831   00:4AD7  D6 30                   sub '0'                         ; Convert it to decimal value
    1832   00:4AD9  87                      add a,a                         ; A has *2
    1833   00:4ADA  4F                      ld  c,a                         ; C has *2
    1834   00:4ADB  87                      add a,a                         ; A has *4
    1835   00:4ADC  87                      add a,a                         ; A has *8
    1836   00:4ADD  81                      add a,c                         ; A has *10
    1837   00:4ADE  83                      add a,e                         ; A has two digits result
    1838   00:4ADF  5F                      ld  e,a                         ; Back to E, DE has two digits results
    1839   00:4AE0  25                      dec h                           ; Decrement digit counter
    1840   00:4AE1  28 17                   jr  z,CHECKTIMEOUT.END          ; If all digits, done
    1841   00:4AE3                          ; Now Third digit, multiply it by 100 and add to DE
    1842   00:4AE3  DD 2B                   dec ix
    1843   00:4AE5  DD 7E 00                ld  a,(ix+0)                    ; 3rd Digit
    1844   00:4AE8  D6 30                   sub '0'                         ; Convert it to decimal value
    1845   00:4AEA  87                      add a,a                         ; A has *2
    1846   00:4AEB  4F                      ld  c,a                         ; C has *2
    1847   00:4AEC  87                      add a,a                         ; A has *4
    1848   00:4AED  87                      add a,a                         ; A has *8
    1849   00:4AEE  81                      add a,c                         ; A has *10
    1850   00:4AEF  26 00                   ld  h,0
    1851   00:4AF1  6F                      ld  l,a                         ; HL has *10
    1852   00:4AF2  29                      add hl,hl                       ; HL has *20
    1853   00:4AF3  44                      ld  b,h
    1854   00:4AF4  4D                      ld  c,l                         ; BC has *20
    1855   00:4AF5  29                      add hl,hl                       ; HL has *40
    1856   00:4AF6  29                      add hl,hl                       ; HL has *80
    1857   00:4AF7  09                      add hl,bc                       ; HL has *100
    1858   00:4AF8  19                      add hl,de                       ; HL has three digit value
    1859   00:4AF9  EB                      ex  de,hl                       ; now in DE
    1860   00:4AFA                      CHECKTIMEOUT.END:
    1861   00:4AFA  E1                      pop hl                          ; Restore address of string version of time count
    1862   00:4AFB  7A                      ld  a,d
    1863   00:4AFC  B3                      or  e                           ; Set zero flag according to the time out set
    1864   00:4AFD  C9                      ret
    1865   00:4AFE                      
    1866   00:4AFE                      MENU_SUB_BAD_END_1S:
    1867   00:4AFE  F1                      pop af                          ; 1 register was stacked, pop it
    1868   00:4AFF                      MENU_SUB_BAD_END:
    1869   00:4AFF  F1                      pop af                          ; It was a sub, so clear stack
    1870   00:4B00                      MENU_BAD_END:
    1871   00:4B00  21 D0 67                ld  hl,STR_SENDING_FAIL         ; error message
    1872   00:4B03  CD 6E 4C                call    PRINTHL
    1873   00:4B06  C3 DF 49                jp  WAIT_2S_AND_THEN_MAINMENU
    1874   00:4B09                      
    1875   00:4B09                      ; WAIT an ESP quick command Response
    1876   00:4B09                      ; Inputs:
    1877   00:4B09                      ; A -> Command Code
    1878   00:4B09                      ; HL -> Timeout
    1879   00:4B09                      ;
    1880   00:4B09                      ; Returns:
    1881   00:4B09                      ; Flag Z is zero if failure, non zero if success
    1882   00:4B09                      ;
    1883   00:4B09                      ; Affect:
    1884   00:4B09                      ; AF and HL
    1885   00:4B09                      ;
    1886   00:4B09                      WAIT_MENU_QCMD_RESPONSE:
    1887   00:4B09  D5                      push    de
    1888   00:4B0A  57                      ld  d,a                         ; Command to wait in D
    1889   00:4B0B                      WAIT_MENU_QCMD_RESPONSE_ST1:
    1890   00:4B0B                          LOAD_STS_PORT_IN_A
    1890   00:4B0B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1891   00:4B0E  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    1892   00:4B10  C2 40 4B                jp  nz,WAIT_MENU_QCMD_RESPONSE_END_NOK
    1893   00:4B13  CB 47                   bit 0,a                         ; If nz has data
    1894   00:4B15  20 08                   jr  nz,WAIT_MENU_QCMD_RESPONSE_ST1.1
    1895   00:4B17  CD 68 4C                call    HLTIMEOUT
    1896   00:4B1A  20 EF                   jr  nz,WAIT_MENU_QCMD_RESPONSE_ST1
    1897   00:4B1C  C3 3E 4B                jp  WAIT_MENU_QCMD_RESPONSE_END ; If time out waiting, return
    1898   00:4B1F                      WAIT_MENU_QCMD_RESPONSE_ST1.1:
    1899   00:4B1F                          ; nz, check the data
    1900   00:4B1F                          RECEIVE_DATA
    1900   00:4B1F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1901   00:4B22  BA                      cp  d                           ; Is response of our command?
    1902   00:4B23  20 E6                   jr  nz,WAIT_MENU_QCMD_RESPONSE_ST1
    1903   00:4B25                          ; Now get return code, if return code other than 0, it is failure, otherwise success
    1904   00:4B25                      WAIT_MENU_QCMD_RESPONSE_RC:
    1905   00:4B25                          CHECK_DATA
    1905   00:4B25  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1905   00:4B28  CB 47             >     bit 0,a
    1906   00:4B2A  20 08                   jr  nz,WAIT_MENU_QCMD_RESPONSE_RC.1
    1907   00:4B2C  CD 68 4C                call    HLTIMEOUT
    1908   00:4B2F  20 F4                   jr  nz,WAIT_MENU_QCMD_RESPONSE_RC
    1909   00:4B31  C3 3E 4B                jp  WAIT_MENU_QCMD_RESPONSE_END ; If time-out waiting, return
    1910   00:4B34                      WAIT_MENU_QCMD_RESPONSE_RC.1:
    1911   00:4B34                          RECEIVE_DATA
    1911   00:4B34  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1912   00:4B37  B7                      or  a                           ; 0?
    1913   00:4B38                          ; If not, done
    1914   00:4B38  C2 40 4B                jp  nz,WAIT_MENU_QCMD_RESPONSE_END_NOK
    1915   00:4B3B                      WAIT_MENU_QCMD_RESPONSE_END_OK:
    1916   00:4B3B  3E 01                   ld  a,1
    1917   00:4B3D  B7                      or  a                           ; NZ to indicate success
    1918   00:4B3E                      WAIT_MENU_QCMD_RESPONSE_END:
    1919   00:4B3E  D1                      pop de
    1920   00:4B3F  C9                      ret
    1921   00:4B40                      WAIT_MENU_QCMD_RESPONSE_END_NOK:
    1922   00:4B40  21 00 00                ld  hl,0
    1923   00:4B43  AF                      xor a
    1924   00:4B44  D1                      pop de
    1925   00:4B45  C9                      ret
    1926   00:4B46                      
    1927   00:4B46                      ; WAIT an ESP regular command Response
    1928   00:4B46                      ; Inputs:
    1929   00:4B46                      ; A -> Command Code
    1930   00:4B46                      ; HL -> Timeout
    1931   00:4B46                      ; IX -> Where to store response
    1932   00:4B46                      ;
    1933   00:4B46                      ; Returns:
    1934   00:4B46                      ; Flag Z is zero if failure, non zero if success
    1935   00:4B46                      ; BC is the response size
    1936   00:4B46                      ;
    1937   00:4B46                      ; Affect:
    1938   00:4B46                      ; AF , BC and HL
    1939   00:4B46                      WAIT_MENU_CMD_RESPONSE:
    1940   00:4B46  D5                      push    de
    1941   00:4B47  DD E5                   push    ix
    1942   00:4B49  57                      ld  d,a                         ; Command to wait in D
    1943   00:4B4A                      WAIT_MENU_CMD_RESPONSE_ST1:
    1944   00:4B4A                          LOAD_STS_PORT_IN_A
    1944   00:4B4A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1945   00:4B4D  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    1946   00:4B4F  C2 CE 4B                jp  nz,WAIT_MENU_CMD_RESPONSE_END_NOK
    1947   00:4B52  CB 47                   bit 0,a                         ; If nz has data
    1948   00:4B54  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST1.1
    1949   00:4B56  CD 68 4C                call    HLTIMEOUT
    1950   00:4B59  20 EF                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST1
    1951   00:4B5B  C3 C8 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    1952   00:4B5E                      WAIT_MENU_CMD_RESPONSE_ST1.1:
    1953   00:4B5E                          ; nz, check the data
    1954   00:4B5E                          RECEIVE_DATA
    1954   00:4B5E  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1955   00:4B61  BA                      cp  d                           ; Is response of our command?
    1956   00:4B62  20 E6                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST1
    1957   00:4B64                          ; Now get return code, if return code other than 0, it is finished
    1958   00:4B64                      WAIT_MENU_CMD_RESPONSE_RC:
    1959   00:4B64                          CHECK_DATA
    1959   00:4B64  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1959   00:4B67  CB 47             >     bit 0,a
    1960   00:4B69  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_RC.1
    1961   00:4B6B  CD 68 4C                call    HLTIMEOUT
    1962   00:4B6E  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_RC
    1963   00:4B70  C3 C8 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    1964   00:4B73                      WAIT_MENU_CMD_RESPONSE_RC.1:
    1965   00:4B73                          RECEIVE_DATA
    1965   00:4B73  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1966   00:4B76  B7                      or  a                           ; 0?
    1967   00:4B77                          ; If not, done
    1968   00:4B77  C2 CE 4B                jp  nz,WAIT_MENU_CMD_RESPONSE_END_NOK
    1969   00:4B7A                          ; Next two bytes are size bytes, save it to BC
    1970   00:4B7A                      WAIT_MENU_CMD_RESPONSE_ST2A:
    1971   00:4B7A                          CHECK_DATA
    1971   00:4B7A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1971   00:4B7D  CB 47             >     bit 0,a
    1972   00:4B7F  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2A.1
    1973   00:4B81  CD 68 4C                call    HLTIMEOUT
    1974   00:4B84  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2A
    1975   00:4B86  C3 C8 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    1976   00:4B89                      WAIT_MENU_CMD_RESPONSE_ST2A.1:
    1977   00:4B89                          RECEIVE_DATA
    1977   00:4B89  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1978   00:4B8C  47                      ld  b,a
    1979   00:4B8D                      WAIT_MENU_CMD_RESPONSE_ST2B:
    1980   00:4B8D                          CHECK_DATA
    1980   00:4B8D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1980   00:4B90  CB 47             >     bit 0,a
    1981   00:4B92  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2B.1
    1982   00:4B94  CD 68 4C                call    HLTIMEOUT
    1983   00:4B97  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_ST2B
    1984   00:4B99  C3 C8 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    1985   00:4B9C                      WAIT_MENU_CMD_RESPONSE_ST2B.1:
    1986   00:4B9C                          RECEIVE_DATA
    1986   00:4B9C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    1987   00:4B9F  4F                      ld  c,a
    1988   00:4BA0  B0                      or  b                           ; Zero size in response?
    1989   00:4BA1  28 1E                   jr  z,WAIT_MENU_CMD_RESPONSE_END_OK
    1990   00:4BA3  50                      ld  d,b
    1991   00:4BA4  59                      ld  e,c                         ; Copy to DE
    1992   00:4BA5                          ; Now loop getting the data until received everything or time-out
    1993   00:4BA5                      WAIT_MENU_CMD_RESPONSE_GET_DATA:
    1994   00:4BA5                          CHECK_DATA
    1994   00:4BA5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    1994   00:4BA8  CB 47             >     bit 0,a
    1995   00:4BAA  20 08                   jr  nz,WAIT_MENU_CMD_RESPONSE_GET_DATA.1
    1996   00:4BAC  CD 68 4C                call    HLTIMEOUT
    1997   00:4BAF  20 F4                   jr  nz,WAIT_MENU_CMD_RESPONSE_GET_DATA
    1998   00:4BB1  C3 C8 4B                jp  WAIT_MENU_CMD_RESPONSE_END  ; If time out waiting, return
    1999   00:4BB4                      WAIT_MENU_CMD_RESPONSE_GET_DATA.1:
    2000   00:4BB4                          RECEIVE_DATA            ; Get data
    2000   00:4BB4  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2001   00:4BB7  DD 77 00                ld  (ix+0),a                    ; Put it in the buffer
    2002   00:4BBA  DD 23                   inc ix                          ; Increment pointer
    2003   00:4BBC  1B                      dec de                          ; Decrement counter
    2004   00:4BBD  7A                      ld  a,d
    2005   00:4BBE  B3                      or  e                           ; Is counter 0?
    2006   00:4BBF  20 E4                   jr  nz,WAIT_MENU_CMD_RESPONSE_GET_DATA
    2007   00:4BC1                      WAIT_MENU_CMD_RESPONSE_END_OK:
    2008   00:4BC1  3E 01                   ld  a,1
    2009   00:4BC3  B7                      or  a                           ; NZ to indicate success
    2010   00:4BC4  DD E1                   pop ix
    2011   00:4BC6  D1                      pop de
    2012   00:4BC7  C9                      ret
    2013   00:4BC8                      WAIT_MENU_CMD_RESPONSE_END:
    2014   00:4BC8  06 FF                   ld  b,#FF
    2015   00:4BCA  DD E1                   pop ix
    2016   00:4BCC  D1                      pop de
    2017   00:4BCD  C9                      ret
    2018   00:4BCE                      WAIT_MENU_CMD_RESPONSE_END_NOK:
    2019   00:4BCE  21 00 00                ld  hl,0
    2020   00:4BD1  47                      ld  b,a                         ; Get result in B, 0xFF for time-out, otherwise was an error return code
    2021   00:4BD2  AF                      xor a
    2022   00:4BD3  DD E1                   pop ix
    2023   00:4BD5  D1                      pop de
    2024   00:4BD6  C9                      ret
    2025   00:4BD7                      
    2026   00:4BD7                      ; WAIT an ESP Wi-Fi Scan command Response
    2027   00:4BD7                      ; Inputs:
    2028   00:4BD7                      ; A -> Command Code
    2029   00:4BD7                      ; HL -> Timeout
    2030   00:4BD7                      ; IX -> Where to store response
    2031   00:4BD7                      ;
    2032   00:4BD7                      ; Returns:
    2033   00:4BD7                      ; Flag Z is zero if failure, non zero if success
    2034   00:4BD7                      ; A is the number of access points scanned
    2035   00:4BD7                      ;
    2036   00:4BD7                      ; Response is stored as:
    2037   00:4BD7                      ; Access Point SSID zero terminated and after first 0
    2038   00:4BD7                      ; 0 if Open otherwise requires a password to join
    2039   00:4BD7                      ; And this repeats...
    2040   00:4BD7                      ;
    2041   00:4BD7                      ; Affect:
    2042   00:4BD7                      ; AF , BC and HL
    2043   00:4BD7                      ;
    2044   00:4BD7                      WAIT_MENU_SCMD_RESPONSE:
    2045   00:4BD7  D5                      push    de
    2046   00:4BD8  DD E5                   push    ix
    2047   00:4BDA  57                      ld  d,a                         ; Command to wait in D
    2048   00:4BDB                      WAIT_MENU_SCMD_RESPONSE_ST1:
    2049   00:4BDB                          LOAD_STS_PORT_IN_A
    2049   00:4BDB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2050   00:4BDE  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    2051   00:4BE0  C2 5F 4C                jp  nz,WAIT_MENU_SCMD_RESPONSE_END_NOK
    2052   00:4BE3  CB 47                   bit 0,a                         ; If nz has data
    2053   00:4BE5  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST1.1
    2054   00:4BE7  CD 68 4C                call    HLTIMEOUT
    2055   00:4BEA  20 EF                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST1
    2056   00:4BEC  C3 5B 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2057   00:4BEF                      WAIT_MENU_SCMD_RESPONSE_ST1.1:
    2058   00:4BEF                          ; nz, check the data
    2059   00:4BEF                          RECEIVE_DATA
    2059   00:4BEF  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2060   00:4BF2  BA                      cp  d                           ; Is response of our command?
    2061   00:4BF3  20 E6                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST1
    2062   00:4BF5                          ; Now get return code, if return code other than 0, it is finished
    2063   00:4BF5                      WAIT_MENU_SCMD_RESPONSE_RC:
    2064   00:4BF5                          CHECK_DATA
    2064   00:4BF5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2064   00:4BF8  CB 47             >     bit 0,a
    2065   00:4BFA  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_RC.1
    2066   00:4BFC  CD 68 4C                call    HLTIMEOUT
    2067   00:4BFF  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_RC
    2068   00:4C01  C3 5B 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2069   00:4C04                      WAIT_MENU_SCMD_RESPONSE_RC.1:
    2070   00:4C04                          RECEIVE_DATA
    2070   00:4C04  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2071   00:4C07  B7                      or  a                           ; 0?
    2072   00:4C08                          ; If not, done
    2073   00:4C08  C2 5F 4C                jp  nz,WAIT_MENU_SCMD_RESPONSE_END_NOK
    2074   00:4C0B                          ; Next byte is how many access points are available
    2075   00:4C0B                      WAIT_MENU_SCMD_RESPONSE_ST2A:
    2076   00:4C0B                          CHECK_DATA
    2076   00:4C0B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2076   00:4C0E  CB 47             >     bit 0,a
    2077   00:4C10  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2A.1
    2078   00:4C12  CD 68 4C                call    HLTIMEOUT
    2079   00:4C15  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2A
    2080   00:4C17  C3 5B 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2081   00:4C1A                      WAIT_MENU_SCMD_RESPONSE_ST2A.1:
    2082   00:4C1A                          RECEIVE_DATA
    2082   00:4C1A  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2083   00:4C1D  47                      ld  b,a                         ; Save in B
    2084   00:4C1E  4F                      ld  c,a                         ; And C as well
    2085   00:4C1F                          ; Now should loop this until c is 0, c will control access point received count
    2086   00:4C1F                      WAIT_MENU_SCMD_RESPONSE_ST2B:
    2087   00:4C1F                          CHECK_DATA
    2087   00:4C1F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2087   00:4C22  CB 47             >     bit 0,a
    2088   00:4C24  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B.1
    2089   00:4C26  CD 68 4C                call    HLTIMEOUT
    2090   00:4C29  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B
    2091   00:4C2B  C3 5B 4C                jp  WAIT_MENU_SCMD_RESPONSE_END ; If time out waiting, return
    2092   00:4C2E                      WAIT_MENU_SCMD_RESPONSE_ST2B.1:
    2093   00:4C2E                          RECEIVE_DATA
    2093   00:4C2E  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2094   00:4C31  DD 77 00                ld  (ix+0),a
    2095   00:4C34  DD 23                   inc ix                          ; Increment pointer
    2096   00:4C36  B7                      or  a                           ; Terminator of AP Name?
    2097   00:4C37  20 E6                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B
    2098   00:4C39                          ; Get encryption
    2099   00:4C39                      WAIT_MENU_SCMD_RESPONSE_GET_ENC:
    2100   00:4C39                          CHECK_DATA
    2100   00:4C39  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2100   00:4C3C  CB 47             >     bit 0,a
    2101   00:4C3E  20 08                   jr  nz,WAIT_MENU_SCMD_RESPONSE_GET_ENC.1
    2102   00:4C40  CD 68 4C                call    HLTIMEOUT
    2103   00:4C43  20 F4                   jr  nz,WAIT_MENU_SCMD_RESPONSE_GET_ENC
    2104   00:4C45  C3 5B 4C                jp  WAIT_MENU_SCMD_RESPONSE_END  ; If time out waiting, return
    2105   00:4C48                      WAIT_MENU_SCMD_RESPONSE_GET_ENC.1:
    2106   00:4C48                          RECEIVE_DATA            ; Get data
    2106   00:4C48  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2107   00:4C4B  D6 4F                   sub 'O'                         ; If O, open, will be 0, otherwise, will be notzero
    2108   00:4C4D  DD 77 00                ld  (ix+0),a                    ; Put it in the buffer
    2109   00:4C50  DD 23                   inc ix                          ; Increment pointer
    2110   00:4C52  0D                      dec c                           ; Decrement counter
    2111   00:4C53  AF                      xor a
    2112   00:4C54  B1                      or  c                           ; Is counter 0?
    2113   00:4C55                          ; If not continue getting more SSIDs
    2114   00:4C55  20 C8                   jr  nz,WAIT_MENU_SCMD_RESPONSE_ST2B
    2115   00:4C57                          ; It is zero, so, done
    2116   00:4C57                      WAIT_MENU_SCMD_RESPONSE_END_OK:
    2117   00:4C57  3E 01                   ld  a,1
    2118   00:4C59  B7                      or  a                           ; NZ to indicate success
    2119   00:4C5A  78                      ld  a,b                         ; Number of APs in A
    2120   00:4C5B                      WAIT_MENU_SCMD_RESPONSE_END:
    2121   00:4C5B  DD E1                   pop ix
    2122   00:4C5D  D1                      pop de
    2123   00:4C5E  C9                      ret
    2124   00:4C5F                      WAIT_MENU_SCMD_RESPONSE_END_NOK:
    2125   00:4C5F  21 00 00                ld  hl,0
    2126   00:4C62  47                      ld  b,a                         ; Return code in B
    2127   00:4C63  AF                      xor a
    2128   00:4C64  DD E1                   pop ix
    2129   00:4C66  D1                      pop de
    2130   00:4C67  C9                      ret
    2131   00:4C68                      
    2132   00:4C68                      ; This routine will check if HL is 0, if it is, will return immediatelly
    2133   00:4C68                      ; If it is not, will decrease HL value and halt (wait one interrupt)
    2134   00:4C68                      HLTIMEOUT:
    2135   00:4C68  7C                      ld  a,h
    2136   00:4C69  B5                      or  l
    2137   00:4C6A  C8                      ret z
    2138   00:4C6B  2B                      dec hl
    2139   00:4C6C  76                      halt
    2140   00:4C6D  C9                      ret
    2141   00:4C6E                      
    2142   00:4C6E                      ; Routine to print the string addressed by HL
    2143   00:4C6E                      PRINTHL:
    2144   00:4C6E  7E                      ld  a,(hl)
    2145   00:4C6F  B7                      or  a
    2146   00:4C70  C8                      ret z                           ; When string is finished, done!
    2147   00:4C71  CD A2 00                call    CHPUT
    2148   00:4C74  23                      inc hl
    2149   00:4C75  C3 6E 4C                jp  PRINTHL
    2150   00:4C78                      
    2151   00:4C78                      ; Routine to print the string addressed by HL on a line, if exceeding it, ends with ..
    2152   00:4C78                      PRINTHLINE:
    2153   00:4C78  C5                      push    bc
    2154   00:4C79  06 18                   ld  b,24
    2155   00:4C7B                      PHLINEL:
    2156   00:4C7B  7E                      ld  a,(hl)
    2157   00:4C7C  B7                      or  a
    2158   00:4C7D  28 1F                   jr  z,PHLINESPC                 ; When string is finished, done!
    2159   00:4C7F  CD A2 00                call    CHPUT
    2160   00:4C82  23                      inc hl
    2161   00:4C83  10 F6                   djnz    PHLINEL
    2162   00:4C85  3E 1D                   ld  a,GOLEFT
    2163   00:4C87  CD A2 00                call    CHPUT
    2164   00:4C8A  CD A2 00                call    CHPUT
    2165   00:4C8D  3E 01                   ld  a,1
    2166   00:4C8F  CD A2 00                call    CHPUT
    2167   00:4C92  3E 5B                   ld  a,91
    2168   00:4C94  CD A2 00                call    CHPUT
    2169   00:4C97  3E 20                   ld  a,' '
    2170   00:4C99  CD A2 00                call    CHPUT
    2171   00:4C9C  18 07                   jr  PHLINELR
    2172   00:4C9E                      PHLINESPC:
    2173   00:4C9E  3E 20                   ld  a,' '
    2174   00:4CA0  CD A2 00                call    CHPUT
    2175   00:4CA3  10 F9                   djnz    PHLINESPC
    2176   00:4CA5                      PHLINELR:
    2177   00:4CA5  3E 1D                   ld  a,GOLEFT
    2178   00:4CA7  CD A2 00                call    CHPUT
    2179   00:4CAA  CD A2 00                call    CHPUT
    2180   00:4CAD  C1                      pop bc
    2181   00:4CAE  C9                      ret
    2182   00:4CAF                      
    2183   00:4CAF                      ;===============================
    2184   00:4CAF                      ;===  HTIM_I hook execution  ===
    2185   00:4CAF                      ;===============================
    2186   00:4CAF                      DO_HTIMI:
    2187   00:4CAF  F5                      push    af                      ; HTIM hook -> need to keep A value
    2188   00:4CB0  CD 9D 59                call    GETCOUNTER              ; Counter in hl
    2189   00:4CB3  7D                      ld  a,l
    2190   00:4CB4  B4                      or  h                           ; In this operation, check if HL is o
    2191   00:4CB5  28 04                   jr  z,DO_HTIMI_END              ; If it is, nothing to do
    2192   00:4CB7  2B                      dec hl                          ; Otherwise decrement it
    2193   00:4CB8  CD AC 59                call    SETCOUNTER              ; And save it
    2194   00:4CBB                      DO_HTIMI_END:
    2195   00:4CBB  CD 0C 59                call    GETSLT
    2196   00:4CBE                          ; Slot in A, now get the address of our counter
    2197   00:4CBE  CD 95 59                call    GETMEMPOINTER
    2198   00:4CC1                          ; HL has the address of our memory area, and there is where we should jump
    2199   00:4CC1  F1                      pop af                          ; Restore original A value
    2200   00:4CC2  E9                      jp  (hl)
    2201   00:4CC3                      
    2202   00:4CC3                      ;===============================
    2203   00:4CC3                      ;===  EXTBIO hook execution  ===
    2204   00:4CC3                      ;===============================
    2205   00:4CC3                      DO_EXTBIO:
    2206   00:4CC3  E5                      push    hl
    2207   00:4CC4  C5                      push    bc
    2208   00:4CC5  F5                      push    af
    2209   00:4CC6  7A                      ld  a,d
    2210   00:4CC7  FE 22                   cp  #22
    2211   00:4CC9  20 43                   jr  nz,JUMP_OLD
    2212   00:4CCB  BB                      cp  e
    2213   00:4CCC  20 40                   jr  nz,JUMP_OLD
    2214   00:4CCE                      
    2215   00:4CCE                          ; Check API ID
    2216   00:4CCE  21 36 69                ld  hl,UNAPI_ID
    2217   00:4CD1  11 47 F8                ld  de,ARG
    2218   00:4CD4                      LOOP:
    2219   00:4CD4  1A                      ld  a,(de)
    2220   00:4CD5  CD E7 5A                call    TOUPPER
    2221   00:4CD8  BE                      cp  (hl)
    2222   00:4CD9  20 30                   jr  nz,JUMP_OLD2
    2223   00:4CDB  23                      inc hl
    2224   00:4CDC  13                      inc de
    2225   00:4CDD  B7                      or  a
    2226   00:4CDE  20 F4                   jr  nz,LOOP
    2227   00:4CE0                      
    2228   00:4CE0                          ; A=255: Jump to old hook
    2229   00:4CE0                      
    2230   00:4CE0  F1                      pop af
    2231   00:4CE1  F5                      push    af
    2232   00:4CE2  3C                      inc a
    2233   00:4CE3  28 26                   jr  z,JUMP_OLD2
    2234   00:4CE5                      
    2235   00:4CE5                          ; A=0: B=B+1 and jump to old hook
    2236   00:4CE5                      
    2237   00:4CE5  CD 0C 59                call    GETSLT
    2238   00:4CE8  CD 65 59                call    GETWRK
    2239   00:4CEB  F1                      pop af
    2240   00:4CEC  C1                      pop bc
    2241   00:4CED  B7                      or  a
    2242   00:4CEE  20 06                   jr  nz,DO_EXTBIO2
    2243   00:4CF0  04                      inc b
    2244   00:4CF1  E3                      ex  (sp),hl
    2245   00:4CF2  11 22 22                ld  de,#2222
    2246   00:4CF5  C9                      ret
    2247   00:4CF6                      
    2248   00:4CF6                      DO_EXTBIO2:
    2249   00:4CF6                          ; A=1: Return A=Slot, B=Segment, HL=UNAPI entry address
    2250   00:4CF6                      
    2251   00:4CF6  3D                      dec a
    2252   00:4CF7  20 0D                   jr  nz,DO_EXTBIO3
    2253   00:4CF9  E1                      pop hl
    2254   00:4CFA  CD 2C 59                call    GETSLTT                 ; GETSLTT is GETSLT that checks if our memory area @ HIMEM has been allocated, if not, allocate it
    2255   00:4CFD  06 FF                   ld  b,#FF
    2256   00:4CFF  21 1A 4D                ld  hl,UNAPI_ENTRY
    2257   00:4D02  11 22 22                ld  de,#2222
    2258   00:4D05  C9                      ret
    2259   00:4D06                      
    2260   00:4D06                          ; A>1: A=A-1, and jump to old hook
    2261   00:4D06                      
    2262   00:4D06                      DO_EXTBIO3:                         ; A=A-1 already done
    2263   00:4D06  E3                      ex  (sp),hl
    2264   00:4D07  11 22 22                ld  de,#2222
    2265   00:4D0A  C9                      ret
    2266   00:4D0B                      
    2267   00:4D0B                      
    2268   00:4D0B                      ; Jump here to execute old EXTBIO code
    2269   00:4D0B                      JUMP_OLD2:
    2270   00:4D0B  11 22 22                ld  de,#2222
    2271   00:4D0E                      JUMP_OLD:                           ; Assumes "push hl,bc,af" done
    2272   00:4D0E  D5                      push    de
    2273   00:4D0F  CD 0C 59                call    GETSLT
    2274   00:4D12  CD 65 59                call    GETWRK
    2275   00:4D15  D1                      pop de
    2276   00:4D16  F1                      pop af
    2277   00:4D17  C1                      pop bc
    2278   00:4D18  E3                      ex  (sp),hl
    2279   00:4D19  C9                      ret
    2280   00:4D1A                      
    2281   00:4D1A                      ;====================================
    2282   00:4D1A                      ;===  Functions entry point code  ===
    2283   00:4D1A                      ;====================================
    2284   00:4D1A                      UNAPI_ENTRY:
    2285   00:4D1A  FB                      ei
    2286   00:4D1B  E5                      push    hl
    2287   00:4D1C  F5                      push    af
    2288   00:4D1D  21 3B 4D                ld  hl,FN_TABLE
    2289   00:4D20  CB 7F                   bit 7,a
    2290   00:4D22                      
    2291   00:4D22                          if  MAX_IMPFN >= 128
    2292   00:4D22                    ~ 
    2293   00:4D22                    ~     jr  z,IS_STANDARD
    2294   00:4D22                    ~     ld  hl,IMPFN_TABLE
    2295   00:4D22                    ~     and %01111111
    2296   00:4D22                    ~     cp  MAX_IMPFN-128
    2297   00:4D22                    ~     jr  z,OK_FNUM
    2298   00:4D22                    ~     jr  nc,UNDEFINED
    2299   00:4D22                    ~ IS_STANDARD:
    2300   00:4D22                    ~ 
    2301   00:4D22                    ~     else
    2302   00:4D22                      
    2303   00:4D22  20 14                   jr  nz,UNDEFINED
    2304   00:4D24                      
    2305   00:4D24                          endif
    2306   00:4D24                      
    2307   00:4D24  FE 1D                   cp  MAX_FN
    2308   00:4D26  28 02                   jr  z,OK_FNUM
    2309   00:4D28  30 0E                   jr  nc,UNDEFINED
    2310   00:4D2A                      
    2311   00:4D2A                      OK_FNUM:
    2312   00:4D2A  87                      add a,a
    2313   00:4D2B  D5                      push    de
    2314   00:4D2C  5F                      ld  e,a
    2315   00:4D2D  16 00                   ld  d,0
    2316   00:4D2F  19                      add hl,de
    2317   00:4D30  D1                      pop de
    2318   00:4D31                      
    2319   00:4D31  7E                      ld  a,(hl)
    2320   00:4D32  23                      inc hl
    2321   00:4D33  66                      ld  h,(hl)
    2322   00:4D34  6F                      ld  l,a
    2323   00:4D35                      
    2324   00:4D35  F1                      pop af
    2325   00:4D36  E3                      ex  (sp),hl
    2326   00:4D37  C9                      ret
    2327   00:4D38                      
    2328   00:4D38                      ; Undefined function: return with registers unmodified
    2329   00:4D38                      UNDEFINED:
    2330   00:4D38  F1                      pop af
    2331   00:4D39  E1                      pop hl
    2332   00:4D3A  C9                      ret
    2333   00:4D3B                      
    2334   00:4D3B                      ;===================================
    2335   00:4D3B                      ;===  Functions addresses table  ===
    2336   00:4D3B                      ;===================================
    2337   00:4D3B                      ;--- Implementation-specific routines addresses table
    2338   00:4D3B                      
    2339   00:4D3B                          if  MAX_IMPFN >= 128
    2340   00:4D3B                    ~ 
    2341   00:4D3B                    ~ IMPFN_TABLE:
    2342   00:4D3B                    ~ FN_128:                 dw  FN_DUMMY
    2343   00:4D3B                    ~ 
    2344   00:4D3B                    ~     endif
    2345   00:4D3B                      
    2346   00:4D3B                      FN_TABLE:
    2347   00:4D3B  8C 4D               FN_0:                   dw  UNAPI_GET_INFO
    2348   00:4D3D  97 4D               FN_1:                   dw  TCPIP_GET_CAPAB
    2349   00:4D3F  EF 4E               FN_2:                   dw  TCPIP_GET_IPINFO
    2350   00:4D41  7E 4F               FN_3:                   dw  TCPIP_NET_STATE
    2351   00:4D43                      ; TCPIP_SEND_ECHO not going to be implemented, ESP do not support ping like UNAPI specify
    2352   00:4D43  77 4D               FN_4:                   dw  FN_NOT_IMP
    2353   00:4D45                      ; TCPIP_RCV_ECHO not going to be implemented as SEND_ECHO is not implemented
    2354   00:4D45  77 4D               FN_5:                   dw  FN_NOT_IMP
    2355   00:4D47  D8 4F               FN_6:                   dw  TCPIP_DNS_Q
    2356   00:4D49  99 50               FN_7:                   dw  TCPIP_DNS_S
    2357   00:4D4B  C6 50               FN_8:                   dw  TCPIP_UDP_OPEN
    2358   00:4D4D  2E 51               FN_9:                   dw  TCPIP_UDP_CLOSE
    2359   00:4D4F  7E 51               FN_10:                  dw  TCPIP_UDP_STATE
    2360   00:4D51  1D 52               FN_11:                  dw  TCPIP_UDP_SEND
    2361   00:4D53  D0 52               FN_12:                  dw  TCPIP_UDP_RCV
    2362   00:4D55  FE 53               FN_13:                  dw  TCPIP_TCP_OPEN
    2363   00:4D57  D3 54               FN_14:                  dw  TCPIP_TCP_CLOSE
    2364   00:4D59  23 55               FN_15:                  dw  TCPIP_TCP_ABORT
    2365   00:4D5B  98 55               FN_16:                  dw  TCPIP_TCP_STATE
    2366   00:4D5D  D2 56               FN_17:                  dw  TCPIP_TCP_SEND
    2367   00:4D5F  79 57               FN_18:                  dw  TCPIP_TCP_RCV
    2368   00:4D61                      ; TCPIP_TCP_FLUSH makes no sense as we do not use buffers to send, any buffer is internal to ESP and we can't delete
    2369   00:4D61  77 4D               FN_19:                  dw  FN_NOT_IMP
    2370   00:4D63                      ; TCPIP_RAW_OPEN not going to be implemented, ESP do not support RAW connections
    2371   00:4D63  77 4D               FN_20:                  dw  FN_NOT_IMP
    2372   00:4D65                      ; TCPIP_RAW_CLOSE not going to be implemented, ESP do not support RAW connections
    2373   00:4D65  77 4D               FN_21:                  dw  FN_NOT_IMP
    2374   00:4D67                      ; TCPIP_RAW_STATE not going to be implemented, ESP do not support RAW connections
    2375   00:4D67  77 4D               FN_22:                  dw  FN_NOT_IMP
    2376   00:4D69                      ; TCPIP_RAW_SEND not going to be implemented, ESP do not support RAW connections
    2377   00:4D69  77 4D               FN_23:                  dw  FN_NOT_IMP
    2378   00:4D6B                      ; TCPIP_RAW_RCV not going to be implemented, ESP do not support RAW connections
    2379   00:4D6B  77 4D               FN_24:                  dw  FN_NOT_IMP
    2380   00:4D6D  3D 58               FN_25:                  dw  TCPIP_CONFIG_AUTOIP
    2381   00:4D6F  A1 58               FN_26:                  dw  TCPIP_CONFIG_IP
    2382   00:4D71  EA 58               FN_27:                  dw  TCPIP_CONFIG_TTL
    2383   00:4D73  FC 58               FN_28:                  dw  TCPIP_CONFIG_PING
    2384   00:4D75                      ; TCPIP_WAIT not needed for our implementation
    2385   00:4D75  7A 4D               FN_29:                  dw  END_OK
    2386   00:4D77                      
    2387   00:4D77                      ;========================
    2388   00:4D77                      ;===  Functions code  ===
    2389   00:4D77                      ;========================
    2390   00:4D77                      FN_NOT_IMP:
    2391   00:4D77  3E 01                   ld  a,ERR_NOT_IMP
    2392   00:4D79  C9                      ret
    2393   00:4D7A                      
    2394   00:4D7A                      END_OK:
    2395   00:4D7A  AF                      xor a
    2396   00:4D7B  C9                      ret
    2397   00:4D7C                      
    2398   00:4D7C                      ; Most functions do not have special handling on time out and can use this.
    2399   00:4D7C                      ; If there is a need to retry sending or receiving on time-out, then a custom
    2400   00:4D7C                      ; time-out function must be done, check the examples of UDP and TCP receive
    2401   00:4D7C                      TCPIP_GENERIC_CHECK_TIME_OUT:
    2402   00:4D7C                          ; Save registers other than AF
    2403   00:4D7C  C5                      push bc
    2404   00:4D7D  D5                      push de
    2405   00:4D7E  E5                      push hl
    2406   00:4D7F  CD 9D 59                call    GETCOUNTER
    2407   00:4D82  7D                      ld  a,l
    2408   00:4D83  B4                      or  h
    2409   00:4D84                          ; Restore registers, we are returning
    2410   00:4D84  E1                      pop hl
    2411   00:4D85  D1                      pop de
    2412   00:4D86  C1                      pop bc
    2413   00:4D87  C0                      ret nz
    2414   00:4D88                          ; Ok, timeout...
    2415   00:4D88  F1                      pop af                          ; Get return address of who called this out of the stack
    2416   00:4D89  3E 0F                   ld  a,ERR_INV_OPER
    2417   00:4D8B  C9                      ret                             ; and return the function itself
    2418   00:4D8C                      
    2419   00:4D8C                      ;========================
    2420   00:4D8C                      ;===  UNAPI_GET_INFO  ===
    2421   00:4D8C                      ;========================
    2422   00:4D8C                      ; Obtain the implementation name and version.
    2423   00:4D8C                      ;
    2424   00:4D8C                      ;    Input:  A  = 0
    2425   00:4D8C                      ;    Output: HL = Descriptive string for this implementation, on this slot, zero terminated
    2426   00:4D8C                      ;            DE = API version supported, D.E
    2427   00:4D8C                      ;            BC = This implementation version, B.C.
    2428   00:4D8C                      ;            A  = 0 and Cy = 0
    2429   00:4D8C                      UNAPI_GET_INFO:
    2430   00:4D8C  01 03 01                ld  bc,256*ROM_V_P+ROM_V_S
    2431   00:4D8F  11 02 01                ld  de,256*API_V_P+API_V_S
    2432   00:4D92  21 3D 69                ld  hl,APIINFO
    2433   00:4D95  AF                      xor a
    2434   00:4D96  C9                      ret
    2435   00:4D97                      
    2436   00:4D97                      ;=========================
    2437   00:4D97                      ;===  TCPIP_GET_CAPAB  ===
    2438   00:4D97                      ;=========================
    2439   00:4D97                      ; Get information about the TCP/IP capabilities and features.
    2440   00:4D97                      ;
    2441   00:4D97                      ;    Input:  A = 1
    2442   00:4D97                      ;            B = Index of information block to retrieve:
    2443   00:4D97                      ;                1: Capabilities and features flags, link level protocol
    2444   00:4D97                      ;                2: Connection pool size and status
    2445   00:4D97                      ;                3: Maximum datagram size allowed
    2446   00:4D97                      ;                4: Second set of capabilities and features flags
    2447   00:4D97                      ;    Output: A = Error code
    2448   00:4D97                      ;        When information block 1 requested:
    2449   00:4D97                      ;            HL = Capabilities flags
    2450   00:4D97                      ;            DE = Features flags
    2451   00:4D97                      ;            B  = Link level protocol used
    2452   00:4D97                      ;        When information block 2 requested:
    2453   00:4D97                      ;            B = Maximum simultaneous TCP connections supported
    2454   00:4D97                      ;            C = Maximum simultaneous UDP connections supported
    2455   00:4D97                      ;            D = Free TCP connections currently available
    2456   00:4D97                      ;            E = Free UDP connections currently available
    2457   00:4D97                      ;            H = Maximum simultaneous raw IP connections supported
    2458   00:4D97                      ;            L = Free raw IP connections currently available
    2459   00:4D97                      ;        When information block 3 requested:
    2460   00:4D97                      ;            HL = Maximum incoming datagram size supported
    2461   00:4D97                      ;            DE = Maximum outgoing datagram size supported
    2462   00:4D97                      ;        When information block 4 requested:
    2463   00:4D97                      ;            HL = Second set of capabilities flags
    2464   00:4D97                      ;            DE = Second set of features flags (currently unused, always zero)
    2465   00:4D97                      TCPIP_GET_CAPAB:
    2466   00:4D97                          SEND_DATA                       ; Send the command
    2466   00:4D97  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2467   00:4D9A  AF                      xor a
    2468   00:4D9B                          SEND_DATA                       ; Send the command size msb
    2468   00:4D9B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2469   00:4D9E  3C                      inc a
    2470   00:4D9F                          SEND_DATA                       ; Send the command size lsb
    2470   00:4D9F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2471   00:4DA2  78                      ld  a,b
    2472   00:4DA3  CD CE 59                call    SETBYTE                 ; Save it, we are going to need it later
    2473   00:4DA6                          SEND_DATA                       ; Send the parameter
    2473   00:4DA6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2474   00:4DA9                      
    2475   00:4DA9                          ; Now wait up to 120 ticks to get response
    2476   00:4DA9  21 78 00                ld  hl,120
    2477   00:4DAC  CD AC 59                call    SETCOUNTER
    2478   00:4DAF                      TCPIP_GET_CAPAB_ST1:
    2479   00:4DAF                          CHECK_DATA
    2479   00:4DAF  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2479   00:4DB2  CB 47             >     bit 0,a
    2480   00:4DB4  20 05                   jr  nz,TCPIP_GET_CAPAB_ST1.1
    2481   00:4DB6  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2482   00:4DB9  18 F4                   jr  TCPIP_GET_CAPAB_ST1
    2483   00:4DBB                      TCPIP_GET_CAPAB_ST1.1:
    2484   00:4DBB                          ; nz, check the data
    2485   00:4DBB                          RECEIVE_DATA
    2485   00:4DBB  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2486   00:4DBE  FE 01                   cp  1                           ; Is response of our command?
    2487   00:4DC0  20 ED                   jr  nz,TCPIP_GET_CAPAB_ST1
    2488   00:4DC2                          ; Now get return code, if return code other than 0, it is finished
    2489   00:4DC2                      TCPIP_GET_CAPAB_RC:
    2490   00:4DC2                          CHECK_DATA
    2490   00:4DC2  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2490   00:4DC5  CB 47             >     bit 0,a
    2491   00:4DC7  20 05                   jr  nz,TCPIP_GET_CAPAB_RC.1
    2492   00:4DC9  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2493   00:4DCC  18 F4                   jr  TCPIP_GET_CAPAB_RC
    2494   00:4DCE                      TCPIP_GET_CAPAB_RC.1:
    2495   00:4DCE                          ; nz, discard
    2496   00:4DCE                          RECEIVE_DATA
    2496   00:4DCE  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2497   00:4DD1  B7                      or  a                           ; 0?
    2498   00:4DD2  C0                      ret nz                          ; If not, done
    2499   00:4DD3                      
    2500   00:4DD3                          ; Next two bytes are return code and size bytes, don't care
    2501   00:4DD3  06 02                   ld  b,2
    2502   00:4DD5                      TCPIP_GET_CAPAB_ST2:
    2503   00:4DD5                          CHECK_DATA
    2503   00:4DD5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2503   00:4DD8  CB 47             >     bit 0,a
    2504   00:4DDA  20 05                   jr  nz,TCPIP_GET_CAPAB_ST2.1
    2505   00:4DDC  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2506   00:4DDF  18 F4                   jr  TCPIP_GET_CAPAB_ST2
    2507   00:4DE1                      TCPIP_GET_CAPAB_ST2.1:
    2508   00:4DE1                          ; Nz, discard
    2509   00:4DE1                          RECEIVE_DATA
    2509   00:4DE1  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2510   00:4DE4  05                      dec b
    2511   00:4DE5  20 EE                   jr  nz,TCPIP_GET_CAPAB_ST2
    2512   00:4DE7                      
    2513   00:4DE7                          ; Now check if block 1, 2 or 3
    2514   00:4DE7  CD BC 59                call    GETBYTE                 ; Get the parameter we saved at the start
    2515   00:4DEA  3D                      dec a
    2516   00:4DEB  CA 9D 4E                jp  z,TCPIP_GET_CAPAB_BLK1      ; 1
    2517   00:4DEE  3D                      dec a
    2518   00:4DEF  CA 3B 4E                jp  z,TCPIP_GET_CAPAB_BLK2      ; 2
    2519   00:4DF2  3D                      dec a
    2520   00:4DF3  CA F9 4D                jp  z,TCPIP_GET_CAPAB_BLK3      ; 3
    2521   00:4DF6                          ; Else, only block four, same as block 1
    2522   00:4DF6  C3 9D 4E                jp  TCPIP_GET_CAPAB_BLK1        ; 1
    2523   00:4DF9                          ; Block 3 Handling, we will receive L, H, E and D
    2524   00:4DF9                      TCPIP_GET_CAPAB_BLK3:
    2525   00:4DF9                      TCPIP_GET_CAPAB_BLK3_ST1:
    2526   00:4DF9                          CHECK_DATA
    2526   00:4DF9  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2526   00:4DFC  CB 47             >     bit 0,a
    2527   00:4DFE  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST1.1
    2528   00:4E00  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2529   00:4E03  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST1
    2530   00:4E05                      TCPIP_GET_CAPAB_BLK3_ST1.1:
    2531   00:4E05                          ; nz, get it
    2532   00:4E05                          RECEIVE_DATA
    2532   00:4E05  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2533   00:4E08  6F                      ld  l,a
    2534   00:4E09                      TCPIP_GET_CAPAB_BLK3_ST2:
    2535   00:4E09                          CHECK_DATA
    2535   00:4E09  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2535   00:4E0C  CB 47             >     bit 0,a
    2536   00:4E0E  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST2.1
    2537   00:4E10  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2538   00:4E13  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST2
    2539   00:4E15                      TCPIP_GET_CAPAB_BLK3_ST2.1:
    2540   00:4E15                          ; nz, get it
    2541   00:4E15                          RECEIVE_DATA
    2541   00:4E15  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2542   00:4E18  67                      ld  h,a
    2543   00:4E19                      TCPIP_GET_CAPAB_BLK3_ST3:
    2544   00:4E19                          CHECK_DATA
    2544   00:4E19  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2544   00:4E1C  CB 47             >     bit 0,a
    2545   00:4E1E  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST3.1
    2546   00:4E20  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2547   00:4E23  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST3
    2548   00:4E25                      TCPIP_GET_CAPAB_BLK3_ST3.1:
    2549   00:4E25                          ; nz, get it
    2550   00:4E25                          RECEIVE_DATA
    2550   00:4E25  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2551   00:4E28  5F                      ld  e,a
    2552   00:4E29                      TCPIP_GET_CAPAB_BLK3_ST4:
    2553   00:4E29                          CHECK_DATA
    2553   00:4E29  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2553   00:4E2C  CB 47             >     bit 0,a
    2554   00:4E2E  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK3_ST4.1
    2555   00:4E30  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2556   00:4E33  18 F4                   jr  TCPIP_GET_CAPAB_BLK3_ST4
    2557   00:4E35                      TCPIP_GET_CAPAB_BLK3_ST4.1:
    2558   00:4E35                          ; nz, get it
    2559   00:4E35                          RECEIVE_DATA
    2559   00:4E35  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2560   00:4E38  57                      ld  d,a
    2561   00:4E39                          ; Done
    2562   00:4E39  AF                      xor a
    2563   00:4E3A  C9                      ret
    2564   00:4E3B                      
    2565   00:4E3B                      TCPIP_GET_CAPAB_BLK2:
    2566   00:4E3B                          ; Block 2 Handling, we will receive B, C, D, E, H, L
    2567   00:4E3B                      TCPIP_GET_CAPAB_BLK2_ST1:
    2568   00:4E3B                          CHECK_DATA
    2568   00:4E3B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2568   00:4E3E  CB 47             >     bit 0,a
    2569   00:4E40  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST1.1
    2570   00:4E42  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2571   00:4E45  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST1
    2572   00:4E47                      TCPIP_GET_CAPAB_BLK2_ST1.1:
    2573   00:4E47                          ; nz, get it
    2574   00:4E47                          RECEIVE_DATA
    2574   00:4E47  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2575   00:4E4A  47                      ld  b,a
    2576   00:4E4B                      TCPIP_GET_CAPAB_BLK2_ST2:
    2577   00:4E4B                          CHECK_DATA
    2577   00:4E4B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2577   00:4E4E  CB 47             >     bit 0,a
    2578   00:4E50  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST2.1
    2579   00:4E52  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2580   00:4E55  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST2
    2581   00:4E57                      TCPIP_GET_CAPAB_BLK2_ST2.1:
    2582   00:4E57                          ; nz, get it
    2583   00:4E57                          RECEIVE_DATA
    2583   00:4E57  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2584   00:4E5A  4F                      ld  c,a
    2585   00:4E5B                      TCPIP_GET_CAPAB_BLK2_ST3:
    2586   00:4E5B                          CHECK_DATA
    2586   00:4E5B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2586   00:4E5E  CB 47             >     bit 0,a
    2587   00:4E60  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST3.1
    2588   00:4E62  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2589   00:4E65  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST3
    2590   00:4E67                      TCPIP_GET_CAPAB_BLK2_ST3.1:
    2591   00:4E67                          ; nz, get it
    2592   00:4E67                          RECEIVE_DATA
    2592   00:4E67  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2593   00:4E6A  57                      ld  d,a
    2594   00:4E6B                      TCPIP_GET_CAPAB_BLK2_ST4:
    2595   00:4E6B                          CHECK_DATA
    2595   00:4E6B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2595   00:4E6E  CB 47             >     bit 0,a
    2596   00:4E70  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST4.1
    2597   00:4E72  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2598   00:4E75  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST4
    2599   00:4E77                      TCPIP_GET_CAPAB_BLK2_ST4.1:
    2600   00:4E77                          ; nz, get it
    2601   00:4E77                          RECEIVE_DATA
    2601   00:4E77  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2602   00:4E7A  5F                      ld  e,a
    2603   00:4E7B                      TCPIP_GET_CAPAB_BLK2_ST5:
    2604   00:4E7B                          CHECK_DATA
    2604   00:4E7B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2604   00:4E7E  CB 47             >     bit 0,a
    2605   00:4E80  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST5.1
    2606   00:4E82  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2607   00:4E85  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST5
    2608   00:4E87                      TCPIP_GET_CAPAB_BLK2_ST5.1:
    2609   00:4E87                          ; nz, get it
    2610   00:4E87                          RECEIVE_DATA
    2610   00:4E87  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2611   00:4E8A  67                      ld  h,a
    2612   00:4E8B                      TCPIP_GET_CAPAB_BLK2_ST6:
    2613   00:4E8B                          CHECK_DATA
    2613   00:4E8B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2613   00:4E8E  CB 47             >     bit 0,a
    2614   00:4E90  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK2_ST6.1
    2615   00:4E92  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2616   00:4E95  18 F4                   jr  TCPIP_GET_CAPAB_BLK2_ST6
    2617   00:4E97                      TCPIP_GET_CAPAB_BLK2_ST6.1:
    2618   00:4E97                          ; nz, get it
    2619   00:4E97                          RECEIVE_DATA
    2619   00:4E97  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2620   00:4E9A  6F                      ld  l,a
    2621   00:4E9B                          ; Done
    2622   00:4E9B  AF                      xor a
    2623   00:4E9C  C9                      ret
    2624   00:4E9D                      
    2625   00:4E9D                      TCPIP_GET_CAPAB_BLK1:
    2626   00:4E9D                          ; Block 1 Handling, we will receive L, H, E, D and B
    2627   00:4E9D                      TCPIP_GET_CAPAB_BLK1_ST1:
    2628   00:4E9D                          CHECK_DATA
    2628   00:4E9D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2628   00:4EA0  CB 47             >     bit 0,a
    2629   00:4EA2  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST1.1
    2630   00:4EA4  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2631   00:4EA7  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST1
    2632   00:4EA9                      TCPIP_GET_CAPAB_BLK1_ST1.1:
    2633   00:4EA9                          ; nz, get it
    2634   00:4EA9                          RECEIVE_DATA
    2634   00:4EA9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2635   00:4EAC  6F                      ld  l,a
    2636   00:4EAD                      TCPIP_GET_CAPAB_BLK1_ST2:
    2637   00:4EAD                          CHECK_DATA
    2637   00:4EAD  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2637   00:4EB0  CB 47             >     bit 0,a
    2638   00:4EB2  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST2.1
    2639   00:4EB4  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2640   00:4EB7  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST2
    2641   00:4EB9                      TCPIP_GET_CAPAB_BLK1_ST2.1:
    2642   00:4EB9                          ; nz, get it
    2643   00:4EB9                          RECEIVE_DATA
    2643   00:4EB9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2644   00:4EBC  67                      ld  h,a
    2645   00:4EBD                      TCPIP_GET_CAPAB_BLK1_ST3:
    2646   00:4EBD                          CHECK_DATA
    2646   00:4EBD  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2646   00:4EC0  CB 47             >     bit 0,a
    2647   00:4EC2  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST3.1
    2648   00:4EC4  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2649   00:4EC7  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST3
    2650   00:4EC9                      TCPIP_GET_CAPAB_BLK1_ST3.1:
    2651   00:4EC9                          ; nz, get it
    2652   00:4EC9                          RECEIVE_DATA
    2652   00:4EC9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2653   00:4ECC  5F                      ld  e,a
    2654   00:4ECD                      TCPIP_GET_CAPAB_BLK1_ST4:
    2655   00:4ECD                          CHECK_DATA
    2655   00:4ECD  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2655   00:4ED0  CB 47             >     bit 0,a
    2656   00:4ED2  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST4.1
    2657   00:4ED4  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2658   00:4ED7  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST4
    2659   00:4ED9                      TCPIP_GET_CAPAB_BLK1_ST4.1:
    2660   00:4ED9                          ; nz, get it
    2661   00:4ED9                          RECEIVE_DATA
    2661   00:4ED9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2662   00:4EDC  57                      ld  d,a
    2663   00:4EDD                      TCPIP_GET_CAPAB_BLK1_ST5:
    2664   00:4EDD                          CHECK_DATA
    2664   00:4EDD  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2664   00:4EE0  CB 47             >     bit 0,a
    2665   00:4EE2  20 05                   jr  nz,TCPIP_GET_CAPAB_BLK1_ST5.1
    2666   00:4EE4  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2667   00:4EE7  18 F4                   jr  TCPIP_GET_CAPAB_BLK1_ST5
    2668   00:4EE9                      TCPIP_GET_CAPAB_BLK1_ST5.1:
    2669   00:4EE9                          ; nz, get it
    2670   00:4EE9                          RECEIVE_DATA
    2670   00:4EE9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2671   00:4EEC  47                      ld  b,a
    2672   00:4EED                          ; Done
    2673   00:4EED  AF                      xor a
    2674   00:4EEE  C9                      ret
    2675   00:4EEF                      
    2676   00:4EEF                      ;==========================
    2677   00:4EEF                      ;===  TCPIP_GET_IPINFO  ===
    2678   00:4EEF                      ;==========================
    2679   00:4EEF                      ;Get IP address.
    2680   00:4EEF                      ;
    2681   00:4EEF                      ;Input:  A = 2
    2682   00:4EEF                      ;        B = Index of address to obtain:
    2683   00:4EEF                      ;            1: Local IP address
    2684   00:4EEF                      ;            2: Peer IP address
    2685   00:4EEF                      ;            3: Subnet mask
    2686   00:4EEF                      ;            4: Default gateway
    2687   00:4EEF                      ;            5: Primary DNS server IP address
    2688   00:4EEF                      ;            6: Secondary DNS server IP address
    2689   00:4EEF                      ;Output: A = Error code
    2690   00:4EEF                      ;        L.H.E.D = Requested address
    2691   00:4EEF                      TCPIP_GET_IPINFO:
    2692   00:4EEF                          SEND_DATA                       ; Send the command
    2692   00:4EEF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2693   00:4EF2  AF                      xor a
    2694   00:4EF3                          SEND_DATA                       ; Send the command size msb
    2694   00:4EF3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2695   00:4EF6  3C                      inc a
    2696   00:4EF7                          SEND_DATA                       ; Send the command size lsb
    2696   00:4EF7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2697   00:4EFA  78                      ld  a,b
    2698   00:4EFB                          SEND_DATA
    2698   00:4EFB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2699   00:4EFE                      
    2700   00:4EFE                          ; Now wait up to 600 ticks to get response
    2701   00:4EFE  21 58 02                ld  hl,600
    2702   00:4F01  CD AC 59                call    SETCOUNTER
    2703   00:4F04                      TCPIP_GET_IPINFO_ST1:
    2704   00:4F04                          CHECK_DATA
    2704   00:4F04  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2704   00:4F07  CB 47             >     bit 0,a
    2705   00:4F09  20 05                   jr  nz,TCPIP_GET_IPINFO_ST1.1
    2706   00:4F0B  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2707   00:4F0E  18 F4                   jr  TCPIP_GET_IPINFO_ST1
    2708   00:4F10                      TCPIP_GET_IPINFO_ST1.1:
    2709   00:4F10                          ; nz, check the data
    2710   00:4F10                          RECEIVE_DATA
    2710   00:4F10  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2711   00:4F13  FE 02                   cp  2                           ; Is response of our command?
    2712   00:4F15  20 ED                   jr  nz,TCPIP_GET_IPINFO_ST1
    2713   00:4F17                          ; now get return code, if return code other than 0, it is finished
    2714   00:4F17                      TCPIP_GET_IPINFO_RC:
    2715   00:4F17                          CHECK_DATA
    2715   00:4F17  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2715   00:4F1A  CB 47             >     bit 0,a
    2716   00:4F1C  20 05                   jr  nz,TCPIP_GET_IPINFO_RC.1
    2717   00:4F1E  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2718   00:4F21  18 F4                   jr  TCPIP_GET_IPINFO_RC
    2719   00:4F23                      TCPIP_GET_IPINFO_RC.1:
    2720   00:4F23                          ; nz, discard
    2721   00:4F23                          RECEIVE_DATA
    2721   00:4F23  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2722   00:4F26  B7                      or  a                           ; 0?
    2723   00:4F27  C0                      ret nz                          ; if not, done
    2724   00:4F28                      
    2725   00:4F28                          ; next two bytes are return code and size bytes, don't care, it is 4
    2726   00:4F28  06 02                   ld  b,2
    2727   00:4F2A                      TCPIP_GET_IPINFO_ST2:
    2728   00:4F2A                          CHECK_DATA
    2728   00:4F2A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2728   00:4F2D  CB 47             >     bit 0,a
    2729   00:4F2F  20 05                   jr  nz,TCPIP_GET_IPINFO_ST2.1
    2730   00:4F31  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2731   00:4F34  18 F4                   jr  TCPIP_GET_IPINFO_ST2
    2732   00:4F36                      TCPIP_GET_IPINFO_ST2.1:
    2733   00:4F36                          ; nz, discard
    2734   00:4F36                          RECEIVE_DATA
    2734   00:4F36  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2735   00:4F39  05                      dec b
    2736   00:4F3A  20 EE                   jr  nz,TCPIP_GET_IPINFO_ST2
    2737   00:4F3C                      
    2738   00:4F3C                          ; now just get the 4 bytes IP and order it in L, H, E and D
    2739   00:4F3C                      TCPIP_GET_IPINFO_IP_ST1:
    2740   00:4F3C                          CHECK_DATA
    2740   00:4F3C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2740   00:4F3F  CB 47             >     bit 0,a
    2741   00:4F41  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST1.1
    2742   00:4F43  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2743   00:4F46  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST1
    2744   00:4F48                      TCPIP_GET_IPINFO_IP_ST1.1:
    2745   00:4F48                          ; nz, get it
    2746   00:4F48                          RECEIVE_DATA
    2746   00:4F48  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2747   00:4F4B  6F                      ld  l,a
    2748   00:4F4C                      TCPIP_GET_IPINFO_IP_ST2:
    2749   00:4F4C                          CHECK_DATA
    2749   00:4F4C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2749   00:4F4F  CB 47             >     bit 0,a
    2750   00:4F51  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST2.1
    2751   00:4F53  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2752   00:4F56  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST2
    2753   00:4F58                      TCPIP_GET_IPINFO_IP_ST2.1:
    2754   00:4F58                          ; nz, get it
    2755   00:4F58                          RECEIVE_DATA
    2755   00:4F58  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2756   00:4F5B  67                      ld  h,a
    2757   00:4F5C                      TCPIP_GET_IPINFO_IP_ST3:
    2758   00:4F5C                          CHECK_DATA
    2758   00:4F5C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2758   00:4F5F  CB 47             >     bit 0,a
    2759   00:4F61  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST3.1
    2760   00:4F63  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2761   00:4F66  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST3
    2762   00:4F68                      TCPIP_GET_IPINFO_IP_ST3.1:
    2763   00:4F68                          ; nz, get it
    2764   00:4F68                          RECEIVE_DATA
    2764   00:4F68  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2765   00:4F6B  5F                      ld  e,a
    2766   00:4F6C                      TCPIP_GET_IPINFO_IP_ST4:
    2767   00:4F6C                          CHECK_DATA
    2767   00:4F6C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2767   00:4F6F  CB 47             >     bit 0,a
    2768   00:4F71  20 05                   jr  nz,TCPIP_GET_IPINFO_IP_ST4.1
    2769   00:4F73  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2770   00:4F76  18 F4                   jr  TCPIP_GET_IPINFO_IP_ST4
    2771   00:4F78                      TCPIP_GET_IPINFO_IP_ST4.1:
    2772   00:4F78                          ; nz, get it
    2773   00:4F78                          RECEIVE_DATA
    2773   00:4F78  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2774   00:4F7B  57                      ld  d,a
    2775   00:4F7C                          ; done
    2776   00:4F7C  AF                      xor a
    2777   00:4F7D  C9                      ret
    2778   00:4F7E                      
    2779   00:4F7E                      ;=========================
    2780   00:4F7E                      ;===  TCPIP_NET_STATE  ===
    2781   00:4F7E                      ;=========================
    2782   00:4F7E                      ;Get network state.
    2783   00:4F7E                      ;
    2784   00:4F7E                      ;Input:  A = 3
    2785   00:4F7E                      ;Output: A = Error code
    2786   00:4F7E                      ;        B = Current network state:
    2787   00:4F7E                      ;            0: Closed
    2788   00:4F7E                      ;            1: Opening
    2789   00:4F7E                      ;            2: Open
    2790   00:4F7E                      ;            3: Closing
    2791   00:4F7E                      ;            255: Unknown
    2792   00:4F7E                      TCPIP_NET_STATE:
    2793   00:4F7E                          SEND_DATA                       ; Send the command
    2793   00:4F7E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2794   00:4F81  AF                      xor a
    2795   00:4F82                          SEND_DATA                       ; Send the command size msb
    2795   00:4F82  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2796   00:4F85                          SEND_DATA                       ; Send the command size lsb
    2796   00:4F85  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2797   00:4F88                      
    2798   00:4F88                          ; Now wait up to 720 ticks to get response
    2799   00:4F88  21 D0 02                ld  hl,720
    2800   00:4F8B  CD AC 59                call    SETCOUNTER
    2801   00:4F8E                      TCPIP_NET_STATE_ST1:
    2802   00:4F8E                          CHECK_DATA
    2802   00:4F8E  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2802   00:4F91  CB 47             >     bit 0,a
    2803   00:4F93  20 05                   jr  nz,TCPIP_NET_STATE_ST1.1
    2804   00:4F95  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2805   00:4F98  18 F4                   jr  TCPIP_NET_STATE_ST1
    2806   00:4F9A                      TCPIP_NET_STATE_ST1.1:
    2807   00:4F9A                          ; nz, check the data
    2808   00:4F9A                          RECEIVE_DATA
    2808   00:4F9A  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2809   00:4F9D  FE 03                   cp  3                           ; Is response of our command?
    2810   00:4F9F  20 ED                   jr  nz,TCPIP_NET_STATE_ST1
    2811   00:4FA1                          ; now get return code, if return code other than 0, it is finished
    2812   00:4FA1                      TCPIP_NET_STATE_RC:
    2813   00:4FA1                          CHECK_DATA
    2813   00:4FA1  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2813   00:4FA4  CB 47             >     bit 0,a
    2814   00:4FA6  20 05                   jr  nz,TCPIP_NET_STATE_RC.1
    2815   00:4FA8  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2816   00:4FAB  18 F4                   jr  TCPIP_NET_STATE_RC
    2817   00:4FAD                      TCPIP_NET_STATE_RC.1:
    2818   00:4FAD                          ; nz, get it
    2819   00:4FAD                          RECEIVE_DATA
    2819   00:4FAD  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2820   00:4FB0  B7                      or  a                           ; 0?
    2821   00:4FB1  C0                      ret nz                          ; if not, done
    2822   00:4FB2                      
    2823   00:4FB2                          ; next two bytes are return code and size bytes, don't care, it is 1
    2824   00:4FB2  06 02                   ld  b,2
    2825   00:4FB4                      TCPIP_NET_STATE_ST2:
    2826   00:4FB4                          CHECK_DATA
    2826   00:4FB4  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2826   00:4FB7  CB 47             >     bit 0,a
    2827   00:4FB9  20 05                   jr  nz,TCPIP_NET_STATE_ST2.1
    2828   00:4FBB  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2829   00:4FBE  18 F4                   jr  TCPIP_NET_STATE_ST2
    2830   00:4FC0                      TCPIP_NET_STATE_ST2.1:
    2831   00:4FC0                          ; nz, discard
    2832   00:4FC0                          RECEIVE_DATA
    2832   00:4FC0  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2833   00:4FC3  05                      dec b
    2834   00:4FC4  20 EE                   jr  nz,TCPIP_NET_STATE_ST2
    2835   00:4FC6                      
    2836   00:4FC6                          ; now just get the 1 byte (NET STATE) IP and place it in B
    2837   00:4FC6                      TCPIP_NET_STATE_NS_ST1:
    2838   00:4FC6                          CHECK_DATA
    2838   00:4FC6  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2838   00:4FC9  CB 47             >     bit 0,a
    2839   00:4FCB  20 05                   jr  nz,TCPIP_NET_STATE_NS_ST1.1
    2840   00:4FCD  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2841   00:4FD0  18 F4                   jr  TCPIP_NET_STATE_NS_ST1
    2842   00:4FD2                      TCPIP_NET_STATE_NS_ST1.1:
    2843   00:4FD2                          ; nz, get it
    2844   00:4FD2                          RECEIVE_DATA
    2844   00:4FD2  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2845   00:4FD5  47                      ld  b,a
    2846   00:4FD6                          ; done
    2847   00:4FD6  AF                      xor a
    2848   00:4FD7  C9                      ret
    2849   00:4FD8                      
    2850   00:4FD8                      ;=====================
    2851   00:4FD8                      ;===  TCPIP_DNS_Q  ===
    2852   00:4FD8                      ;=====================
    2853   00:4FD8                      ;Start a host name resolution query.
    2854   00:4FD8                      ;
    2855   00:4FD8                      ;Input:  A  = 6
    2856   00:4FD8                      ;        HL = Address of the host name to be resolved, zero terminated
    2857   00:4FD8                      ;        B  = Flags, when set to 1 they instruct the resolver to:
    2858   00:4FD8                      ;             bit 0: Only abort the query currently in progress, if there is any
    2859   00:4FD8                      ;                    (other flags and registers are then ignored)
    2860   00:4FD8                      ;             bit 1: Assume that the passed name is an IP address,
    2861   00:4FD8                      ;                    and return an error if this is not true
    2862   00:4FD8                      ;             bit 2: If there is a query in progress already,
    2863   00:4FD8                      ;                    do NOT abort it and return an error instead
    2864   00:4FD8                      ;Output:  A = Error code
    2865   00:4FD8                      ;         B = 0 if a query to a DNS server is in progress
    2866   00:4FD8                      ;             1 if the name represented an IP address
    2867   00:4FD8                      ;             2 if the name could be resolved locally
    2868   00:4FD8                      ;         L.H.E.D = Resolved IP address
    2869   00:4FD8                      ;                   (only if no error occurred and B=1 or 2 is returned)
    2870   00:4FD8                      ;RAM Buffer to store names to be resolved (and used also to translate IPs from ASCII to 32bits number)
    2871   00:4FD8                      ;Will store the result of the last DNS query
    2872   00:4FD8                      TCPIP_DNS_Q:
    2873   00:4FD8  E5                      push    hl                      ; Save HL
    2874   00:4FD9  AF                      xor a
    2875   00:4FDA  5F                      ld  e,a
    2876   00:4FDB  57                      ld  d,a                         ; Zero DE
    2877   00:4FDC                      TCPIP_DNS_Q_SIZE_LOOP:
    2878   00:4FDC  7E                      ld  a,(hl)                      ; so let's check the size of dns data
    2879   00:4FDD  B7                      or  a                           ; it is zero terminated
    2880   00:4FDE  28 05                   jr  z,TCPIP_DNS_Q_SEND          ; if zero, end of string
    2881   00:4FE0  13                      inc de                          ; ok, not zero, one more char
    2882   00:4FE1  23                      inc hl                          ; next
    2883   00:4FE2  C3 DC 4F                jp  TCPIP_DNS_Q_SIZE_LOOP       ; jp is a tad bit faster and we are not worried about code size
    2884   00:4FE5                      TCPIP_DNS_Q_SEND:
    2885   00:4FE5                          ; Here we send the query and wait the result
    2886   00:4FE5  13                      inc de                          ; add 1, we will send flag first
    2887   00:4FE6  3E CE                   ld  a,206                       ; DNS_Q_NEW
    2888   00:4FE8                          SEND_DATA                       ; Send the command
    2888   00:4FE8  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2889   00:4FEB  7A                      ld  a,d
    2890   00:4FEC                          SEND_DATA                       ; Send the command size msb
    2890   00:4FEC  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2891   00:4FEF  7B                      ld  a,e
    2892   00:4FF0                          SEND_DATA                       ; Send the command size lsb
    2892   00:4FF0  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2893   00:4FF3  78                      ld  a,b
    2894   00:4FF4                          SEND_DATA                       ; Send the flag byte
    2894   00:4FF4  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    2895   00:4FF7                      
    2896   00:4FF7                          if USE_MEM_IO = 0
    2897   00:4FF7                    ~     ; now otir of DNS/DNS BUFFER DATA SIZE
    2898   00:4FF7                    ~     ld  c,OUT_TX_PORT               ; our data TX port
    2899   00:4FF7                    ~     endif
    2900   00:4FF7  E1                      pop hl                          ; string to try to resolve
    2901   00:4FF8  1B                      dec de                          ; we are sending just data addressed by HL, so revert count
    2902   00:4FF9  7A                      ld  a,d
    2903   00:4FFA  B3                      or  e                           ; if de zero, no string, wrong parameters, but let the ESP answer
    2904   00:4FFB  CA 0D 50                jp  z,TCPIP_DNS_Q_WAIT_RSP
    2905   00:4FFE  AF                      xor a
    2906   00:4FFF                          ; Fast 16 bit variable size loop by GRAUW
    2907   00:4FFF  43                      ld  b,e
    2908   00:5000  1B                      dec de
    2909   00:5001  14                      inc d
    2910   00:5002                      TCPIP_DNS_Q_SENDLP:
    2911   00:5002                          ; send it
    2912   00:5002                          if USE_MEM_IO = 0
    2913   00:5002                    ~     outi
    2914   00:5002                    ~     jp  nz,TCPIP_DNS_Q_SENDLP
    2915   00:5002                    ~     else
    2916   00:5002  7E                      ld  a,(hl)
    2917   00:5003  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    2918   00:5006  23                      inc hl
    2919   00:5007  10 F9                   djnz TCPIP_DNS_Q_SENDLP
    2920   00:5009                          endif
    2921   00:5009  15                      dec d
    2922   00:500A  C2 02 50                jp  nz,TCPIP_DNS_Q_SENDLP
    2923   00:500D                      TCPIP_DNS_Q_WAIT_RSP:
    2924   00:500D                          ; Now wait up to 900 ticks (15s@60Hz) to get response
    2925   00:500D  21 84 03                ld  hl,900
    2926   00:5010  CD AC 59                call    SETCOUNTER
    2927   00:5013                      TCPIP_DNSQ_SEND_ST1:
    2928   00:5013                          CHECK_DATA
    2928   00:5013  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2928   00:5016  CB 47             >     bit 0,a
    2929   00:5018  20 05                   jr  nz,TCPIP_DNSQ_SEND_ST1.1
    2930   00:501A  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2931   00:501D  18 F4                   jr  TCPIP_DNSQ_SEND_ST1
    2932   00:501F                      TCPIP_DNSQ_SEND_ST1.1:
    2933   00:501F                          ; nz, check the data
    2934   00:501F                          RECEIVE_DATA
    2934   00:501F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2935   00:5022  FE CE                   cp  206                         ; Is response of our command?
    2936   00:5024  20 ED                   jr  nz,TCPIP_DNSQ_SEND_ST1
    2937   00:5026                          ; now get return code, if return code other than 0, it is finished
    2938   00:5026                      TCPIP_DNSQ_SEND_RC:
    2939   00:5026                          CHECK_DATA
    2939   00:5026  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2939   00:5029  CB 47             >     bit 0,a
    2940   00:502B  20 05                   jr  nz,TCPIP_DNSQ_SEND_RC.1
    2941   00:502D  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2942   00:5030  18 F4                   jr  TCPIP_DNSQ_SEND_RC
    2943   00:5032                      TCPIP_DNSQ_SEND_RC.1:
    2944   00:5032                          ; nz, discard
    2945   00:5032                          RECEIVE_DATA
    2945   00:5032  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2946   00:5035  B7                      or  a                           ; 0?
    2947   00:5036  06 00                   ld  b,0                         ; say in progress as there is no failure status
    2948   00:5038  C0                      ret nz                          ; if not, done, ERROR won't return data
    2949   00:5039                      
    2950   00:5039                          ; next two bytes are return code and size bytes, don't care, it is 4, resolved IP
    2951   00:5039  06 02                   ld  b,2
    2952   00:503B                      TCPIP_DNSQ_SEND_RC_ST2:
    2953   00:503B                          CHECK_DATA
    2953   00:503B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2953   00:503E  CB 47             >     bit 0,a
    2954   00:5040  20 05                   jr  nz,TCPIP_DNSQ_SEND_RC_ST2.1
    2955   00:5042  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2956   00:5045  18 F4                   jr  TCPIP_DNSQ_SEND_RC_ST2
    2957   00:5047                      TCPIP_DNSQ_SEND_RC_ST2.1:
    2958   00:5047                          ; nz, discard
    2959   00:5047                          RECEIVE_DATA
    2959   00:5047  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2960   00:504A  05                      dec b
    2961   00:504B  20 EE                   jr  nz,TCPIP_DNSQ_SEND_RC_ST2
    2962   00:504D                      
    2963   00:504D                          ; now just get the 4 bytes IP and place it in L H E D
    2964   00:504D                      TCPIP_DNSQ_IP_ST1:
    2965   00:504D                          CHECK_DATA
    2965   00:504D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2965   00:5050  CB 47             >     bit 0,a
    2966   00:5052  20 05                   jr  nz,TCPIP_DNSQ_IP_ST1.1
    2967   00:5054  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2968   00:5057  18 F4                   jr  TCPIP_DNSQ_IP_ST1
    2969   00:5059                      TCPIP_DNSQ_IP_ST1.1:
    2970   00:5059                          ; nz, get it
    2971   00:5059                          RECEIVE_DATA
    2971   00:5059  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2972   00:505C  6F                      ld  l,a
    2973   00:505D                      TCPIP_DNSQ_IP_ST2:
    2974   00:505D                          CHECK_DATA
    2974   00:505D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2974   00:5060  CB 47             >     bit 0,a
    2975   00:5062  20 05                   jr  nz,TCPIP_DNSQ_IP_ST2.1
    2976   00:5064  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2977   00:5067  18 F4                   jr  TCPIP_DNSQ_IP_ST2
    2978   00:5069                      TCPIP_DNSQ_IP_ST2.1:
    2979   00:5069                          ; nz, get it
    2980   00:5069                          RECEIVE_DATA
    2980   00:5069  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2981   00:506C  67                      ld  h,a
    2982   00:506D                      TCPIP_DNSQ_IP_ST3:
    2983   00:506D                          CHECK_DATA
    2983   00:506D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2983   00:5070  CB 47             >     bit 0,a
    2984   00:5072  20 05                   jr  nz,TCPIP_DNSQ_IP_ST3.1
    2985   00:5074  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2986   00:5077  18 F4                   jr  TCPIP_DNSQ_IP_ST3
    2987   00:5079                      TCPIP_DNSQ_IP_ST3.1:
    2988   00:5079                          ; nz, get it
    2989   00:5079                          RECEIVE_DATA
    2989   00:5079  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2990   00:507C  5F                      ld  e,a
    2991   00:507D                      TCPIP_DNSQ_IP_ST4:
    2992   00:507D                          CHECK_DATA
    2992   00:507D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    2992   00:5080  CB 47             >     bit 0,a
    2993   00:5082  20 05                   jr  nz,TCPIP_DNSQ_IP_ST4.1
    2994   00:5084  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    2995   00:5087  18 F4                   jr  TCPIP_DNSQ_IP_ST4
    2996   00:5089                      TCPIP_DNSQ_IP_ST4.1:
    2997   00:5089                          ; nz, get it
    2998   00:5089                          RECEIVE_DATA
    2998   00:5089  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    2999   00:508C  57                      ld  d,a
    3000   00:508D                          ; done
    3001   00:508D  3E 01                   ld  a,1
    3002   00:508F  CD A3 5A                call    SETDNSREADY             ; DNS done
    3003   00:5092  CD CD 5A                call    SETDNSRESULT            ; DNS RESULT
    3004   00:5095  06 02                   ld  b,2
    3005   00:5097  AF                      xor a
    3006   00:5098  C9                      ret
    3007   00:5099                      
    3008   00:5099                      ;=====================
    3009   00:5099                      ;===  TCPIP_DNS_S  ===
    3010   00:5099                      ;=====================
    3011   00:5099                      ;Obtains the host name resolution process state and result.
    3012   00:5099                      ;
    3013   00:5099                      ;Input:  A = 7
    3014   00:5099                      ;        B = Flags, when set to 1 they instruct the resolver to:
    3015   00:5099                      ;            bit 0: Clear any existing result or error condition after the execution
    3016   00:5099                      ;                   (except if there is a query in progress)
    3017   00:5099                      ;Output: A = Error code
    3018   00:5099                      ;        B = DNS error code (when error is ERR_DNS)
    3019   00:5099                      ;        B = Current query status (when error is ERR_OK):
    3020   00:5099                      ;            0: There is no query in progress, nor any result nor error code available
    3021   00:5099                      ;            1: There is a query in progress
    3022   00:5099                      ;            2: Query is complete
    3023   00:5099                      ;        C = Current query sub status (when error is ERR_OK and B=1):
    3024   00:5099                      ;            0: Unknown
    3025   00:5099                      ;            1: Querying the primary DNS server
    3026   00:5099                      ;            2: Querying the secondary DNS server
    3027   00:5099                      ;            3: Querying another DNS server
    3028   00:5099                      ;        C = Resolution process type (when error is ERR_OK and B=2):
    3029   00:5099                      ;            0: The name was obtained by querying a DNS server
    3030   00:5099                      ;            1: The name was a direct representation of an IP address
    3031   00:5099                      ;            2: The name was resolved locally
    3032   00:5099                      ;       L.H.E.D = Resolved IP address (when error is ERR_OK and B=2)
    3033   00:5099                      TCPIP_DNS_S:
    3034   00:5099                          ;--- Is there a result?
    3035   00:5099  CD 91 5A                call    GETDNSREADY             ; DNS done?
    3036   00:509C  B7                      or  a
    3037   00:509D  28 23                   jr  z,TCPIP_DNS_S_NORESULT      ; No DNS result
    3038   00:509F                          ;--- Ok, we have a result, is it success?
    3039   00:509F  3D                      dec a
    3040   00:50A0  28 12                   jr  z,TCPIP_DNS_S_HASRESULT     ; If it is 1, it was not an error
    3041   00:50A2                          ;--- Shoot, there is an error...
    3042   00:50A2                          ;--- And sure thing, ESP do not tell us details, it is always failure :-P
    3043   00:50A2  CB 40                   bit 0,b                         ;--- clear error after this?
    3044   00:50A4  28 09                   jr  z,TCP_IP_DNS_S_NOCLR
    3045   00:50A6                          ;--- Clear
    3046   00:50A6  06 00                   ld b,0                          ;--- Like I've said, no details
    3047   00:50A8  AF                      xor a
    3048   00:50A9  CD A3 5A                call    SETDNSREADY             ; DNS not done
    3049   00:50AC  3E 08                   ld  a,ERR_DNS;
    3050   00:50AE  C9                      ret
    3051   00:50AF                      TCP_IP_DNS_S_NOCLR:
    3052   00:50AF                          ;--- Don't clear
    3053   00:50AF  3E 08                   ld  a,ERR_DNS
    3054   00:50B1  06 00                   ld  b,0                         ;--- Like I've said, no details
    3055   00:50B3  C9                      ret
    3056   00:50B4                          ;--- There is a result available...
    3057   00:50B4                      TCPIP_DNS_S_HASRESULT:
    3058   00:50B4                          ;--- Copy the result
    3059   00:50B4  CD B7 5A                call    GETDNSRESULT
    3060   00:50B7  AF                      xor a
    3061   00:50B8  CB 40                   bit 0,b                         ;--- clear result after this?
    3062   00:50BA  28 03                   jr  z,TCP_IP_DNS_S_RES_NOCLR    ;--- no, just return
    3063   00:50BC                          ;--- Yes, clear
    3064   00:50BC  CD A3 5A                call    SETDNSREADY             ; DNS not done
    3065   00:50BF                      TCP_IP_DNS_S_RES_NOCLR:
    3066   00:50BF  06 02                   ld  b,2
    3067   00:50C1  C9                      ret
    3068   00:50C2                      
    3069   00:50C2                      TCPIP_DNS_S_NORESULT:
    3070   00:50C2  AF                      xor a                           ;--- OK no query in progress, no result, means nothing in progress
    3071   00:50C3  06 00                   ld  b,0                         ;--- No query in progress
    3072   00:50C5  C9                      ret
    3073   00:50C6                      
    3074   00:50C6                      ;========================
    3075   00:50C6                      ;===  TCPIP_UDP_OPEN  ===
    3076   00:50C6                      ;========================
    3077   00:50C6                      ;Open an UDP connection.
    3078   00:50C6                      ;
    3079   00:50C6                      ;Input:  A  = 8
    3080   00:50C6                      ;        HL = Local port number (#FFFF=random)
    3081   00:50C6                      ;        B  = Intended connection lifetime:
    3082   00:50C6                      ;             0: Transient
    3083   00:50C6                      ;             1: Resident
    3084   00:50C6                      ;Output: A = Error code
    3085   00:50C6                      ;        B = Connection number
    3086   00:50C6                      TCPIP_UDP_OPEN:
    3087   00:50C6                          SEND_DATA                       ; Send the command
    3087   00:50C6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3088   00:50C9  AF                      xor a
    3089   00:50CA                          SEND_DATA                       ; Send the command size msb
    3089   00:50CA  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3090   00:50CD  3E 03                   ld  a,3
    3091   00:50CF                          SEND_DATA                       ; Send the command size lsb
    3091   00:50CF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3092   00:50D2  7D                      ld  a,l
    3093   00:50D3                          SEND_DATA                       ; Send the port LSB
    3093   00:50D3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3094   00:50D6  7C                      ld  a,h
    3095   00:50D7                          SEND_DATA                       ; Send the port MSB
    3095   00:50D7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3096   00:50DA  78                      ld  a,b
    3097   00:50DB                          SEND_DATA                       ; Send the connection transient/resident
    3097   00:50DB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3098   00:50DE                      
    3099   00:50DE                          ; Now wait up to 180 ticks to get response
    3100   00:50DE  21 B4 00                ld  hl,180
    3101   00:50E1  CD AC 59                call    SETCOUNTER
    3102   00:50E4                      TCPIP_UDP_OPEN_ST1:
    3103   00:50E4                          CHECK_DATA
    3103   00:50E4  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3103   00:50E7  CB 47             >     bit 0,a
    3104   00:50E9  20 05                   jr  nz,TCPIP_UDP_OPEN_ST1.1
    3105   00:50EB  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3106   00:50EE  18 F4                   jr  TCPIP_UDP_OPEN_ST1
    3107   00:50F0                      TCPIP_UDP_OPEN_ST1.1:
    3108   00:50F0                          ; nz, check the data
    3109   00:50F0                          RECEIVE_DATA
    3109   00:50F0  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3110   00:50F3  FE 08                   cp  8                           ; Is response of our command?
    3111   00:50F5  20 ED                   jr  nz,TCPIP_UDP_OPEN_ST1
    3112   00:50F7                          ; now get return code, if return code other than 0, it is finished
    3113   00:50F7                      TCPIP_UDP_OPEN_RC:
    3114   00:50F7                          CHECK_DATA
    3114   00:50F7  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3114   00:50FA  CB 47             >     bit 0,a
    3115   00:50FC  20 05                   jr  nz,TCPIP_UDP_OPEN_RC.1
    3116   00:50FE  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3117   00:5101  18 F4                   jr  TCPIP_UDP_OPEN_RC
    3118   00:5103                      TCPIP_UDP_OPEN_RC.1:
    3119   00:5103                          ; nz, discard
    3120   00:5103                          RECEIVE_DATA
    3120   00:5103  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3121   00:5106  B7                      or  a                           ; 0?
    3122   00:5107  C0                      ret nz                          ; if not, done
    3123   00:5108                      
    3124   00:5108                          ; next two bytes are return code and size bytes, don't care, it is 1, conn #
    3125   00:5108  06 02                   ld  b,2
    3126   00:510A                      TCPIP_UDP_OPEN_ST2:
    3127   00:510A                          CHECK_DATA
    3127   00:510A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3127   00:510D  CB 47             >     bit 0,a
    3128   00:510F  20 05                   jr  nz,TCPIP_UDP_OPEN_ST2.1
    3129   00:5111  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3130   00:5114  18 F4                   jr  TCPIP_UDP_OPEN_ST2
    3131   00:5116                      TCPIP_UDP_OPEN_ST2.1:
    3132   00:5116                          ; nz, discard
    3133   00:5116                          RECEIVE_DATA
    3133   00:5116  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3134   00:5119  05                      dec b
    3135   00:511A  20 EE                   jr  nz,TCPIP_UDP_OPEN_ST2
    3136   00:511C                      
    3137   00:511C                          ; now just get the 1 byte, conn#, should go to B
    3138   00:511C                      TCPIP_UDP_OPEN_CONN_ST1:
    3139   00:511C                          CHECK_DATA
    3139   00:511C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3139   00:511F  CB 47             >     bit 0,a
    3140   00:5121  20 05                   jr  nz,TCPIP_UDP_OPEN_CONN_ST1.1
    3141   00:5123  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3142   00:5126  18 F4                   jr  TCPIP_UDP_OPEN_CONN_ST1
    3143   00:5128                      TCPIP_UDP_OPEN_CONN_ST1.1:
    3144   00:5128                          ; nz, get it
    3145   00:5128                          RECEIVE_DATA
    3145   00:5128  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3146   00:512B  47                      ld  b,a
    3147   00:512C                          ; done
    3148   00:512C  AF                      xor a
    3149   00:512D  C9                      ret
    3150   00:512E                      
    3151   00:512E                      ;=========================
    3152   00:512E                      ;===  TCPIP_UDP_CLOSE  ===
    3153   00:512E                      ;=========================
    3154   00:512E                      ;Close a UDP connection.
    3155   00:512E                      ;
    3156   00:512E                      ;Input:  A = 9
    3157   00:512E                      ;        B = Connection number
    3158   00:512E                      ;            0 to close all open transient UDP connections
    3159   00:512E                      ;Output: A = Error code
    3160   00:512E                      TCPIP_UDP_CLOSE:
    3161   00:512E                          SEND_DATA                       ; Send the command
    3161   00:512E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3162   00:5131  AF                      xor a
    3163   00:5132                          SEND_DATA                       ; Send the command size msb
    3163   00:5132  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3164   00:5135  3E 01                   ld  a,1
    3165   00:5137                          SEND_DATA                       ; Send the command size lsb
    3165   00:5137  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3166   00:513A  78                      ld  a,b
    3167   00:513B                          SEND_DATA                       ; Send the connection #
    3167   00:513B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3168   00:513E                          ; Now wait up to 180 ticks to get response
    3169   00:513E  21 B4 00                ld  hl,180
    3170   00:5141  CD AC 59                call    SETCOUNTER
    3171   00:5144                      TCPIP_UDP_CLOSE_ST1:
    3172   00:5144                          CHECK_DATA
    3172   00:5144  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3172   00:5147  CB 47             >     bit 0,a
    3173   00:5149  20 05                   jr  nz,TCPIP_UDP_CLOSE_ST1.1
    3174   00:514B  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3175   00:514E  18 F4                   jr  TCPIP_UDP_CLOSE_ST1
    3176   00:5150                      TCPIP_UDP_CLOSE_ST1.1:
    3177   00:5150                          ; nz, check the data
    3178   00:5150                          RECEIVE_DATA
    3178   00:5150  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3179   00:5153  FE 09                   cp  9                           ; Is response of our command?
    3180   00:5155  20 ED                   jr  nz,TCPIP_UDP_CLOSE_ST1
    3181   00:5157                          ; now get return code, if return code other than 0, it is finished
    3182   00:5157                      TCPIP_UDP_CLOSE_RC:
    3183   00:5157                          CHECK_DATA
    3183   00:5157  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3183   00:515A  CB 47             >     bit 0,a
    3184   00:515C  20 05                   jr  nz,TCPIP_UDP_CLOSE_RC.1
    3185   00:515E  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3186   00:5161  18 F4                   jr  TCPIP_UDP_CLOSE_RC
    3187   00:5163                      TCPIP_UDP_CLOSE_RC.1:
    3188   00:5163                          ; nz, discard
    3189   00:5163                          RECEIVE_DATA
    3189   00:5163  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3190   00:5166  B7                      or  a                           ; 0?
    3191   00:5167  C0                      ret nz                          ; if not, done
    3192   00:5168                      
    3193   00:5168                          ; next two bytes are return code and size bytes, don't care, it is 1, conn #
    3194   00:5168  06 02                   ld  b,2
    3195   00:516A                      TCPIP_UDP_CLOSE_ST2:
    3196   00:516A                          CHECK_DATA
    3196   00:516A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3196   00:516D  CB 47             >     bit 0,a
    3197   00:516F  20 05                   jr  nz,TCPIP_UDP_CLOSE_ST2.1
    3198   00:5171  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3199   00:5174  18 F4                   jr  TCPIP_UDP_CLOSE_ST2
    3200   00:5176                      TCPIP_UDP_CLOSE_ST2.1:
    3201   00:5176                          ; nz, discard
    3202   00:5176                          RECEIVE_DATA
    3202   00:5176  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3203   00:5179  05                      dec b
    3204   00:517A  20 EE                   jr  nz,TCPIP_UDP_CLOSE_ST2
    3205   00:517C                      
    3206   00:517C                          ; done, no return data other than return code
    3207   00:517C  AF                      xor a
    3208   00:517D  C9                      ret
    3209   00:517E                      
    3210   00:517E                      ;=========================
    3211   00:517E                      ;===  TCPIP_UDP_STATE  ===
    3212   00:517E                      ;=========================
    3213   00:517E                      ;Get the state of a UDP connection.
    3214   00:517E                      ;
    3215   00:517E                      ;Input:  A = 10
    3216   00:517E                      ;        B = Connection number
    3217   00:517E                      ;Output: A  = Error code
    3218   00:517E                      ;        HL = Local port number
    3219   00:517E                      ;        B  = Number of pending incoming datagrams
    3220   00:517E                      ;        DE = Size of oldest pending incoming datagram (data part only)
    3221   00:517E                      TCPIP_UDP_STATE:
    3222   00:517E                          SEND_DATA                       ; Send the command
    3222   00:517E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3223   00:5181  AF                      xor a
    3224   00:5182                          SEND_DATA                       ; Send the command size msb
    3224   00:5182  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3225   00:5185  3C                      inc a
    3226   00:5186                          SEND_DATA                       ; Send the command size lsb
    3226   00:5186  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3227   00:5189  78                      ld  a,b
    3228   00:518A                          SEND_DATA                       ; Send the parameter
    3228   00:518A  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3229   00:518D                      
    3230   00:518D                          ; Now wait up to 60 ticks to get response
    3231   00:518D  21 3C 00                ld  hl,60
    3232   00:5190  CD AC 59                call    SETCOUNTER
    3233   00:5193                      TCPIP_UDP_STATE_ST1:
    3234   00:5193                          CHECK_DATA
    3234   00:5193  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3234   00:5196  CB 47             >     bit 0,a
    3235   00:5198  20 05                   jr  nz,TCPIP_UDP_STATE_ST1.1
    3236   00:519A  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3237   00:519D  18 F4                   jr  TCPIP_UDP_STATE_ST1
    3238   00:519F                      TCPIP_UDP_STATE_ST1.1:
    3239   00:519F                          ; nz, check the data
    3240   00:519F                          RECEIVE_DATA
    3240   00:519F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3241   00:51A2  FE 0A                   cp  10                          ; Is response of our command?
    3242   00:51A4  20 ED                   jr  nz,TCPIP_UDP_STATE_ST1
    3243   00:51A6                          ; now get return code, if return code other than 0, it is finished
    3244   00:51A6                      TCPIP_UDP_STATE_RC:
    3245   00:51A6                          CHECK_DATA
    3245   00:51A6  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3245   00:51A9  CB 47             >     bit 0,a
    3246   00:51AB  20 05                   jr  nz,TCPIP_UDP_STATE_RC.1
    3247   00:51AD  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3248   00:51B0  18 F4                   jr  TCPIP_UDP_STATE_RC
    3249   00:51B2                      TCPIP_UDP_STATE_RC.1:
    3250   00:51B2                          ; nz, discard
    3251   00:51B2                          RECEIVE_DATA
    3251   00:51B2  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3252   00:51B5  B7                      or  a                           ; 0?
    3253   00:51B6  C0                      ret nz                          ; if not, done
    3254   00:51B7                      
    3255   00:51B7                          ; next two bytes are return code and size bytes, don't care, it is 5
    3256   00:51B7  06 02                   ld  b,2
    3257   00:51B9                      TCPIP_UDP_STATE_ST2:
    3258   00:51B9                          CHECK_DATA
    3258   00:51B9  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3258   00:51BC  CB 47             >     bit 0,a
    3259   00:51BE  20 05                   jr  nz,TCPIP_UDP_STATE_ST2.1
    3260   00:51C0  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3261   00:51C3  18 F4                   jr  TCPIP_UDP_STATE_ST2
    3262   00:51C5                      TCPIP_UDP_STATE_ST2.1:
    3263   00:51C5                          ; nz, discard
    3264   00:51C5                          RECEIVE_DATA
    3264   00:51C5  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3265   00:51C8  05                      dec b
    3266   00:51C9  20 EE                   jr  nz,TCPIP_UDP_STATE_ST2
    3267   00:51CB                      
    3268   00:51CB                          ; now just get the 5 bytes (Port LSB then MSB, # of packets, packet size LSB then MSB) and order it in L, H, B, E and D
    3269   00:51CB                      TCPIP_UDP_STATE_RESP_ST1:
    3270   00:51CB                          CHECK_DATA
    3270   00:51CB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3270   00:51CE  CB 47             >     bit 0,a
    3271   00:51D0  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST1.1
    3272   00:51D2  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3273   00:51D5  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST1
    3274   00:51D7                      TCPIP_UDP_STATE_RESP_ST1.1:
    3275   00:51D7                          ; nz, get it
    3276   00:51D7                          RECEIVE_DATA
    3276   00:51D7  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3277   00:51DA  6F                      ld  l,a
    3278   00:51DB                      TCPIP_UDP_STATE_RESP_ST2:
    3279   00:51DB                          CHECK_DATA
    3279   00:51DB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3279   00:51DE  CB 47             >     bit 0,a
    3280   00:51E0  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST2.1
    3281   00:51E2  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3282   00:51E5  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST2
    3283   00:51E7                      TCPIP_UDP_STATE_RESP_ST2.1:
    3284   00:51E7                          ; nz, get it
    3285   00:51E7                          RECEIVE_DATA
    3285   00:51E7  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3286   00:51EA  67                      ld  h,a
    3287   00:51EB                      TCPIP_UDP_STATE_RESP_ST3:
    3288   00:51EB                          CHECK_DATA
    3288   00:51EB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3288   00:51EE  CB 47             >     bit 0,a
    3289   00:51F0  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST3.1
    3290   00:51F2  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3291   00:51F5  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST3
    3292   00:51F7                      TCPIP_UDP_STATE_RESP_ST3.1:
    3293   00:51F7                          ; nz, get it
    3294   00:51F7                          RECEIVE_DATA
    3294   00:51F7  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3295   00:51FA  47                      ld  b,a
    3296   00:51FB                      TCPIP_UDP_STATE_RESP_ST4:
    3297   00:51FB                          CHECK_DATA
    3297   00:51FB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3297   00:51FE  CB 47             >     bit 0,a
    3298   00:5200  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST4.1
    3299   00:5202  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3300   00:5205  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST4
    3301   00:5207                      TCPIP_UDP_STATE_RESP_ST4.1:
    3302   00:5207                          ; nz, get it
    3303   00:5207                          RECEIVE_DATA
    3303   00:5207  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3304   00:520A  5F                      ld  e,a
    3305   00:520B                      TCPIP_UDP_STATE_RESP_ST5:
    3306   00:520B                          CHECK_DATA
    3306   00:520B  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3306   00:520E  CB 47             >     bit 0,a
    3307   00:5210  20 05                   jr  nz,TCPIP_UDP_STATE_RESP_ST5.1
    3308   00:5212  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3309   00:5215  18 F4                   jr  TCPIP_UDP_STATE_RESP_ST5
    3310   00:5217                      TCPIP_UDP_STATE_RESP_ST5.1:
    3311   00:5217                          ; nz, get it
    3312   00:5217                          RECEIVE_DATA
    3312   00:5217  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3313   00:521A  57                      ld  d,a
    3314   00:521B                          ; done
    3315   00:521B  AF                      xor a
    3316   00:521C  C9                      ret
    3317   00:521D                      
    3318   00:521D                      ;========================
    3319   00:521D                      ;===  TCPIP_UDP_SEND  ===
    3320   00:521D                      ;========================
    3321   00:521D                      ;Send an UDP datagram.
    3322   00:521D                      ;
    3323   00:521D                      ;Input:  A = 11
    3324   00:521D                      ;        B = Connection number
    3325   00:521D                      ;        HL = Address of datagram data
    3326   00:521D                      ;        DE = Address of parameters block
    3327   00:521D                      ;Output: A = Error code
    3328   00:521D                      ;
    3329   00:521D                      ;Parameters block:
    3330   00:521D                      ;
    3331   00:521D                      ;    +0 (4): Destination IP address
    3332   00:521D                      ;    +4 (2): Destination port
    3333   00:521D                      ;    +6 (2): Data length
    3334   00:521D                      TCPIP_UDP_SEND:
    3335   00:521D  E5                      push    hl
    3336   00:521E  D5                      push    de
    3337   00:521F                          SEND_DATA                       ; Send the command
    3337   00:521F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3338   00:5222                          ; prepare new data size, adding our 7 bytes overhead
    3339   00:5222  DD 62                   ld  ixh,d
    3340   00:5224  DD 6B                   ld  ixl,e
    3341   00:5226  11 07 00                ld  de,7
    3342   00:5229  DD 6E 06                ld  l,(ix+6)
    3343   00:522C  DD 66 07                ld  h,(ix+7)
    3344   00:522F  19                      add hl,de
    3345   00:5230  7C                      ld  a,h
    3346   00:5231                          SEND_DATA                       ; Send the command size msb
    3346   00:5231  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3347   00:5234  7D                      ld  a,l
    3348   00:5235                          SEND_DATA                       ; Send the command size lsb
    3348   00:5235  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3349   00:5238  78                      ld  a,b
    3350   00:5239                          SEND_DATA                       ; Send the connection #
    3350   00:5239  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3351   00:523C  D1                      pop de
    3352   00:523D  E1                      pop hl
    3353   00:523E  1A                      ld  a,(de)
    3354   00:523F                          SEND_DATA                       ; Send IP byte 1
    3354   00:523F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3355   00:5242  13                      inc de
    3356   00:5243  1A                      ld  a,(de)
    3357   00:5244                          SEND_DATA                       ; Send IP byte 2
    3357   00:5244  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3358   00:5247  13                      inc de
    3359   00:5248  1A                      ld  a,(de)
    3360   00:5249                          SEND_DATA                       ; Send IP byte 3
    3360   00:5249  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3361   00:524C  13                      inc de
    3362   00:524D  1A                      ld  a,(de)
    3363   00:524E                          SEND_DATA                       ; Send IP byte 4
    3363   00:524E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3364   00:5251  13                      inc de
    3365   00:5252  1A                      ld  a,(de)
    3366   00:5253                          SEND_DATA                       ; Send Port LSB
    3366   00:5253  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3367   00:5256  13                      inc de
    3368   00:5257  1A                      ld  a,(de)
    3369   00:5258                          SEND_DATA                       ; Send Port MSB
    3369   00:5258  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3370   00:525B                          ; now oti the data starting at hl, size is in next DE position
    3371   00:525B  13                      inc de
    3372   00:525C  1A                      ld  a,(de)
    3373   00:525D  47                      ld  b,a                         ; save lsb in b
    3374   00:525E  13                      inc de
    3375   00:525F  1A                      ld  a,(de)                      ; msb
    3376   00:5260  57                      ld  d,a                         ; put in D, there is no ld d,(de)
    3377   00:5261  58                      ld  e,b                         ; lsb
    3378   00:5262                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    3379   00:5262                          ;ld b,e                         ; Number of loops originaly in DE, not needed, b already has e
    3380   00:5262  1B                      dec de
    3381   00:5263  14                      inc d
    3382   00:5264                          if USE_MEM_IO = 0
    3383   00:5264                    ~     ld  c,OUT_TX_PORT
    3384   00:5264                    ~ TCPIP_UDP_SEND_R:
    3385   00:5264                    ~     otir                            ; Send until B is 0
    3386   00:5264                    ~     else
    3387   00:5264                      TCPIP_UDP_SEND_R:
    3388   00:5264  7E                      ld  a,(hl)
    3389   00:5265  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3390   00:5268  23                      inc hl
    3391   00:5269  10 F9                   djnz TCPIP_UDP_SEND_R
    3392   00:526B                          endif
    3393   00:526B  15                      dec d                           ; decrement secondary counter
    3394   00:526C  20 F6                   jr  nz,TCPIP_UDP_SEND_R         ; If still have another round, do it
    3395   00:526E                          ; Now wait up to 600 ticks to get response
    3396   00:526E  21 58 02                ld  hl,600
    3397   00:5271  CD AC 59                call    SETCOUNTER
    3398   00:5274                      TCPIP_UDP_SEND_ST1:
    3399   00:5274                          CHECK_DATA
    3399   00:5274  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3399   00:5277  CB 47             >     bit 0,a
    3400   00:5279  20 05                   jr  nz,TCPIP_UDP_SEND_ST1.1
    3401   00:527B  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3402   00:527E  18 F4                   jr  TCPIP_UDP_SEND_ST1
    3403   00:5280                      TCPIP_UDP_SEND_ST1.1:
    3404   00:5280                          ; nz, check the data
    3405   00:5280                          RECEIVE_DATA
    3405   00:5280  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3406   00:5283  FE 0B                   cp  11                          ; Is response of our command?
    3407   00:5285  20 ED                   jr  nz,TCPIP_UDP_SEND_ST1
    3408   00:5287                          ; now get return code, if return code other than 0, it is finished
    3409   00:5287                      TCPIP_UDP_SEND_RC:
    3410   00:5287                          CHECK_DATA
    3410   00:5287  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3410   00:528A  CB 47             >     bit 0,a
    3411   00:528C  20 05                   jr  nz,TCPIP_UDP_SEND_RC.1
    3412   00:528E  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3413   00:5291  18 F4                   jr  TCPIP_UDP_SEND_RC
    3414   00:5293                      TCPIP_UDP_SEND_RC.1:
    3415   00:5293                          ; nz, discard
    3416   00:5293                          RECEIVE_DATA
    3416   00:5293  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3417   00:5296  B7                      or  a                           ; 0?
    3418   00:5297  C0                      ret nz                          ; if not, done
    3419   00:5298                      
    3420   00:5298                          ; next two bytes are return code and size bytes, don't care, it is 0
    3421   00:5298  06 02                   ld  b,2
    3422   00:529A                      TCPIP_UDP_SEND_ST2:
    3423   00:529A                          CHECK_DATA
    3423   00:529A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3423   00:529D  CB 47             >     bit 0,a
    3424   00:529F  20 05                   jr  nz,TCPIP_UDP_SEND_ST2.1
    3425   00:52A1  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3426   00:52A4  18 F4                   jr  TCPIP_UDP_SEND_ST2
    3427   00:52A6                      TCPIP_UDP_SEND_ST2.1:
    3428   00:52A6                          ; nz, discard
    3429   00:52A6                          RECEIVE_DATA
    3429   00:52A6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3430   00:52A9  05                      dec b
    3431   00:52AA  20 EE                   jr  nz,TCPIP_UDP_SEND_ST2
    3432   00:52AC                      
    3433   00:52AC                          ; done, no return data other than return code
    3434   00:52AC  AF                      xor a
    3435   00:52AD  C9                      ret
    3436   00:52AE                      
    3437   00:52AE                      ;=======================
    3438   00:52AE                      ;===  TCPIP_UDP_RCV  ===
    3439   00:52AE                      ;=======================
    3440   00:52AE                      ;Retrieve an incoming UDP datagram.
    3441   00:52AE                      ;
    3442   00:52AE                      ;Input:  A = 12
    3443   00:52AE                      ;        B = Connection number
    3444   00:52AE                      ;        HL = Address for datagram data
    3445   00:52AE                      ;        DE = Maximum data size to retrieve
    3446   00:52AE                      ;Output: A = Error code
    3447   00:52AE                      ;        L.H.E.D = Source IP address
    3448   00:52AE                      ;        IX = Source port
    3449   00:52AE                      ;        BC = Actual received data size
    3450   00:52AE                      
    3451   00:52AE                      ; Customized TIME OUT routine: If time out receiving data, retry as received data
    3452   00:52AE                      ; won't be re-sent as host is unaware of this
    3453   00:52AE                      TCPIP_UDP_RCV_CHECK_TIME_OUT:
    3454   00:52AE                          ; Save registers other than AF
    3455   00:52AE  C5                      push bc
    3456   00:52AF  D5                      push de
    3457   00:52B0  E5                      push hl
    3458   00:52B1  CD 9D 59                call    GETCOUNTER
    3459   00:52B4  7D                      ld  a,l
    3460   00:52B5  B4                      or  h
    3461   00:52B6                          ; Restore registers, we are returning
    3462   00:52B6  E1                      pop hl
    3463   00:52B7  D1                      pop de
    3464   00:52B8  C1                      pop bc
    3465   00:52B9  C0                      ret nz
    3466   00:52BA                          ; Ok, timeout...
    3467   00:52BA  F1                      pop af                          ; Get return address of who called this out of the stack, we will return from the function or re-start
    3468   00:52BB                      TCPIP_TCP_UDP_RETRY_QRCV:
    3469   00:52BB  CD BC 59                call    GETBYTE
    3470   00:52BE  B7                      or  a
    3471   00:52BF  28 0C                   jr  z,TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY
    3472   00:52C1                          ; Ok, so let's ask ESP to re-send the data and retry receiving it
    3473   00:52C1  3D                      dec a
    3474   00:52C2  CD CE 59                call    SETBYTE                 ; we are retrying it
    3475   00:52C5  3E 72                   ld  a,'r'                       ; retry transmission command
    3476   00:52C7                          SEND_DATA
    3476   00:52C7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3477   00:52CA  C3 F2 52                jp  TCPIP_UDP_RCV.RXRETRY       ; and retry it
    3478   00:52CD                      TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY:
    3479   00:52CD  3E 0F                   ld  a,ERR_INV_OPER
    3480   00:52CF  C9                      ret                             ; and return the function itself
    3481   00:52D0                      
    3482   00:52D0                      TCPIP_UDP_RCV:
    3483   00:52D0  CD F5 59                call    SETWORD                 ; Save for later the datagram address
    3484   00:52D3  3E 0C                   ld  a,12
    3485   00:52D5                          SEND_DATA                       ; Send the command
    3485   00:52D5  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3486   00:52D8  AF                      xor a
    3487   00:52D9                          SEND_DATA                       ; Send the command size msb
    3487   00:52D9  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3488   00:52DC  3E 03                   ld  a,3
    3489   00:52DE                          SEND_DATA                       ; Send the command size lsb
    3489   00:52DE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3490   00:52E1  78                      ld  a,b
    3491   00:52E2                          SEND_DATA                       ; Send the connection #
    3491   00:52E2  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3492   00:52E5  7B                      ld  a,e
    3493   00:52E6                          SEND_DATA                       ; Send MAX rcv size LSB
    3493   00:52E6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3494   00:52E9  7A                      ld  a,d
    3495   00:52EA                          SEND_DATA                       ; Send MAX rcv size MSB
    3495   00:52EA  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3496   00:52ED  3E 03                   ld  a,3
    3497   00:52EF  CD CE 59                call    SETBYTE                 ; Ok, retry up to three times
    3498   00:52F2                      TCPIP_UDP_RCV.RXRETRY:
    3499   00:52F2                          ; Now wait up to 600 ticks to get response
    3500   00:52F2  21 58 02                ld  hl,600
    3501   00:52F5  CD AC 59                call    SETCOUNTER
    3502   00:52F8                      TCPIP_UDP_RCV_ST1:
    3503   00:52F8                          CHECK_DATA
    3503   00:52F8  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3503   00:52FB  CB 47             >     bit 0,a
    3504   00:52FD  20 05                   jr  nz,TCPIP_UDP_RCV_ST1.1
    3505   00:52FF  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3506   00:5302  18 F4                   jr  TCPIP_UDP_RCV_ST1
    3507   00:5304                      TCPIP_UDP_RCV_ST1.1:
    3508   00:5304                          ; nz, check the data
    3509   00:5304                          RECEIVE_DATA
    3509   00:5304  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3510   00:5307  FE 0C                   cp  12                          ; Is response of our command?
    3511   00:5309  20 ED                   jr  nz,TCPIP_UDP_RCV_ST1
    3512   00:530B                          ; At this point, all data is being buffered, so 30 ticks, half second, is more than enough time-out
    3513   00:530B  F3                      di
    3514   00:530C  21 1E 00                ld  hl,30
    3515   00:530F  CD AC 59                call    SETCOUNTER
    3516   00:5312  FB                      ei
    3517   00:5313                          ; now get return code, if return code other than 0, it is finished
    3518   00:5313                      TCPIP_UDP_RCV_RC:
    3519   00:5313                          CHECK_DATA
    3519   00:5313  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3519   00:5316  CB 47             >     bit 0,a
    3520   00:5318  20 05                   jr  nz,TCPIP_UDP_RCV_RC.1
    3521   00:531A  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3522   00:531D  18 F4                   jr  TCPIP_UDP_RCV_RC
    3523   00:531F                      TCPIP_UDP_RCV_RC.1:
    3524   00:531F                          ; nz, discard
    3525   00:531F                          RECEIVE_DATA
    3525   00:531F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3526   00:5322  B7                      or  a                           ; 0?
    3527   00:5323  C0                      ret nz                          ; if not, done
    3528   00:5324                          ; next two bytes are return code and size bytes, save it to BC
    3529   00:5324                      TCPIP_UDP_RCV_ST2A:
    3530   00:5324                          CHECK_DATA
    3530   00:5324  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3530   00:5327  CB 47             >     bit 0,a
    3531   00:5329  20 05                   jr  nz,TCPIP_UDP_RCV_ST2A.1
    3532   00:532B  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3533   00:532E  18 F4                   jr  TCPIP_UDP_RCV_ST2A
    3534   00:5330                      TCPIP_UDP_RCV_ST2A.1:
    3535   00:5330                          ; nz, discard
    3536   00:5330                          RECEIVE_DATA
    3536   00:5330  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3537   00:5333  67                      ld  h,a
    3538   00:5334                      TCPIP_UDP_RCV_ST2B:
    3539   00:5334                          CHECK_DATA
    3539   00:5334  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3539   00:5337  CB 47             >     bit 0,a
    3540   00:5339  20 05                   jr  nz,TCPIP_UDP_RCV_ST2B.1
    3541   00:533B  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3542   00:533E  18 F4                   jr  TCPIP_UDP_RCV_ST2B
    3543   00:5340                      TCPIP_UDP_RCV_ST2B.1:
    3544   00:5340                          ; nz, discard
    3545   00:5340                          RECEIVE_DATA
    3545   00:5340  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3546   00:5343  6F                      ld  l,a
    3547   00:5344  01 06 00                ld  bc,6
    3548   00:5347                          ; subtract 6 (IP and PORT)
    3549   00:5347  AF                      xor a                           ; zero carry
    3550   00:5348  ED 42                   sbc hl,bc
    3551   00:534A  4D                      ld  c,l
    3552   00:534B  44                      ld  b,h                         ; BC has effective received data size
    3553   00:534C                          ; now just get the 4 bytes IP and place it in L H E D
    3554   00:534C                      TCPIP_UDP_RCV_IP_ST1:
    3555   00:534C                          CHECK_DATA
    3555   00:534C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3555   00:534F  CB 47             >     bit 0,a
    3556   00:5351  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST1.1
    3557   00:5353  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3558   00:5356  18 F4                   jr  TCPIP_UDP_RCV_IP_ST1
    3559   00:5358                      TCPIP_UDP_RCV_IP_ST1.1:
    3560   00:5358                          ; nz, get it
    3561   00:5358                          RECEIVE_DATA
    3561   00:5358  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3562   00:535B  6F                      ld  l,a
    3563   00:535C                      TCPIP_UDP_RCV_IP_ST2:
    3564   00:535C                          CHECK_DATA
    3564   00:535C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3564   00:535F  CB 47             >     bit 0,a
    3565   00:5361  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST2.1
    3566   00:5363  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3567   00:5366  18 F4                   jr  TCPIP_UDP_RCV_IP_ST2
    3568   00:5368                      TCPIP_UDP_RCV_IP_ST2.1:
    3569   00:5368                          ; nz, get it
    3570   00:5368                          RECEIVE_DATA
    3570   00:5368  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3571   00:536B  67                      ld  h,a
    3572   00:536C                      TCPIP_UDP_RCV_IP_ST3:
    3573   00:536C                          CHECK_DATA
    3573   00:536C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3573   00:536F  CB 47             >     bit 0,a
    3574   00:5371  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST3.1
    3575   00:5373  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3576   00:5376  18 F4                   jr  TCPIP_UDP_RCV_IP_ST3
    3577   00:5378                      TCPIP_UDP_RCV_IP_ST3.1:
    3578   00:5378                          ; nz, get it
    3579   00:5378                          RECEIVE_DATA
    3579   00:5378  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3580   00:537B  5F                      ld  e,a
    3581   00:537C                      TCPIP_UDP_RCV_IP_ST4:
    3582   00:537C                          CHECK_DATA
    3582   00:537C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3582   00:537F  CB 47             >     bit 0,a
    3583   00:5381  20 05                   jr  nz,TCPIP_UDP_RCV_IP_ST4.1
    3584   00:5383  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3585   00:5386  18 F4                   jr  TCPIP_UDP_RCV_IP_ST4
    3586   00:5388                      TCPIP_UDP_RCV_IP_ST4.1:
    3587   00:5388                          ; nz, get it
    3588   00:5388                          RECEIVE_DATA
    3588   00:5388  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3589   00:538B  57                      ld  d,a
    3590   00:538C                          ; now get the 2 bytes port and place in IXL and IXH
    3591   00:538C                      TCPIP_UDP_RCV_PORT_ST1:
    3592   00:538C                          CHECK_DATA
    3592   00:538C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3592   00:538F  CB 47             >     bit 0,a
    3593   00:5391  20 05                   jr  nz,TCPIP_UDP_RCV_PORT_ST1.1
    3594   00:5393  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3595   00:5396  18 F4                   jr  TCPIP_UDP_RCV_PORT_ST1
    3596   00:5398                      TCPIP_UDP_RCV_PORT_ST1.1:
    3597   00:5398                          ; nz, get it
    3598   00:5398                          RECEIVE_DATA
    3598   00:5398  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3599   00:539B  DD 6F                   ld  ixl,a
    3600   00:539D                      TCPIP_UDP_RCV_PORT_ST2:
    3601   00:539D                          CHECK_DATA
    3601   00:539D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3601   00:53A0  CB 47             >     bit 0,a
    3602   00:53A2  20 05                   jr  nz,TCPIP_UDP_RCV_PORT_ST2.1
    3603   00:53A4  CD AE 52                call    TCPIP_UDP_RCV_CHECK_TIME_OUT
    3604   00:53A7  18 F4                   jr  TCPIP_UDP_RCV_PORT_ST2
    3605   00:53A9                      TCPIP_UDP_RCV_PORT_ST2.1:
    3606   00:53A9                          ; nz, get it
    3607   00:53A9                          RECEIVE_DATA
    3607   00:53A9  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3608   00:53AC  DD 67                   ld  ixh,a
    3609   00:53AE                      
    3610   00:53AE                          ; save the received data in memory
    3611   00:53AE  CD 21 5A                call    REGBACKUP               ; Save the data received so far, registers will change
    3612   00:53B1                          ; will start moving at RCV_ADDRESS that was stored in our WORD
    3613   00:53B1  CD E2 59                call    GETWORD
    3614   00:53B4                          ; size goes to DE
    3615   00:53B4  50                      ld  d,b
    3616   00:53B5  59                      ld  e,c
    3617   00:53B6                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use ini :-D
    3618   00:53B6  43                      ld  b,e                         ; Number of loops originaly in DE
    3619   00:53B7  1B                      dec de
    3620   00:53B8  14                      inc d
    3621   00:53B9                          if USE_MEM_IO = 0
    3622   00:53B9                    ~     ld  c,IN_DATA_PORT
    3623   00:53B9                    ~     endif
    3624   00:53B9                      TCPIP_UDP_RCV_R:
    3625   00:53B9                          if USE_MEM_IO = 0
    3626   00:53B9                    ~     inir
    3627   00:53B9                    ~     else
    3628   00:53B9  3A 06 7F                ld  a,(MEM_IN_DATA_PORT)
    3629   00:53BC  77                      ld  (hl),a
    3630   00:53BD  23                      inc hl
    3631   00:53BE  10 F9                   djnz TCPIP_UDP_RCV_R
    3632   00:53C0                          endif
    3633   00:53C0  15                      dec d
    3634   00:53C1  20 F6                   jr  nz,TCPIP_UDP_RCV_R
    3635   00:53C3                          CHECK_BUFFER_UNDERRUN
    3635   00:53C3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3635   00:53C6  CB 67             >     bit 4,a
    3636   00:53C8  C2 BB 52                jp  nz,TCPIP_TCP_UDP_RETRY_QRCV ; If yes, retry
    3637   00:53CB                          ; Otherwise, done
    3638   00:53CB                          ; done, restore return data in DE BC and HL
    3639   00:53CB  CD 0A 5A                call    REGRESTORE
    3640   00:53CE  AF                      xor a
    3641   00:53CF  C9                      ret
    3642   00:53D0                      
    3643   00:53D0                      ;========================
    3644   00:53D0                      ;===  TCPIP_TCP_OPEN  ===
    3645   00:53D0                      ;========================
    3646   00:53D0                      ;Open a TCP connection.
    3647   00:53D0                      ;
    3648   00:53D0                      ;Input:  A  = 13
    3649   00:53D0                      ;        HL = Address of parameters block
    3650   00:53D0                      ;Output: A = Error code
    3651   00:53D0                      ;        B = Connection number
    3652   00:53D0                      ;        C = Connection not open reason (mostly for TLS)
    3653   00:53D0                      ;
    3654   00:53D0                      ;Parameters block format:
    3655   00:53D0                      ;
    3656   00:53D0                      ;+0 (4): Remote IP address (0.0.0.0 for unspecified remote socket)
    3657   00:53D0                      ;+4 (2): Remote port (ignored if unspecified remote socket)
    3658   00:53D0                      ;+6 (2): Local port, 0FFFFh for a random value
    3659   00:53D0                      ;+8 (2): Suggestion for user timeout value
    3660   00:53D0                      ;+10 (1): Flags:
    3661   00:53D0                      ;         bit 0: Set for passive connection
    3662   00:53D0                      ;         bit 1: Set for resident connection
    3663   00:53D0                      ;         bit 2: Set for TLS connection
    3664   00:53D0                      ;         bit 3: Set for TLS connection validating host certificate
    3665   00:53D0                      ;+11 (2): If 0000 no host name validation, otherwise the hostname string address (zero terminated)
    3666   00:53D0                      ;TCP_OPEN_IP1               (ix+0)
    3667   00:53D0                      ;TCP_OPEN_IP2               (ix+1)
    3668   00:53D0                      ;TCP_OPEN_IP3               (ix+2)
    3669   00:53D0                      ;TCP_OPEN_IP4               (ix+3)
    3670   00:53D0                      ;TCP_OPEN_RP                (ix+4)
    3671   00:53D0                      ;TCP_OPEN_LP                (ix+6)
    3672   00:53D0                      ;TCP_OPEN_TO                (ix+8)
    3673   00:53D0                      ;TCP_OPEN_CMD_FLAGS         (ix+10)
    3674   00:53D0                      ;TCP_OPEN_CMD_HOST_LSB      (ix+11)
    3675   00:53D0                      ;TCP_OPEN_CMD_HOST_MSB      (ix+12)
    3676   00:53D0                      
    3677   00:53D0                      ; When no connection, let's get the reason and put in register C, as agreed
    3678   00:53D0                      ; with Nestor this will be the way to go in the next UNAPI revision
    3679   00:53D0                      TCPIP_TCP_OPEN_ERROR:
    3680   00:53D0                          ; next two bytes are return code and size bytes, don't care, it is 1, conn close reason
    3681   00:53D0  47                      ld  b,a                         ; save error in b
    3682   00:53D1  0E 02                   ld  c,2
    3683   00:53D3                      TCPIP_TCP_OPEN_ERROR2:
    3684   00:53D3                          CHECK_DATA
    3684   00:53D3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3684   00:53D6  CB 47             >     bit 0,a
    3685   00:53D8  20 05                   jr  nz,TCPIP_TCP_OPEN_ERROR2.1
    3686   00:53DA  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3687   00:53DD  18 F4                   jr  TCPIP_TCP_OPEN_ERROR2
    3688   00:53DF                      TCPIP_TCP_OPEN_ERROR2.1:
    3689   00:53DF                          ; nz, discard
    3690   00:53DF                          RECEIVE_DATA
    3690   00:53DF  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3691   00:53E2  0D                      dec c
    3692   00:53E3  20 EE                   jr  nz,TCPIP_TCP_OPEN_ERROR2
    3693   00:53E5  78                      ld  a,b
    3694   00:53E6  FE 0B                   cp  ERR_NO_CONN
    3695   00:53E8  20 10                   jr  nz,TCPIP_TCP_OPEN_ERROR4    ; other errors do not have extra bytes as result
    3696   00:53EA                      ; now just get the 1 byte, close reason, should go to C
    3697   00:53EA                      TCPIP_TCP_OPEN_ERROR3:
    3698   00:53EA                          CHECK_DATA
    3698   00:53EA  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3698   00:53ED  CB 47             >     bit 0,a
    3699   00:53EF  20 05                   jr  nz,TCPIP_TCP_OPEN_ERROR3.1
    3700   00:53F1  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3701   00:53F4  18 F4                   jr  TCPIP_TCP_OPEN_ERROR3
    3702   00:53F6                      TCPIP_TCP_OPEN_ERROR3.1:
    3703   00:53F6                          ; nz, get it
    3704   00:53F6                          RECEIVE_DATA
    3704   00:53F6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3705   00:53F9  4F                      ld  c,a
    3706   00:53FA                      TCPIP_TCP_OPEN_ERROR4:
    3707   00:53FA                          ; now return w/ error that is saved in b
    3708   00:53FA  78                      ld  a,b
    3709   00:53FB  06 00                   ld  b,0                         ; no connection, so 0
    3710   00:53FD  C9                      ret
    3711   00:53FE                      
    3712   00:53FE                      TCPIP_TCP_OPEN:
    3713   00:53FE  E5                      push    hl                      ; save param block address
    3714   00:53FF  7C                      ld  a,h
    3715   00:5400  DD 67                   ld  ixh,a
    3716   00:5402  7D                      ld  a,l
    3717   00:5403  DD 6F                   ld  ixl,a
    3718   00:5405                          ; IX now has the parameters area
    3719   00:5405                          ; most times it will be non tls, so this is the first test case
    3720   00:5405  21 0B 00                ld  hl,11
    3721   00:5408  CD F5 59                call    SETWORD                 ; If it is non-TLS, send 11 bytes
    3722   00:540B  DD 7E 0A                ld  a,(ix+10)                   ; TCP_OPEN_CMD_FLAGS
    3723   00:540E  CB 57                   bit 2,a
    3724   00:5410  28 4F                   jr  z,TCPIP_TCP_OPEN_NO_TLS
    3725   00:5412                      
    3726   00:5412                          ; TLS, but, do we have host name?
    3727   00:5412  21 0C 00                ld  hl,12
    3728   00:5415  CD F5 59                call    SETWORD                 ; If it is TLS without host name, send 12 bytes, one zero as host name suffice
    3729   00:5418  DD 6E 0B                ld  l,(ix+11)                   ; TCP_OPEN_CMD_HOST_LSB
    3730   00:541B  DD 7E 0C                ld  a,(ix+12)                   ; TCP_OPEN_CMD_HOST_MSB
    3731   00:541E  B5                      or  l
    3732   00:541F                          ; if TLS and next two bytes are 00 no host to check
    3733   00:541F  28 40                   jr  z,TCPIP_TCP_OPEN_NO_CHECKHOST
    3734   00:5421                          ; we are here, host to check
    3735   00:5421  DD 66 0C                ld  h,(ix+12)                   ; TCP_OPEN_CMD_HOST_MSB
    3736   00:5424  D1                      pop de                          ; Retrieve parameters address
    3737   00:5425  E5                      push    hl                      ; Save host name address
    3738   00:5426  D5                      push    de                      ; Save Parameters address (so it is in the order we are going to need)
    3739   00:5427                          ; let's check how many bytes there are
    3740   00:5427  11 0B 00                ld  de,11                       ; Start with 11, all params except host name
    3741   00:542A                      TCPIP_TCP_OPEN_CHECK_HOSTOF:
    3742   00:542A  7E                      ld  a,(hl)
    3743   00:542B  13                      inc de                          ; Not zero, so increase size count
    3744   00:542C  23                      inc hl                          ; And next hostname byte
    3745   00:542D  B7                      or  a                           ; If zero, hostname terminated
    3746   00:542E                          ; Loop until terminator (0) is found
    3747   00:542E  C2 2A 54                jp  nz,TCPIP_TCP_OPEN_CHECK_HOSTOF
    3748   00:5431                      
    3749   00:5431                      TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME:
    3750   00:5431                          ; Ok, so, DE has the full hostname size, let's start sending from here
    3751   00:5431  3E 0D                   ld  a,13                        ; Function TCP OPEN
    3752   00:5433                          SEND_DATA                       ; Send the command
    3752   00:5433  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3753   00:5436  7A                      ld  a,d
    3754   00:5437                          SEND_DATA                       ; Send the command size msb
    3754   00:5437  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3755   00:543A  7B                      ld  a,e
    3756   00:543B                          SEND_DATA                       ; Send the command size lsb
    3756   00:543B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3757   00:543E  E1                      pop hl                          ; Restore the memory address for the parameters
    3758   00:543F                          ; First send the 11 bytes parameters
    3759   00:543F                          if USE_MEM_IO = 0
    3760   00:543F                    ~     ld  c,OUT_TX_PORT
    3761   00:543F                    ~     outi
    3762   00:543F                    ~     outi
    3763   00:543F                    ~     outi
    3764   00:543F                    ~     outi
    3765   00:543F                    ~     outi
    3766   00:543F                    ~     outi
    3767   00:543F                    ~     outi
    3768   00:543F                    ~     outi
    3769   00:543F                    ~     outi
    3770   00:543F                    ~     outi
    3771   00:543F                    ~     outi                            ; Unrolled outi is a bit faster :)
    3772   00:543F                    ~     else
    3773   00:543F  06 0B                   ld  b,11                        ; Send 11 bytes
    3774   00:5441                      TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME_LOOP_PARAM:
    3775   00:5441  7E                      ld  a,(hl)
    3776   00:5442  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3777   00:5445  23                      inc hl
    3778   00:5446  10 F9                   djnz TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME_LOOP_PARAM
    3779   00:5448                          endif
    3780   00:5448  EB                      ex  de,hl                       ; Size in HL
    3781   00:5449  11 0B 00                ld  de,11
    3782   00:544C  B7                      or  a                           ; zero flag
    3783   00:544D  ED 52                   sbc hl,de
    3784   00:544F  EB                      ex de,hl                        ; and adjusted size back in de
    3785   00:5450  E1                      pop hl                          ; Restore the memory address for hostname
    3786   00:5451                      ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    3787   00:5451  43                      ld  b,e                         ; Number of loops originaly in DE
    3788   00:5452  1B                      dec de
    3789   00:5453  14                      inc d
    3790   00:5454                          if USE_MEM_IO = 0
    3791   00:5454                    ~     ld  c,OUT_TX_PORT
    3792   00:5454                    ~ TCPIP_TCP_OPEN_SENDHOSTNAME:
    3793   00:5454                    ~     outi
    3794   00:5454                    ~     jr  nz,TCPIP_TCP_OPEN_SENDHOSTNAME
    3795   00:5454                    ~     else
    3796   00:5454                      TCPIP_TCP_OPEN_SENDHOSTNAME:
    3797   00:5454  7E                      ld  a,(hl)
    3798   00:5455  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3799   00:5458  23                      inc hl
    3800   00:5459  10 F9                   djnz TCPIP_TCP_OPEN_SENDHOSTNAME
    3801   00:545B                          endif
    3802   00:545B  15                      dec d
    3803   00:545C  20 F6                   jr  nz,TCPIP_TCP_OPEN_SENDHOSTNAME
    3804   00:545E  C3 81 54                jp  TCPIP_TCP_OPEN_WAIT_RESPONSE
    3805   00:5461                      
    3806   00:5461                      TCPIP_TCP_OPEN_NO_TLS:
    3807   00:5461                      TCPIP_TCP_OPEN_NO_CHECKHOST:
    3808   00:5461  3E 0D                   ld  a,13                        ; Function TCP OPEN
    3809   00:5463                          SEND_DATA                       ; Send the command
    3809   00:5463  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3810   00:5466  CD E2 59                call    GETWORD
    3811   00:5469  7C                      ld  a,h
    3812   00:546A  57                      ld  d,a
    3813   00:546B                          SEND_DATA                       ; Send the command size msb
    3813   00:546B  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3814   00:546E  7D                      ld  a,l
    3815   00:546F  5F                      ld  e,a
    3816   00:5470                          SEND_DATA                       ; Send the command size lsb
    3816   00:5470  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3817   00:5473                      
    3818   00:5473  E1                      pop hl                          ; Restore the memory address for the parameters
    3819   00:5474                      ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    3820   00:5474  43                      ld  b,e                         ; Number of loops originaly in DE
    3821   00:5475  1B                      dec de
    3822   00:5476  14                      inc d
    3823   00:5477                          if USE_MEM_IO = 0
    3824   00:5477                    ~     ld  c,OUT_TX_PORT
    3825   00:5477                    ~ TCPIP_TCP_OPEN_R:
    3826   00:5477                    ~     outi
    3827   00:5477                    ~     jr  nz,TCPIP_TCP_OPEN_R
    3828   00:5477                    ~     else
    3829   00:5477                      TCPIP_TCP_OPEN_R:
    3830   00:5477  7E                      ld  a,(hl)
    3831   00:5478  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    3832   00:547B  23                      inc hl
    3833   00:547C  10 F9                   djnz TCPIP_TCP_OPEN_R
    3834   00:547E                          endif
    3835   00:547E  15                      dec d
    3836   00:547F  20 F6                   jr  nz,TCPIP_TCP_OPEN_R
    3837   00:5481                      
    3838   00:5481                      TCPIP_TCP_OPEN_WAIT_RESPONSE:
    3839   00:5481                          ; Now wait up to 3600 (1 minute @ 60Hz) ticks to get response
    3840   00:5481                          ; TLS Connections might take SEVERAL seconds on TLS Handshake
    3841   00:5481                          ; Even more if certificates database is being indexed
    3842   00:5481  21 10 0E                ld  hl,3600
    3843   00:5484  CD AC 59                call    SETCOUNTER
    3844   00:5487                      TCPIP_TCP_OPEN_ST1:
    3845   00:5487                          CHECK_DATA
    3845   00:5487  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3845   00:548A  CB 47             >     bit 0,a
    3846   00:548C  20 05                   jr  nz,TCPIP_TCP_OPEN_ST1.1
    3847   00:548E  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3848   00:5491  18 F4                   jr  TCPIP_TCP_OPEN_ST1
    3849   00:5493                      TCPIP_TCP_OPEN_ST1.1:
    3850   00:5493                          ; nz, check the data
    3851   00:5493                          RECEIVE_DATA
    3851   00:5493  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3852   00:5496  FE 0D                   cp  13                          ; Is response of our command?
    3853   00:5498  20 ED                   jr  nz,TCPIP_TCP_OPEN_ST1
    3854   00:549A                          ; now get return code, if return code other than 0, it is finished
    3855   00:549A                      TCPIP_TCP_OPEN_RC:
    3856   00:549A                          CHECK_DATA
    3856   00:549A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3856   00:549D  CB 47             >     bit 0,a
    3857   00:549F  20 05                   jr  nz,TCPIP_TCP_OPEN_RC.1
    3858   00:54A1  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3859   00:54A4  18 F4                   jr  TCPIP_TCP_OPEN_RC
    3860   00:54A6                      TCPIP_TCP_OPEN_RC.1:
    3861   00:54A6                          ; nz, discard
    3862   00:54A6                          RECEIVE_DATA
    3862   00:54A6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3863   00:54A9  B7                      or  a                           ; 0?
    3864   00:54AA  C2 D0 53                jp  nz,TCPIP_TCP_OPEN_ERROR
    3865   00:54AD                      
    3866   00:54AD                          ; next two bytes are size bytes, don't care, it is 1, conn #
    3867   00:54AD  06 02                   ld  b,2
    3868   00:54AF                      TCPIP_TCP_OPEN_ST2:
    3869   00:54AF                          CHECK_DATA
    3869   00:54AF  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3869   00:54B2  CB 47             >     bit 0,a
    3870   00:54B4  20 05                   jr  nz,TCPIP_TCP_OPEN_ST2.1
    3871   00:54B6  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3872   00:54B9  18 F4                   jr  TCPIP_TCP_OPEN_ST2
    3873   00:54BB                      TCPIP_TCP_OPEN_ST2.1:
    3874   00:54BB                          ; nz, discard
    3875   00:54BB                          RECEIVE_DATA
    3875   00:54BB  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3876   00:54BE  05                      dec b
    3877   00:54BF  20 EE                   jr  nz,TCPIP_TCP_OPEN_ST2
    3878   00:54C1                      
    3879   00:54C1                          ; now just get the 1 byte, conn#, should go to B
    3880   00:54C1                      TCPIP_TCP_OPEN_CONN_ST1:
    3881   00:54C1                          CHECK_DATA
    3881   00:54C1  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3881   00:54C4  CB 47             >     bit 0,a
    3882   00:54C6  20 05                   jr  nz,TCPIP_TCP_OPEN_CONN_ST1.1
    3883   00:54C8  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3884   00:54CB  18 F4                   jr  TCPIP_TCP_OPEN_CONN_ST1
    3885   00:54CD                      TCPIP_TCP_OPEN_CONN_ST1.1:
    3886   00:54CD                          ; nz, get it
    3887   00:54CD                          RECEIVE_DATA
    3887   00:54CD  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3888   00:54D0  47                      ld  b,a
    3889   00:54D1                          ; done
    3890   00:54D1  AF                      xor a
    3891   00:54D2  C9                      ret
    3892   00:54D3                      
    3893   00:54D3                      ;=========================
    3894   00:54D3                      ;===  TCPIP_TCP_CLOSE  ===
    3895   00:54D3                      ;=========================
    3896   00:54D3                      ;Close a TCP connection.
    3897   00:54D3                      ;
    3898   00:54D3                      ;Input:  A = 14
    3899   00:54D3                      ;        B = Connection number
    3900   00:54D3                      ;            0 to close all open transient UDP connections
    3901   00:54D3                      ;Output: A = Error code
    3902   00:54D3                      TCPIP_TCP_CLOSE:
    3903   00:54D3                          SEND_DATA                       ; Send the command
    3903   00:54D3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3904   00:54D6  AF                      xor a
    3905   00:54D7                          SEND_DATA                       ; Send the command size msb
    3905   00:54D7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3906   00:54DA  3E 01                   ld  a,1
    3907   00:54DC                          SEND_DATA                       ; Send the command size lsb
    3907   00:54DC  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3908   00:54DF  78                      ld  a,b
    3909   00:54E0                          SEND_DATA                       ; Send the connection #
    3909   00:54E0  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3910   00:54E3                          ; Now wait up to 180 ticks to get response
    3911   00:54E3  21 B4 00                ld  hl,180
    3912   00:54E6  CD AC 59                call    SETCOUNTER
    3913   00:54E9                      TCPIP_TCP_CLOSE_ST1:
    3914   00:54E9                          CHECK_DATA
    3914   00:54E9  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3914   00:54EC  CB 47             >     bit 0,a
    3915   00:54EE  20 05                   jr  nz,TCPIP_TCP_CLOSE_ST1.1
    3916   00:54F0  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3917   00:54F3  18 F4                   jr  TCPIP_TCP_CLOSE_ST1
    3918   00:54F5                      TCPIP_TCP_CLOSE_ST1.1:
    3919   00:54F5                          ; nz, check the data
    3920   00:54F5                          RECEIVE_DATA
    3920   00:54F5  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3921   00:54F8  FE 0E                   cp  14                          ; Is response of our command?
    3922   00:54FA  20 ED                   jr  nz,TCPIP_TCP_CLOSE_ST1
    3923   00:54FC                          ; now get return code, if return code other than 0, it is finished
    3924   00:54FC                      TCPIP_TCP_CLOSE_RC:
    3925   00:54FC                          CHECK_DATA
    3925   00:54FC  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3925   00:54FF  CB 47             >     bit 0,a
    3926   00:5501  20 05                   jr  nz,TCPIP_TCP_CLOSE_RC.1
    3927   00:5503  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3928   00:5506  18 F4                   jr  TCPIP_TCP_CLOSE_RC
    3929   00:5508                      TCPIP_TCP_CLOSE_RC.1:
    3930   00:5508                          ; nz, discard
    3931   00:5508                          RECEIVE_DATA
    3931   00:5508  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3932   00:550B  B7                      or  a                           ; 0?
    3933   00:550C  C0                      ret nz                          ; if not, done
    3934   00:550D                      
    3935   00:550D                          ; next two bytes are return code and size bytes, don't care, it is 0
    3936   00:550D  06 02                   ld  b,2
    3937   00:550F                      TCPIP_TCP_CLOSE_ST2:
    3938   00:550F                          CHECK_DATA
    3938   00:550F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3938   00:5512  CB 47             >     bit 0,a
    3939   00:5514  20 05                   jr  nz,TCPIP_TCP_CLOSE_ST2.1
    3940   00:5516  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3941   00:5519  18 F4                   jr  TCPIP_TCP_CLOSE_ST2
    3942   00:551B                      TCPIP_TCP_CLOSE_ST2.1:
    3943   00:551B                          ; nz, discard
    3944   00:551B                          RECEIVE_DATA
    3944   00:551B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3945   00:551E  05                      dec b
    3946   00:551F  20 EE                   jr  nz,TCPIP_TCP_CLOSE_ST2
    3947   00:5521                      
    3948   00:5521                          ; done, no return data other than return code
    3949   00:5521  AF                      xor a
    3950   00:5522  C9                      ret
    3951   00:5523                      
    3952   00:5523                      ;=========================
    3953   00:5523                      ;===  TCPIP_TCP_ABORT  ===
    3954   00:5523                      ;=========================
    3955   00:5523                      ;Abort a TCP connection.
    3956   00:5523                      ;Input:  A  = 15
    3957   00:5523                      ;        B = Connection number
    3958   00:5523                      ;            0 to abort all open transient TCP connections
    3959   00:5523                      ;Output: A = Error code
    3960   00:5523                      
    3961   00:5523                      TCPIP_TCP_ABORT:
    3962   00:5523                          SEND_DATA                       ; Send the command
    3962   00:5523  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3963   00:5526  AF                      xor a
    3964   00:5527                          SEND_DATA                       ; Send the command size msb
    3964   00:5527  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3965   00:552A  3E 01                   ld  a,1
    3966   00:552C                          SEND_DATA                       ; Send the command size lsb
    3966   00:552C  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3967   00:552F  78                      ld  a,b
    3968   00:5530                          SEND_DATA                       ; Send the connection #
    3968   00:5530  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    3969   00:5533                          ; Now wait up to 180 ticks to get response
    3970   00:5533  21 B4 00                ld  hl,180
    3971   00:5536  CD AC 59                call    SETCOUNTER
    3972   00:5539                      TCPIP_TCP_ABORT_ST1:
    3973   00:5539                          CHECK_DATA
    3973   00:5539  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3973   00:553C  CB 47             >     bit 0,a
    3974   00:553E  20 05                   jr  nz,TCPIP_TCP_ABORT_ST1.1
    3975   00:5540  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3976   00:5543  18 F4                   jr  TCPIP_TCP_ABORT_ST1
    3977   00:5545                      TCPIP_TCP_ABORT_ST1.1:
    3978   00:5545                          ; nz, check the data
    3979   00:5545                          RECEIVE_DATA
    3979   00:5545  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3980   00:5548  FE 0F                   cp  15                          ; Is response of our command?
    3981   00:554A  20 ED                   jr  nz,TCPIP_TCP_ABORT_ST1
    3982   00:554C                          ; now get return code, if return code other than 0, it is finished
    3983   00:554C                      TCPIP_TCP_ABORT_RC:
    3984   00:554C                          CHECK_DATA
    3984   00:554C  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3984   00:554F  CB 47             >     bit 0,a
    3985   00:5551  20 05                   jr  nz,TCPIP_TCP_ABORT_RC.1
    3986   00:5553  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    3987   00:5556  18 F4                   jr  TCPIP_TCP_ABORT_RC
    3988   00:5558                      TCPIP_TCP_ABORT_RC.1:
    3989   00:5558                          ; nz, discard
    3990   00:5558                          RECEIVE_DATA
    3990   00:5558  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    3991   00:555B  B7                      or  a                           ; 0?
    3992   00:555C  C0                      ret nz                          ; if not, done
    3993   00:555D                      
    3994   00:555D                          ; next two bytes are return code and size bytes, don't care, it is 0
    3995   00:555D  06 02                   ld  b,2
    3996   00:555F                      TCPIP_TCP_ABORT_ST2:
    3997   00:555F                          CHECK_DATA
    3997   00:555F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    3997   00:5562  CB 47             >     bit 0,a
    3998   00:5564  20 05                   jr  nz,TCPIP_TCP_ABORT_ST2.1
    3999   00:5566  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4000   00:5569  18 F4                   jr  TCPIP_TCP_ABORT_ST2
    4001   00:556B                      TCPIP_TCP_ABORT_ST2.1:
    4002   00:556B                          ; nz, discard
    4003   00:556B                          RECEIVE_DATA
    4003   00:556B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4004   00:556E  05                      dec b
    4005   00:556F  20 EE                   jr  nz,TCPIP_TCP_ABORT_ST2
    4006   00:5571                      
    4007   00:5571                          ; done, no return data other than return code
    4008   00:5571  AF                      xor a
    4009   00:5572  C9                      ret
    4010   00:5573                      
    4011   00:5573                      ;=========================
    4012   00:5573                      ;===  TCPIP_TCP_STATE  ===
    4013   00:5573                      ;=========================
    4014   00:5573                      ;Get the state of a TCP connection.
    4015   00:5573                      ;
    4016   00:5573                      ;Input:  A = 16
    4017   00:5573                      ;        B = Connection number
    4018   00:5573                      ;        HL = Pointer in TPA for connection information block
    4019   00:5573                      ;             (0 if not needed)
    4020   00:5573                      ;Output: A  = Error code
    4021   00:5573                      ;        B  = Connection state
    4022   00:5573                      ;        C  = Close reason (only if ERR_NO_CONN is returned)
    4023   00:5573                      ;        HL = Number of total available incoming bytes
    4024   00:5573                      ;        DE = Number of urgent available incoming bytes
    4025   00:5573                      ;        IX = Available free space in the output buffer
    4026   00:5573                      ;             (0FFFFh = infinite)
    4027   00:5573                      ;
    4028   00:5573                      ;Connection information block consists of:
    4029   00:5573                      ;
    4030   00:5573                      ;    +0 (4): Remote IP address
    4031   00:5573                      ;    +4 (2): Remote port
    4032   00:5573                      ;    +6 (2): Local port
    4033   00:5573                      TCPIP_TCP_STATE_ERROR:
    4034   00:5573                          ; next two bytes are size bytes, don't care
    4035   00:5573  47                      ld  b,a                         ; save error in b
    4036   00:5574  0E 02                   ld  c,2
    4037   00:5576                      TCPIP_TCP_STATE_ERROR2:
    4038   00:5576                          CHECK_DATA
    4038   00:5576  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4038   00:5579  CB 47             >     bit 0,a
    4039   00:557B  20 05                   jr  nz,TCPIP_TCP_STATE_ERROR2.1
    4040   00:557D  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4041   00:5580  18 F4                   jr  TCPIP_TCP_STATE_ERROR2
    4042   00:5582                      TCPIP_TCP_STATE_ERROR2.1:
    4043   00:5582                          ; nz, discard
    4044   00:5582                          RECEIVE_DATA
    4044   00:5582  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4045   00:5585  0D                      dec c
    4046   00:5586  20 EE                   jr  nz,TCPIP_TCP_STATE_ERROR2
    4047   00:5588                      
    4048   00:5588                          ; now return w/ error that is saved in b
    4049   00:5588  78                      ld  a,b
    4050   00:5589  06 00                   ld  b,0
    4051   00:558B  0E 07                   ld  c,7
    4052   00:558D  21 00 00                ld  hl,0
    4053   00:5590  11 00 00                ld  de,0
    4054   00:5593  DD 21 00 00             ld  ix,0
    4055   00:5597  C9                      ret
    4056   00:5598                      
    4057   00:5598                      TCPIP_TCP_STATE:
    4058   00:5598  CD F5 59                call    SETWORD                 ; Save HL pointer in our memory
    4059   00:559B  7C                      ld  a,h
    4060   00:559C  B5                      or  l                           ; Information block required?
    4061   00:559D  3E 00                   ld  a,0                         ; do not want to mess with flags, let's say no need
    4062   00:559F  28 01                   jr  z,TCPIP_TCP_STATE_NOINFOBLOCK
    4063   00:55A1  3C                      inc a                           ; otherwise there is a need
    4064   00:55A2                      TCPIP_TCP_STATE_NOINFOBLOCK:
    4065   00:55A2  CD CE 59                call    SETBYTE                 ; Save for later
    4066   00:55A5  3E 10                   ld  a,16                        ; Our command
    4067   00:55A7                          SEND_DATA                       ; Send the command
    4067   00:55A7  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4068   00:55AA  AF                      xor a
    4069   00:55AB                          SEND_DATA                       ; Send the command size msb
    4069   00:55AB  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4070   00:55AE  3C                      inc a
    4071   00:55AF                          SEND_DATA                       ; Send the command size lsb
    4071   00:55AF  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4072   00:55B2  78                      ld  a,b
    4073   00:55B3                          SEND_DATA                       ; Send the parameter
    4073   00:55B3  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4074   00:55B6                      
    4075   00:55B6                          ; Now wait up to 180 ticks to get response
    4076   00:55B6  21 B4 00                ld  hl,180
    4077   00:55B9  CD AC 59                call    SETCOUNTER
    4078   00:55BC                      TCPIP_TCP_STATE_ST1:
    4079   00:55BC                          CHECK_DATA
    4079   00:55BC  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4079   00:55BF  CB 47             >     bit 0,a
    4080   00:55C1  20 05                   jr  nz,TCPIP_TCP_STATE_ST1.1
    4081   00:55C3  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4082   00:55C6  18 F4                   jr  TCPIP_TCP_STATE_ST1
    4083   00:55C8                      TCPIP_TCP_STATE_ST1.1:
    4084   00:55C8                          ; nz, check the data
    4085   00:55C8                          RECEIVE_DATA
    4085   00:55C8  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4086   00:55CB  FE 10                   cp  16                          ; Is response of our command?
    4087   00:55CD  20 ED                   jr  nz,TCPIP_TCP_STATE_ST1
    4088   00:55CF                          ; now get return code, if return code other than 0, it is finished
    4089   00:55CF                      TCPIP_TCP_STATE_RC:
    4090   00:55CF                          CHECK_DATA
    4090   00:55CF  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4090   00:55D2  CB 47             >     bit 0,a
    4091   00:55D4  20 05                   jr  nz,TCPIP_TCP_STATE_RC.1
    4092   00:55D6  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4093   00:55D9  18 F4                   jr  TCPIP_TCP_STATE_RC
    4094   00:55DB                      TCPIP_TCP_STATE_RC.1:
    4095   00:55DB                          ; nz, discard
    4096   00:55DB                          RECEIVE_DATA
    4096   00:55DB  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4097   00:55DE  B7                      or  a                           ; 0?
    4098   00:55DF  20 92                   jr  nz,TCPIP_TCP_STATE_ERROR    ; if not, done
    4099   00:55E1                      
    4100   00:55E1                          ; next two bytes are return code and size bytes, don't care, it is 16
    4101   00:55E1  06 02                   ld  b,2
    4102   00:55E3                      TCPIP_TCP_STATE_ST2:
    4103   00:55E3                          CHECK_DATA
    4103   00:55E3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4103   00:55E6  CB 47             >     bit 0,a
    4104   00:55E8  20 05                   jr  nz,TCPIP_TCP_STATE_ST2.1
    4105   00:55EA  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4106   00:55ED  18 F4                   jr  TCPIP_TCP_STATE_ST2
    4107   00:55EF                      TCPIP_TCP_STATE_ST2.1:
    4108   00:55EF                          ; nz, discard
    4109   00:55EF                          RECEIVE_DATA
    4109   00:55EF  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4110   00:55F2  05                      dec b
    4111   00:55F3  20 EE                   jr  nz,TCPIP_TCP_STATE_ST2
    4112   00:55F5                      
    4113   00:55F5                          ; now just get the 16 bytes (Port LSB then MSB, # of packets, packet size LSB then MSB) and order it in C, B, L, H, E, D, IXL and IXH.
    4114   00:55F5                          ; Remaining 8 bytes go to TCP_STATE_INFORMATION_BLOCK if its value is other than 0
    4115   00:55F5                      TCPIP_TCP_STATE_RESP_ST1:
    4116   00:55F5                          CHECK_DATA
    4116   00:55F5  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4116   00:55F8  CB 47             >     bit 0,a
    4117   00:55FA  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST1.1
    4118   00:55FC  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4119   00:55FF  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST1
    4120   00:5601                      TCPIP_TCP_STATE_RESP_ST1.1:
    4121   00:5601                          ; nz, get it
    4122   00:5601                          RECEIVE_DATA
    4122   00:5601  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4123   00:5604  4F                      ld  c,a
    4124   00:5605                      TCPIP_TCP_STATE_RESP_ST2:
    4125   00:5605                          CHECK_DATA
    4125   00:5605  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4125   00:5608  CB 47             >     bit 0,a
    4126   00:560A  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST2.1
    4127   00:560C  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4128   00:560F  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST2
    4129   00:5611                      TCPIP_TCP_STATE_RESP_ST2.1:
    4130   00:5611                          ; nz, get it
    4131   00:5611                          RECEIVE_DATA
    4131   00:5611  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4132   00:5614  47                      ld  b,a
    4133   00:5615                      TCPIP_TCP_STATE_RESP_ST3:
    4134   00:5615                          CHECK_DATA
    4134   00:5615  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4134   00:5618  CB 47             >     bit 0,a
    4135   00:561A  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST3.1
    4136   00:561C  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4137   00:561F  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST3
    4138   00:5621                      TCPIP_TCP_STATE_RESP_ST3.1:
    4139   00:5621                          ; nz, get it
    4140   00:5621                          RECEIVE_DATA
    4140   00:5621  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4141   00:5624  6F                      ld  l,a
    4142   00:5625                      TCPIP_TCP_STATE_RESP_ST4:
    4143   00:5625                          CHECK_DATA
    4143   00:5625  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4143   00:5628  CB 47             >     bit 0,a
    4144   00:562A  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST4.1
    4145   00:562C  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4146   00:562F  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST4
    4147   00:5631                      TCPIP_TCP_STATE_RESP_ST4.1:
    4148   00:5631                          ; nz, get it
    4149   00:5631                          RECEIVE_DATA
    4149   00:5631  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4150   00:5634  67                      ld  h,a
    4151   00:5635                      TCPIP_TCP_STATE_RESP_ST5:
    4152   00:5635                          CHECK_DATA
    4152   00:5635  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4152   00:5638  CB 47             >     bit 0,a
    4153   00:563A  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST5.1
    4154   00:563C  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4155   00:563F  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST5
    4156   00:5641                      TCPIP_TCP_STATE_RESP_ST5.1:
    4157   00:5641                          ; nz, get it
    4158   00:5641                          RECEIVE_DATA
    4158   00:5641  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4159   00:5644  5F                      ld  e,a
    4160   00:5645                      TCPIP_TCP_STATE_RESP_ST6:
    4161   00:5645                          CHECK_DATA
    4161   00:5645  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4161   00:5648  CB 47             >     bit 0,a
    4162   00:564A  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST6.1
    4163   00:564C  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4164   00:564F  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST6
    4165   00:5651                      TCPIP_TCP_STATE_RESP_ST6.1:
    4166   00:5651                          ; nz, get it
    4167   00:5651                          RECEIVE_DATA
    4167   00:5651  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4168   00:5654  57                      ld  d,a
    4169   00:5655                      TCPIP_TCP_STATE_RESP_ST7:
    4170   00:5655                          CHECK_DATA
    4170   00:5655  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4170   00:5658  CB 47             >     bit 0,a
    4171   00:565A  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST7.1
    4172   00:565C  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4173   00:565F  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST7
    4174   00:5661                      TCPIP_TCP_STATE_RESP_ST7.1:
    4175   00:5661                          ; nz, get it
    4176   00:5661                          RECEIVE_DATA
    4176   00:5661  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4177   00:5664  DD 6F                   ld  ixl,a
    4178   00:5666                      TCPIP_TCP_STATE_RESP_ST8:
    4179   00:5666                          CHECK_DATA
    4179   00:5666  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4179   00:5669  CB 47             >     bit 0,a
    4180   00:566B  20 05                   jr  nz,TCPIP_TCP_STATE_RESP_ST8.1
    4181   00:566D  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4182   00:5670  18 F4                   jr  TCPIP_TCP_STATE_RESP_ST8
    4183   00:5672                      TCPIP_TCP_STATE_RESP_ST8.1:
    4184   00:5672                          ; nz, get it
    4185   00:5672                          RECEIVE_DATA
    4185   00:5672  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4186   00:5675  DD 67                   ld  ixh,a
    4187   00:5677                      
    4188   00:5677                      ; Check if there is an information block
    4189   00:5677  CD 55 5A                call    BCBACKUP                ; Save BC, we gonna use it
    4190   00:567A  06 08                   ld  b,8                         ; prepare in advance for 8 bytes being transferred
    4191   00:567C  CD BC 59                call    GETBYTE                 ; Let's check if we have flagged need for INFOBLOCK
    4192   00:567F  B7                      or  a
    4193   00:5680  20 17                   jr  nz,TCPIP_TCP_STATE_GET_IBLOCK
    4194   00:5682                      
    4195   00:5682                      ; If here, just discard Information Block (next 8 bytes)
    4196   00:5682                      TCPIP_TCP_STATE_DISCARD_IBLOCK:
    4197   00:5682                          CHECK_DATA
    4197   00:5682  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4197   00:5685  CB 47             >     bit 0,a
    4198   00:5687  20 05                   jr  nz,TCPIP_TCP_STATE_DISCARD_IBLOCK.1
    4199   00:5689  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4200   00:568C  18 F4                   jr  TCPIP_TCP_STATE_DISCARD_IBLOCK
    4201   00:568E                      TCPIP_TCP_STATE_DISCARD_IBLOCK.1:
    4202   00:568E                          ; nz, discard
    4203   00:568E                          RECEIVE_DATA
    4203   00:568E  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4204   00:5691  05                      dec b
    4205   00:5692  20 EE                   jr  nz,TCPIP_TCP_STATE_DISCARD_IBLOCK
    4206   00:5694                          ; done
    4207   00:5694  CD 43 5A                call    BCRESTORE
    4208   00:5697  AF                      xor a
    4209   00:5698  C9                      ret
    4210   00:5699                      
    4211   00:5699                      ; If here, save Information Block (next 8 bytes)
    4212   00:5699                      TCPIP_TCP_STATE_GET_IBLOCK:
    4213   00:5699  CD 7C 5A                call    HLBACKUP                ; Save HL
    4214   00:569C  CD E2 59                call    GETWORD                 ; Restore address for IB on HL
    4215   00:569F                      TCPIP_TCP_STATE_SAVE_IBLOCK:
    4216   00:569F                          CHECK_DATA
    4216   00:569F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4216   00:56A2  CB 47             >     bit 0,a
    4217   00:56A4  20 05                   jr  nz,TCPIP_TCP_STATE_SAVE_IBLOCK.1
    4218   00:56A6  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4219   00:56A9  18 F4                   jr  TCPIP_TCP_STATE_SAVE_IBLOCK
    4220   00:56AB                      TCPIP_TCP_STATE_SAVE_IBLOCK.1:
    4221   00:56AB                          ; nz, save
    4222   00:56AB                          RECEIVE_DATA
    4222   00:56AB  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4223   00:56AE  77                      ld  (hl),a
    4224   00:56AF  23                      inc hl
    4225   00:56B0  05                      dec b
    4226   00:56B1  20 EC                   jr  nz,TCPIP_TCP_STATE_SAVE_IBLOCK
    4227   00:56B3                          ; done
    4228   00:56B3  CD 69 5A                call    HLRESTORE
    4229   00:56B6  CD 43 5A                call    BCRESTORE
    4230   00:56B9  AF                      xor a
    4231   00:56BA  C9                      ret
    4232   00:56BB                      
    4233   00:56BB                      ;========================
    4234   00:56BB                      ;===  TCPIP_TCP_SEND  ===
    4235   00:56BB                      ;========================
    4236   00:56BB                      ;Send data to a TCP connection.
    4237   00:56BB                      ;
    4238   00:56BB                      ;Input:  A  = 17
    4239   00:56BB                      ;        B  = Connection number
    4240   00:56BB                      ;        DE = Address of the data to be sent
    4241   00:56BB                      ;        HL = Length of the data to be sent
    4242   00:56BB                      ;        C  = Flags:
    4243   00:56BB                      ;             bit 0: Send the data PUSHed
    4244   00:56BB                      ;             bit 1: The data is urgent
    4245   00:56BB                      ;Output: A = Error code
    4246   00:56BB                      TCPIP_TCP_SEND_ERROR:
    4247   00:56BB                          ; next two bytes are size bytes, don't care
    4248   00:56BB  47                      ld  b,a                         ; save error in b
    4249   00:56BC  0E 02                   ld  c,2
    4250   00:56BE                      TCPIP_TCP_SEND_ERROR2:
    4251   00:56BE                          CHECK_DATA
    4251   00:56BE  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4251   00:56C1  CB 47             >     bit 0,a
    4252   00:56C3  20 05                   jr  nz,TCPIP_TCP_SEND_ERROR2.1
    4253   00:56C5  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4254   00:56C8  18 F4                   jr  TCPIP_TCP_SEND_ERROR2
    4255   00:56CA                      TCPIP_TCP_SEND_ERROR2.1:
    4256   00:56CA                          ; nz, discard
    4257   00:56CA                          RECEIVE_DATA
    4257   00:56CA  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4258   00:56CD  0D                      dec c
    4259   00:56CE  20 EE                   jr  nz,TCPIP_TCP_SEND_ERROR2
    4260   00:56D0                          ; now return w/ error that is saved in b
    4261   00:56D0  78                      ld  a,b
    4262   00:56D1  C9                      ret
    4263   00:56D2                      
    4264   00:56D2                      TCPIP_TCP_SEND:
    4265   00:56D2  E5                      push    hl
    4266   00:56D3  D5                      push    de
    4267   00:56D4                          SEND_DATA                       ; Send the command
    4267   00:56D4  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4268   00:56D7                          ; prepare new data size, adding our 2 bytes overhead
    4269   00:56D7  11 02 00                ld  de,2
    4270   00:56DA  19                      add hl,de
    4271   00:56DB  7C                      ld  a,h
    4272   00:56DC                          SEND_DATA                       ; Send the command size msb
    4272   00:56DC  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4273   00:56DF  7D                      ld  a,l
    4274   00:56E0                          SEND_DATA                       ; Send the command size lsb
    4274   00:56E0  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4275   00:56E3  78                      ld  a,b
    4276   00:56E4                          SEND_DATA                       ; Send the connection #
    4276   00:56E4  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4277   00:56E7  79                      ld  a,c
    4278   00:56E8                          SEND_DATA                       ; Send the connection flags
    4278   00:56E8  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4279   00:56EB  E1                      pop hl
    4280   00:56EC  D1                      pop de
    4281   00:56ED                          ; now oti the data starting at hl, size is in DE
    4282   00:56ED                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
    4283   00:56ED  43                      ld  b,e                         ;Number of loops originaly in DE
    4284   00:56EE  1B                      dec de
    4285   00:56EF  14                      inc d
    4286   00:56F0                          if USE_MEM_IO = 0
    4287   00:56F0                    ~     ld  c,OUT_TX_PORT
    4288   00:56F0                    ~ TCPIP_TCP_SEND_R:
    4289   00:56F0                    ~     outi
    4290   00:56F0                    ~     jr  nz,TCPIP_TCP_SEND_R
    4291   00:56F0                    ~     else
    4292   00:56F0                      TCPIP_TCP_SEND_R:
    4293   00:56F0  7E                      ld  a,(hl)
    4294   00:56F1  32 07 7F                ld  (MEM_OUT_TX_PORT),a
    4295   00:56F4  23                      inc hl
    4296   00:56F5  10 F9                   djnz TCPIP_TCP_SEND_R
    4297   00:56F7                          endif
    4298   00:56F7  15                      dec d
    4299   00:56F8  20 F6                   jr  nz,TCPIP_TCP_SEND_R
    4300   00:56FA                      
    4301   00:56FA                          ; Now wait up to 600 ticks to get response
    4302   00:56FA  21 58 02                ld  hl,600
    4303   00:56FD  CD AC 59                call    SETCOUNTER
    4304   00:5700                      TCPIP_TCP_SEND_ST1:
    4305   00:5700                          CHECK_DATA
    4305   00:5700  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4305   00:5703  CB 47             >     bit 0,a
    4306   00:5705  20 05                   jr  nz,TCPIP_TCP_SEND_R.1
    4307   00:5707  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4308   00:570A  18 F4                   jr  TCPIP_TCP_SEND_ST1
    4309   00:570C                      TCPIP_TCP_SEND_R.1:
    4310   00:570C                          ; nz, check the data
    4311   00:570C                          RECEIVE_DATA
    4311   00:570C  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4312   00:570F  FE 11                   cp  17                          ; Is response of our command?
    4313   00:5711  20 ED                   jr  nz,TCPIP_TCP_SEND_ST1
    4314   00:5713                          ; now get return code, if return code other than 0, it is finished
    4315   00:5713                      TCPIP_TCP_SEND_RC:
    4316   00:5713                          CHECK_DATA
    4316   00:5713  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4316   00:5716  CB 47             >     bit 0,a
    4317   00:5718  20 05                   jr  nz,TCPIP_TCP_SEND_RC.1
    4318   00:571A  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4319   00:571D  18 F4                   jr  TCPIP_TCP_SEND_RC
    4320   00:571F                      TCPIP_TCP_SEND_RC.1:
    4321   00:571F                          ; nz, discard
    4322   00:571F                          RECEIVE_DATA
    4322   00:571F  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4323   00:5722  B7                      or  a                           ; 0?
    4324   00:5723  C0                      ret nz                          ; if not, done
    4325   00:5724                      
    4326   00:5724                          ; next two bytes are return code and size bytes, don't care, it is 0
    4327   00:5724  06 02                   ld  b,2
    4328   00:5726                      TCPIP_TCP_SEND_ST2:
    4329   00:5726                          CHECK_DATA
    4329   00:5726  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4329   00:5729  CB 47             >     bit 0,a
    4330   00:572B  20 05                   jr  nz,TCPIP_TCP_SEND_ST2.1
    4331   00:572D  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4332   00:5730  18 F4                   jr  TCPIP_TCP_SEND_ST2
    4333   00:5732                      TCPIP_TCP_SEND_ST2.1:
    4334   00:5732                          ; nz, discard
    4335   00:5732                          RECEIVE_DATA
    4335   00:5732  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4336   00:5735  05                      dec b
    4337   00:5736  20 EE                   jr  nz,TCPIP_TCP_SEND_ST2
    4338   00:5738                      
    4339   00:5738                          ; done, no return data other than return code
    4340   00:5738  AF                      xor a
    4341   00:5739  C9                      ret
    4342   00:573A                      
    4343   00:573A                      ;=======================
    4344   00:573A                      ;===  TCPIP_TCP_RCV  ===
    4345   00:573A                      ;=======================
    4346   00:573A                      ;Receive data from a TCP connection.
    4347   00:573A                      ;
    4348   00:573A                      ;Input:   A  = 18
    4349   00:573A                      ;         B  = Connection number
    4350   00:573A                      ;         DE = Address for the retrieved data
    4351   00:573A                      ;         HL = Length of the data to be obtained
    4352   00:573A                      ;Output:  A  = Error code
    4353   00:573A                      ;         BC = Total number of bytes that have been actually retrieved
    4354   00:573A                      ;         HL = Number of urgent data bytes that have been retrieved
    4355   00:573A                      ;              (placed at the beginning of the received data block)
    4356   00:573A                      ; Save registers other than AF
    4357   00:573A                      TCPIP_TCP_RCV_CHECK_TIME_OUT:
    4358   00:573A  C5                      push bc
    4359   00:573B  D5                      push de
    4360   00:573C  E5                      push hl
    4361   00:573D  CD 9D 59                call    GETCOUNTER
    4362   00:5740  7D                      ld  a,l
    4363   00:5741  B4                      or  h
    4364   00:5742                          ; Restore registers, we are returning
    4365   00:5742  E1                      pop hl
    4366   00:5743  D1                      pop de
    4367   00:5744  C1                      pop bc
    4368   00:5745  C0                      ret nz
    4369   00:5746                          ; Ok, timeout...
    4370   00:5746  F1                      pop af                          ; Get return address of who called this out of the stack, we will return from the function or re-start
    4371   00:5747                      TCPIP_TCP_RCV_RETRY_QRCV:
    4372   00:5747  CD BC 59                call    GETBYTE
    4373   00:574A  B7                      or  a
    4374   00:574B  28 0C                   jr  z,TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY
    4375   00:574D                          ; Ok, so let's ask ESP to re-send the data and retry receiving it
    4376   00:574D  3D                      dec a
    4377   00:574E  CD CE 59                call    SETBYTE                 ; we are retrying it
    4378   00:5751  3E 72                   ld  a,'r'                       ; retry transmission command
    4379   00:5753                          SEND_DATA
    4379   00:5753  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4380   00:5756  C3 9D 57                jp  TCPIP_TCP_RCV.RXRETRY       ; and retry it
    4381   00:5759                      TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY:
    4382   00:5759  3E 0F                   ld  a,ERR_INV_OPER
    4383   00:575B  C9                      ret                             ; and return the function itself
    4384   00:575C                      
    4385   00:575C                      TCPIP_TCP_RCV_RET_ERR:
    4386   00:575C                          ; next two bytes are size bytes, don't care
    4387   00:575C  47                      ld  b,a                         ; save error in b
    4388   00:575D  0E 02                   ld  c,2
    4389   00:575F                      TCPIP_TCP_RCV_RET_ERR2:
    4390   00:575F                          CHECK_DATA
    4390   00:575F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4390   00:5762  CB 47             >     bit 0,a
    4391   00:5764  20 05                   jr  nz,TCPIP_TCP_RCV_RET_ERR2.1
    4392   00:5766  CD 3A 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4393   00:5769  18 F4                   jr  TCPIP_TCP_RCV_RET_ERR2
    4394   00:576B                      TCPIP_TCP_RCV_RET_ERR2.1:
    4395   00:576B                          ; nz, discard
    4396   00:576B                          RECEIVE_DATA
    4396   00:576B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4397   00:576E  0D                      dec c
    4398   00:576F  20 EE                   jr  nz,TCPIP_TCP_RCV_RET_ERR2
    4399   00:5771                          ; now return w/ error that is saved in b
    4400   00:5771  78                      ld  a,b
    4401   00:5772                      TCPIP_TCP_RCV_RET_NODATA:
    4402   00:5772  21 00 00                ld  hl,0
    4403   00:5775  01 00 00                ld  bc,0
    4404   00:5778  C9                      ret
    4405   00:5779                      
    4406   00:5779                      TCPIP_TCP_RCV:
    4407   00:5779  EB                      ex  de,hl
    4408   00:577A  CD F5 59                call    SETWORD
    4409   00:577D  EB                      ex  de,hl
    4410   00:577E  3E 12                   ld  a,18
    4411   00:5780                          SEND_DATA                       ; Send the command
    4411   00:5780  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4412   00:5783  AF                      xor a
    4413   00:5784                          SEND_DATA                       ; Send the command size msb
    4413   00:5784  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4414   00:5787  3E 03                   ld  a,3
    4415   00:5789                          SEND_DATA                       ; Send the command size lsb
    4415   00:5789  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4416   00:578C  78                      ld  a,b
    4417   00:578D                          SEND_DATA                       ; Send the connection #
    4417   00:578D  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4418   00:5790  7D                      ld  a,l
    4419   00:5791                          SEND_DATA                       ; Send MAX rcv size LSB
    4419   00:5791  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4420   00:5794  7C                      ld  a,h
    4421   00:5795                          SEND_DATA                       ; Send MAX rcv size MSB
    4421   00:5795  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4422   00:5798  3E 03                   ld  a,3
    4423   00:579A  CD CE 59                call    SETBYTE                 ; Ok, retry up to three times
    4424   00:579D                      TCPIP_TCP_RCV.RXRETRY:
    4425   00:579D                          ; Now wait up to 600 ticks to get response
    4426   00:579D  21 58 02                ld  hl,600
    4427   00:57A0  CD AC 59                call    SETCOUNTER
    4428   00:57A3                      TCPIP_TCP_RCV_ST1:
    4429   00:57A3                          CHECK_DATA
    4429   00:57A3  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4429   00:57A6  CB 47             >     bit 0,a
    4430   00:57A8  20 05                   jr  nz,TCPIP_TCP_RCV_ST1.1
    4431   00:57AA  CD 3A 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4432   00:57AD  18 F4                   jr  TCPIP_TCP_RCV_ST1
    4433   00:57AF                      TCPIP_TCP_RCV_ST1.1:
    4434   00:57AF                          ; nz, check the data
    4435   00:57AF                          RECEIVE_DATA
    4435   00:57AF  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4436   00:57B2  FE 12                   cp 18                           ; Is response of our command?
    4437   00:57B4  20 ED                   jr  nz,TCPIP_TCP_RCV_ST1
    4438   00:57B6                          ; At this point, all data is being buffered, so 15 ticks, quarter second, is more than enough time-out
    4439   00:57B6  F3                      di
    4440   00:57B7  21 1E 00                ld  hl,30
    4441   00:57BA  CD AC 59                call    SETCOUNTER
    4442   00:57BD  FB                      ei
    4443   00:57BE                          ; now get return code, if return code other than 0, it is finished
    4444   00:57BE                      TCPIP_TCP_RCV_RC:
    4445   00:57BE                          CHECK_DATA
    4445   00:57BE  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4445   00:57C1  CB 47             >     bit 0,a
    4446   00:57C3  20 05                   jr  nz,TCPIP_TCP_RCV_RC.1
    4447   00:57C5  CD 3A 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4448   00:57C8  18 F4                   jr  TCPIP_TCP_RCV_RC
    4449   00:57CA                      TCPIP_TCP_RCV_RC.1:
    4450   00:57CA                          ; nz, discard
    4451   00:57CA                          RECEIVE_DATA
    4451   00:57CA  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4452   00:57CD  B7                      or  a                           ; 0?
    4453   00:57CE  20 8C                   jr  nz,TCPIP_TCP_RCV_RET_ERR    ; if not, done
    4454   00:57D0                          ; next two bytes are response size bytes (UB count two bytes, always 0, and data read), save it -2 to BC
    4455   00:57D0                      TCPIP_TCP_RCV_ST2A:
    4456   00:57D0                          CHECK_DATA
    4456   00:57D0  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4456   00:57D3  CB 47             >     bit 0,a
    4457   00:57D5  20 05                   jr  nz,TCPIP_TCP_RCV_ST2A.1
    4458   00:57D7  CD 3A 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4459   00:57DA  18 F4                   jr  TCPIP_TCP_RCV_ST2A
    4460   00:57DC                      TCPIP_TCP_RCV_ST2A.1:
    4461   00:57DC                          ; nz, high byte count of bytes to receive
    4462   00:57DC                          RECEIVE_DATA
    4462   00:57DC  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4463   00:57DF  67                      ld h,a
    4464   00:57E0                      TCPIP_TCP_RCV_ST2B:
    4465   00:57E0                          CHECK_DATA
    4465   00:57E0  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4465   00:57E3  CB 47             >     bit 0,a
    4466   00:57E5  20 05                   jr  nz,TCPIP_TCP_RCV_ST2B.1
    4467   00:57E7  CD 3A 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4468   00:57EA  18 F4                   jr  TCPIP_TCP_RCV_ST2B
    4469   00:57EC                      TCPIP_TCP_RCV_ST2B.1:
    4470   00:57EC                          ; nz, low byte count of bytes to receive
    4471   00:57EC                          RECEIVE_DATA
    4471   00:57EC  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4472   00:57EF  6F                      ld  l,a
    4473   00:57F0  01 02 00                ld  bc,2
    4474   00:57F3                          ; subtract 2 (Urgent data count, not used)
    4475   00:57F3  AF                      xor a                           ; zero carry
    4476   00:57F4  ED 42                   sbc hl,bc
    4477   00:57F6                          ; if it was 0, will carry
    4478   00:57F6                          if USE_MEM_IO = 1
    4479   00:57F6  DA 72 57                jp  c,TCPIP_TCP_RCV_RET_NODATA
    4480   00:57F9                          else
    4481   00:57F9                    ~     jr  c,TCPIP_TCP_RCV_RET_NODATA
    4482   00:57F9                    ~     endif
    4483   00:57F9  4D                      ld  c,l
    4484   00:57FA  44                      ld  b,h                         ; BC has effective received data size, as well as HL
    4485   00:57FB                      
    4486   00:57FB                          ; now just discard 2 bytes urgent data
    4487   00:57FB                      TCPIP_TCP_RCV_UDC_ST1:
    4488   00:57FB                          CHECK_DATA
    4488   00:57FB  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4488   00:57FE  CB 47             >     bit 0,a
    4489   00:5800  20 05                   jr  nz,TCPIP_TCP_RCV_UDC_ST1.1
    4490   00:5802  CD 3A 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4491   00:5805  18 F4                   jr  TCPIP_TCP_RCV_UDC_ST1
    4492   00:5807                      TCPIP_TCP_RCV_UDC_ST1.1:
    4493   00:5807                          ; nz, get it
    4494   00:5807                          RECEIVE_DATA
    4494   00:5807  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4495   00:580A                      TCPIP_TCP_RCV_UDC_ST2:
    4496   00:580A                          CHECK_DATA
    4496   00:580A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4496   00:580D  CB 47             >     bit 0,a
    4497   00:580F  20 05                   jr  nz,TCPIP_TCP_RCV_UDC_ST2.1
    4498   00:5811  CD 3A 57                call    TCPIP_TCP_RCV_CHECK_TIME_OUT
    4499   00:5814  18 F4                   jr  TCPIP_TCP_RCV_UDC_ST2
    4500   00:5816                      TCPIP_TCP_RCV_UDC_ST2.1
    4501   00:5816                          ; nz, get it
    4502   00:5816                          RECEIVE_DATA
    4502   00:5816  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4503   00:5819                      
    4504   00:5819                          ; put effective data size in de
    4505   00:5819  EB                      ex  de,hl
    4506   00:581A                          ; will start moving at address in stack (we've pushed the adress in WORD)
    4507   00:581A  CD E2 59                call    GETWORD
    4508   00:581D  CD 55 5A                call    BCBACKUP                ; save count (BC)
    4509   00:5820                      
    4510   00:5820                          ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use ini :-D
    4511   00:5820  43                      ld  b,e                         ; Number of loops originaly in DE
    4512   00:5821  1B                      dec de
    4513   00:5822  14                      inc d
    4514   00:5823                          if USE_MEM_IO = 0
    4515   00:5823                    ~     ld  c,IN_DATA_PORT
    4516   00:5823                    ~ TCPIP_TCP_RCV_R:
    4517   00:5823                    ~     inir
    4518   00:5823                    ~     else
    4519   00:5823                      TCPIP_TCP_RCV_R:
    4520   00:5823  3A 06 7F                ld  a,(MEM_IN_DATA_PORT)
    4521   00:5826  77                      ld  (hl),a
    4522   00:5827  23                      inc hl
    4523   00:5828  10 F9                   djnz TCPIP_TCP_RCV_R
    4524   00:582A                          endif
    4525   00:582A  15                      dec d
    4526   00:582B  20 F6                   jr nz,TCPIP_TCP_RCV_R
    4527   00:582D                          CHECK_BUFFER_UNDERRUN
    4527   00:582D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4527   00:5830  CB 67             >     bit 4,a
    4528   00:5832  C2 47 57                jp  nz,TCPIP_TCP_RCV_RETRY_QRCV ; If yes, retry
    4529   00:5835                          ; Otherwise, done
    4530   00:5835  CD 43 5A                call    BCRESTORE               ; done, restore return data in BC
    4531   00:5838                          ; no urgent data support
    4532   00:5838  21 00 00                ld  hl,0
    4533   00:583B  AF                      xor a
    4534   00:583C  C9                      ret
    4535   00:583D                      
    4536   00:583D                      ;=============================
    4537   00:583D                      ;===  TCPIP_CONFIG_AUTOIP  ===
    4538   00:583D                      ;=============================
    4539   00:583D                      ;Enable or disable the automatic IP addresses retrieval.
    4540   00:583D                      ;
    4541   00:583D                      ;Input:  A = 25
    4542   00:583D                      ;        B = 0: Get current configuration
    4543   00:583D                      ;            1: Set configuration
    4544   00:583D                      ;        C = Configuration to set (only if B=1):
    4545   00:583D                      ;            bit 0: Set to automatically retrieve
    4546   00:583D                      ;                   local IP address, subnet mask and default gateway
    4547   00:583D                      ;            bit 1: Set to automatically retrieve DNS servers addresses
    4548   00:583D                      ;            bits 2-7: Unused, must be zero
    4549   00:583D                      ;Output: A = Error code
    4550   00:583D                      ;        C = Configuration after the routine execution
    4551   00:583D                      ;            (same format as C at input)
    4552   00:583D                      TCPIP_CONFIG_AUTOIP:
    4553   00:583D                          SEND_DATA                       ; Send the command
    4553   00:583D  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4554   00:5840  AF                      xor a
    4555   00:5841                          SEND_DATA                       ; Send the command size msb
    4555   00:5841  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4556   00:5844  3E 02                   ld  a,2
    4557   00:5846                          SEND_DATA                       ; Send the command size lsb
    4557   00:5846  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4558   00:5849  78                      ld  a,b
    4559   00:584A                          SEND_DATA                       ; Send the command
    4559   00:584A  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4560   00:584D  79                      ld  a,c
    4561   00:584E                          SEND_DATA                       ; Send the command parameter
    4561   00:584E  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4562   00:5851                      
    4563   00:5851                          ; Now wait up to 180 ticks to get response
    4564   00:5851  21 B4 00                ld hl,180
    4565   00:5854  CD AC 59                call    SETCOUNTER
    4566   00:5857                      TCPIP_CONFIG_AUTOIP_ST1:
    4567   00:5857                          CHECK_DATA
    4567   00:5857  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4567   00:585A  CB 47             >     bit 0,a
    4568   00:585C  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_ST1.1
    4569   00:585E  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4570   00:5861  18 F4                   jr  TCPIP_CONFIG_AUTOIP_ST1
    4571   00:5863                      TCPIP_CONFIG_AUTOIP_ST1.1:
    4572   00:5863                          ; nz, check the data
    4573   00:5863                          RECEIVE_DATA
    4573   00:5863  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4574   00:5866  FE 19                   cp  25                          ; Is response of our command?
    4575   00:5868  20 ED                   jr  nz,TCPIP_CONFIG_AUTOIP_ST1
    4576   00:586A                          ; now get return code, if return code other than 0, it is finished
    4577   00:586A                      TCPIP_CONFIG_AUTOIP_RC:
    4578   00:586A                          CHECK_DATA
    4578   00:586A  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4578   00:586D  CB 47             >     bit 0,a
    4579   00:586F  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_RC.1
    4580   00:5871  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4581   00:5874  18 F4                   jr  TCPIP_CONFIG_AUTOIP_RC
    4582   00:5876                      TCPIP_CONFIG_AUTOIP_RC.1:
    4583   00:5876                          ;nz, discard
    4584   00:5876                          RECEIVE_DATA
    4584   00:5876  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4585   00:5879  B7                      or  a                           ; 0?
    4586   00:587A  C0                      ret nz                          ; if not, done
    4587   00:587B                      
    4588   00:587B                          ; next two bytes are return code and size bytes, don't care, it is 1, configuration
    4589   00:587B  06 02                   ld  b,2
    4590   00:587D                      TCPIP_CONFIG_AUTOIP_ST2:
    4591   00:587D                          CHECK_DATA
    4591   00:587D  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4591   00:5880  CB 47             >     bit 0,a
    4592   00:5882  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_ST2.1
    4593   00:5884  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4594   00:5887  18 F4                   jr  TCPIP_CONFIG_AUTOIP_ST2
    4595   00:5889                      TCPIP_CONFIG_AUTOIP_ST2.1:
    4596   00:5889                          ; nz, discard
    4597   00:5889                          RECEIVE_DATA
    4597   00:5889  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4598   00:588C  05                      dec b
    4599   00:588D  20 EE                   jr  nz,TCPIP_CONFIG_AUTOIP_ST2
    4600   00:588F                      
    4601   00:588F                          ; now just get the 1 byte, configuration, should go to C
    4602   00:588F                      TCPIP_CONFIG_AUTOIP_CONF_ST1:
    4603   00:588F                          CHECK_DATA
    4603   00:588F  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4603   00:5892  CB 47             >     bit 0,a
    4604   00:5894  20 05                   jr  nz,TCPIP_CONFIG_AUTOIP_CONF_ST1.1
    4605   00:5896  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4606   00:5899  18 F4                   jr  TCPIP_CONFIG_AUTOIP_CONF_ST1
    4607   00:589B                      TCPIP_CONFIG_AUTOIP_CONF_ST1.1:
    4608   00:589B                          ; nz, get it
    4609   00:589B                          RECEIVE_DATA
    4609   00:589B  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4610   00:589E  4F                      ld  c,a
    4611   00:589F                          ; done
    4612   00:589F  AF                      xor a
    4613   00:58A0  C9                      ret
    4614   00:58A1                      
    4615   00:58A1                      ;=========================
    4616   00:58A1                      ;===  TCPIP_CONFIG_IP  ===
    4617   00:58A1                      ;=========================
    4618   00:58A1                      ;Manually configure an IP address.
    4619   00:58A1                      ;
    4620   00:58A1                      ;Input:  A = 26
    4621   00:58A1                      ;        B = Index of address to set:
    4622   00:58A1                      ;            1: Local IP address
    4623   00:58A1                      ;            2: Peer IP address
    4624   00:58A1                      ;            3: Subnet mask
    4625   00:58A1                      ;            4: Default gateway
    4626   00:58A1                      ;            5: Primary DNS server IP address
    4627   00:58A1                      ;            6: Secondary DNS server IP address
    4628   00:58A1                      ;        L.H.E.D = Address value
    4629   00:58A1                      ;Output: A = Error code
    4630   00:58A1                      TCPIP_CONFIG_IP:
    4631   00:58A1                          SEND_DATA                       ; Send the command
    4631   00:58A1  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4632   00:58A4  AF                      xor a
    4633   00:58A5                          SEND_DATA                       ; Send the command size msb
    4633   00:58A5  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4634   00:58A8  3E 05                   ld  a,5
    4635   00:58AA                          SEND_DATA                       ; Send the command size lsb
    4635   00:58AA  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4636   00:58AD  78                      ld  a,b
    4637   00:58AE                          SEND_DATA                       ; Send the address to set
    4637   00:58AE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4638   00:58B1  7D                      ld  a,l
    4639   00:58B2                          SEND_DATA                       ; Send the IP first byte
    4639   00:58B2  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4640   00:58B5  7C                      ld  a,h
    4641   00:58B6                          SEND_DATA                       ; Send the IP second byte
    4641   00:58B6  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4642   00:58B9  7B                      ld  a,e
    4643   00:58BA                          SEND_DATA                       ; Send the IP third byte
    4643   00:58BA  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4644   00:58BD  7A                      ld  a,d
    4645   00:58BE                          SEND_DATA                       ; Send the IP fourth byte
    4645   00:58BE  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    4646   00:58C1                      
    4647   00:58C1                          ; Now wait up to 180 ticks to get response
    4648   00:58C1  21 B4 00                ld  hl,180
    4649   00:58C4  CD AC 59                call    SETCOUNTER
    4650   00:58C7                      TCPIP_CONFIG_IP_ST1:
    4651   00:58C7                          CHECK_DATA
    4651   00:58C7  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4651   00:58CA  CB 47             >     bit 0,a
    4652   00:58CC  20 05                   jr  nz,TCPIP_CONFIG_IP_ST1.1
    4653   00:58CE  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4654   00:58D1  18 F4                   jr  TCPIP_CONFIG_IP_ST1
    4655   00:58D3                      TCPIP_CONFIG_IP_ST1.1:
    4656   00:58D3                          ; nz, check the data
    4657   00:58D3                          RECEIVE_DATA
    4657   00:58D3  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4658   00:58D6  FE 1A                   cp  26                          ; Is response of our command?
    4659   00:58D8  20 ED                   jr  nz,TCPIP_CONFIG_IP_ST1
    4660   00:58DA                          ; now get return code, and that is it
    4661   00:58DA                      TCPIP_CONFIG_IP_RC:
    4662   00:58DA                          CHECK_DATA
    4662   00:58DA  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    4662   00:58DD  CB 47             >     bit 0,a
    4663   00:58DF  20 05                   jr  nz,TCPIP_CONFIG_IP_RC.1
    4664   00:58E1  CD 7C 4D                call    TCPIP_GENERIC_CHECK_TIME_OUT
    4665   00:58E4  18 F4                   jr  TCPIP_CONFIG_IP_RC
    4666   00:58E6                      TCPIP_CONFIG_IP_RC.1:
    4667   00:58E6                          ; nz, discard
    4668   00:58E6                          RECEIVE_DATA
    4668   00:58E6  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    4669   00:58E9  C9                      ret                             ; done
    4670   00:58EA                      
    4671   00:58EA                      ;==========================
    4672   00:58EA                      ;===  TCPIP_CONFIG_TTL  ===
    4673   00:58EA                      ;==========================
    4674   00:58EA                      ;Get/set the value of TTL and TOS for outgoing datagrams.
    4675   00:58EA                      ;
    4676   00:58EA                      ;Input:  A = 27
    4677   00:58EA                      ;        B = 0: Get current values (just return 255 for TTL and 0 for TOS
    4678   00:58EA                      ;               as ESP do not expose or allow configurations of it)
    4679   00:58EA                      ;            1: Set values
    4680   00:58EA                      ;        D = New value for TTL (only if B=1)
    4681   00:58EA                      ;        E = New value for ToS (only if B=1)
    4682   00:58EA                      ;Output: A = Error code
    4683   00:58EA                      ;        D = Value of TTL after the routine execution
    4684   00:58EA                      ;        E = Value of ToS after the routine execution
    4685   00:58EA                      TCPIP_CONFIG_TTL:
    4686   00:58EA  78                      ld  a,b
    4687   00:58EB  E6 FE                   and %11111110
    4688   00:58ED  B7                      or  a
    4689   00:58EE  3E 04                   ld  a,ERR_INV_PARAM
    4690   00:58F0  C0                      ret nz
    4691   00:58F1  78                      ld  a,b
    4692   00:58F2  B7                      or  a
    4693   00:58F3                          ; Cant set, so NOT IMP
    4694   00:58F3  3E 01                   ld  a,ERR_NOT_IMP
    4695   00:58F5  C0                      ret nz                          ; if not get, not implemented
    4696   00:58F6                          ; get, so just return D = #FF, A = OK = 0 and E = 0
    4697   00:58F6  AF                      xor a
    4698   00:58F7  1E 00                   ld  e,0
    4699   00:58F9  16 FF                   ld  d,#FF
    4700   00:58FB  C9                      ret
    4701   00:58FC                      
    4702   00:58FC                      ;===========================
    4703   00:58FC                      ;===  TCPIP_CONFIG_PING  ===
    4704   00:58FC                      ;===========================
    4705   00:58FC                      ;Get/set the automatic PING reply flag.
    4706   00:58FC                      ;
    4707   00:58FC                      ;Input:  A = 28
    4708   00:58FC                      ;        B = 0: Get current flag value
    4709   00:58FC                      ;            1: Set flag value (ERR_NOT_IMP)
    4710   00:58FC                      ;        C = New flag value (only if B=1):
    4711   00:58FC                      ;            0: Off
    4712   00:58FC                      ;            1: On
    4713   00:58FC                      ;Output: A = Error code
    4714   00:58FC                      ;        C = Flag value after the routine execution
    4715   00:58FC                      TCPIP_CONFIG_PING:
    4716   00:58FC  78                      ld  a,b
    4717   00:58FD  E6 FE                   and %11111110
    4718   00:58FF  B7                      or  a
    4719   00:5900  3E 04                   ld  a,ERR_INV_PARAM
    4720   00:5902  C0                      ret nz
    4721   00:5903  78                      ld  a,b
    4722   00:5904  B7                      or  a
    4723   00:5905                          ; Cant set, so NOT IMP
    4724   00:5905  3E 01                   ld  a,ERR_NOT_IMP
    4725   00:5907  C0                      ret nz                          ; if not get, not implemented
    4726   00:5908                          ; get, so just return C = 1, A = OK = 0
    4727   00:5908  AF                      xor a
    4728   00:5909  0E 01                   ld  c,1
    4729   00:590B  C9                      ret
    4730   00:590C                      
    4731   00:590C                      ;============================
    4732   00:590C                      ;===  Auxiliary routines  ===
    4733   00:590C                      ;============================
    4734   00:590C                      
    4735   00:590C                      ;--- Get slot connected on page 1
    4736   00:590C                      ;    Input:  -
    4737   00:590C                      ;    Output: A = Slot number
    4738   00:590C                      ;    Modifies: AF, HL, E, BC
    4739   00:590C                      
    4740   00:590C                      GETSLT:
    4741   00:590C  DB A8                   in  a,(#A8)
    4742   00:590E  0F                      rrca
    4743   00:590F  0F                      rrca
    4744   00:5910  E6 03                   and 3
    4745   00:5912  4F                      ld  c,a                         ;C = Slot
    4746   00:5913  06 00                   ld  b,0
    4747   00:5915  21 C1 FC                ld  hl,EXPTBL
    4748   00:5918  09                      add hl,bc
    4749   00:5919  7E                      ld  a,(hl)
    4750   00:591A  E6 80                   and #80
    4751   00:591C  B1                      or  c
    4752   00:591D  4F                      ld  c,a
    4753   00:591E  23                      inc hl
    4754   00:591F  23                      inc hl
    4755   00:5920  23                      inc hl
    4756   00:5921  23                      inc hl
    4757   00:5922  7E                      ld  a,(hl)
    4758   00:5923  E6 0C                   and #0C
    4759   00:5925  B1                      or  c
    4760   00:5926  CB 7F                   bit 7,a
    4761   00:5928  C0                      ret nz
    4762   00:5929  E6 03                   and %11
    4763   00:592B  C9                      ret
    4764   00:592C                      
    4765   00:592C                      ;--- Get slot connected on page 1 and test if work area has been created, if not, create it
    4766   00:592C                      ;    Input:  -
    4767   00:592C                      ;    Output: A = Slot number
    4768   00:592C                      ;    Modifies: AF, HL, E, BC
    4769   00:592C                      
    4770   00:592C                      GETSLTT:
    4771   00:592C  DB A8                   in  a,(#A8)
    4772   00:592E  0F                      rrca
    4773   00:592F  0F                      rrca
    4774   00:5930  E6 03                   and 3
    4775   00:5932  4F                      ld  c,a                         ;C = Slot
    4776   00:5933  06 00                   ld  b,0
    4777   00:5935  21 C1 FC                ld  hl,EXPTBL
    4778   00:5938  09                      add hl,bc
    4779   00:5939  7E                      ld  a,(hl)
    4780   00:593A  E6 80                   and #80
    4781   00:593C  B1                      or  c
    4782   00:593D  4F                      ld  c,a
    4783   00:593E  23                      inc hl
    4784   00:593F  23                      inc hl
    4785   00:5940  23                      inc hl
    4786   00:5941  23                      inc hl
    4787   00:5942  7E                      ld  a,(hl)
    4788   00:5943  E6 0C                   and #0C
    4789   00:5945  B1                      or  c
    4790   00:5946  CB 7F                   bit 7,a
    4791   00:5948  C2 4D 59                jp  nz,GETSLTT1
    4792   00:594B  E6 03                   and %11
    4793   00:594D                      GETSLTT1:
    4794   00:594D  F5                      push    af
    4795   00:594E  C5                      push    bc
    4796   00:594F  E5                      push    hl
    4797   00:5950  CD 65 59                call    GETWRK
    4798   00:5953  01 05 00                ld  bc,5
    4799   00:5956  09                      add hl,bc
    4800   00:5957  7E                      ld  a,(hl)
    4801   00:5958  B7                      or  a
    4802   00:5959  C2 61 59                jp  nz,GETSLTTRET
    4803   00:595C  3C                      inc a
    4804   00:595D  77                      ld  (hl),a
    4805   00:595E  CD E4 41                call    HIMEM_ALLOC
    4806   00:5961                      GETSLTTRET:
    4807   00:5961  E1                      pop hl
    4808   00:5962  C1                      pop bc
    4809   00:5963  F1                      pop af
    4810   00:5964  C9                      ret
    4811   00:5965                      
    4812   00:5965                      ;--- Obtain slot work area (8 bytes) on SLTWRK
    4813   00:5965                      ;    Input:  A  = Slot number
    4814   00:5965                      ;    Output: HL = Work area address
    4815   00:5965                      ;    Modifies: AF, BC
    4816   00:5965                      
    4817   00:5965                      GETWRK:
    4818   00:5965  47                      ld  b,a
    4819   00:5966  0F                      rrca
    4820   00:5967  0F                      rrca
    4821   00:5968  0F                      rrca
    4822   00:5969  E6 60                   and %01100000
    4823   00:596B  4F                      ld  c,a                         ;C = Slot * 32
    4824   00:596C  78                      ld  a,b
    4825   00:596D  07                      rlca
    4826   00:596E  E6 18                   and %00011000                   ;A = Subslot * 8
    4827   00:5970  B1                      or  c
    4828   00:5971  4F                      ld  c,a
    4829   00:5972  06 00                   ld  b,0
    4830   00:5974  21 09 FD                ld  hl,SLTWRK
    4831   00:5977  09                      add hl,bc
    4832   00:5978  C9                      ret
    4833   00:5979                      
    4834   00:5979                      ;--- Obtain the address where our memory area address in high memory is stored
    4835   00:5979                      ;    Input:  A  = Slot number
    4836   00:5979                      ;    Output: HL = High memory area address
    4837   00:5979                      ;    Modifies: AF, BC
    4838   00:5979                      
    4839   00:5979                      GETMEMPOINTERADDR:
    4840   00:5979  47                      ld  b,a
    4841   00:597A  0F                      rrca
    4842   00:597B  0F                      rrca
    4843   00:597C  0F                      rrca
    4844   00:597D  E6 60                   and %01100000
    4845   00:597F  4F                      ld  c,a                         ; C = Slot * 32
    4846   00:5980  78                      ld  a,b
    4847   00:5981  07                      rlca
    4848   00:5982  E6 18                   and %00011000                   ; A = Subslot * 8
    4849   00:5984  B1                      or  c
    4850   00:5985  4F                      ld  c,a
    4851   00:5986  06 00                   ld  b,0
    4852   00:5988  D2 8C 59                jp  nc,GETMEM_1
    4853   00:598B  04                      inc b
    4854   00:598C                      GETMEM_1:
    4855   00:598C  21 09 FD                ld  hl,SLTWRK
    4856   00:598F  09                      add hl,bc
    4857   00:5990  01 05 00                ld  bc,5
    4858   00:5993  09                      add hl,bc
    4859   00:5994  C9                      ret
    4860   00:5995                      
    4861   00:5995                      ;--- Obtain the address where our memory area address in high memory is stored
    4862   00:5995                      ;    Input:  A  = Slot number
    4863   00:5995                      ;    Output: HL = High memory area address
    4864   00:5995                      ;    Modifies: AF, BC
    4865   00:5995                      
    4866   00:5995                      GETMEMPOINTER:
    4867   00:5995  CD 79 59                call    GETMEMPOINTERADDR
    4868   00:5998  4E                      ld  c,(hl)
    4869   00:5999  23                      inc hl
    4870   00:599A  66                      ld  h,(hl)
    4871   00:599B  69                      ld  l,c
    4872   00:599C  C9                      ret
    4873   00:599D                      
    4874   00:599D                      ;--- Obtain our HTIM_I driven counter value in high memory
    4875   00:599D                      ;    Input:  none
    4876   00:599D                      ;    Output: HL = counter value
    4877   00:599D                      ;    Modifies: AF, HL, DE, BC
    4878   00:599D                      
    4879   00:599D                      GETCOUNTER:
    4880   00:599D  CD 0C 59                call    GETSLT
    4881   00:59A0                          ; Slot in A, now get the address of our counter
    4882   00:59A0  CD 95 59                call    GETMEMPOINTER
    4883   00:59A3                          ; HL has the address of our memory area, counter is 5 bytes after start
    4884   00:59A3  11 05 00                ld  de,MEMORY_COUNTER_OFFSET
    4885   00:59A6  19                      add hl,de
    4886   00:59A7                          ; Ok, this is where our counter is so get it
    4887   00:59A7  5E                      ld  e,(hl)
    4888   00:59A8  23                      inc hl
    4889   00:59A9  56                      ld  d,(hl)
    4890   00:59AA                          ; DE has the counter value
    4891   00:59AA  EB                      ex  de,hl                       ; Counter value in HL
    4892   00:59AB  C9                      ret
    4893   00:59AC                      
    4894   00:59AC                      ;--- Set our HTIM_I driven counter value in high memory
    4895   00:59AC                      ;    Input:  HL = new counter value
    4896   00:59AC                      ;    Output: none
    4897   00:59AC                      ;    Modifies: AF, HL, DE, BC
    4898   00:59AC                      
    4899   00:59AC                      SETCOUNTER:
    4900   00:59AC  E5                      push    hl                      ; Save parameter
    4901   00:59AD  CD 0C 59                call    GETSLT
    4902   00:59B0                          ; Slot in A, now get the address of our counter
    4903   00:59B0  CD 95 59                call    GETMEMPOINTER
    4904   00:59B3                          ; HL has the address of our memory area, counter is 5 bytes after start
    4905   00:59B3  11 05 00                ld  de,MEMORY_COUNTER_OFFSET
    4906   00:59B6  19                      add hl,de
    4907   00:59B7                          ; Ok, this is where our counter is so get it
    4908   00:59B7                          ; HL has the address of counter
    4909   00:59B7  D1                      pop de                          ; Restore parameter in DE
    4910   00:59B8  73                      ld  (hl),e
    4911   00:59B9  23                      inc hl
    4912   00:59BA  72                      ld  (hl),d
    4913   00:59BB  C9                      ret
    4914   00:59BC                      
    4915   00:59BC                      ;--- Obtain a one byte param saved in high memory
    4916   00:59BC                      ;    Input:  none
    4917   00:59BC                      ;    Output: A = param
    4918   00:59BC                      ;    Modifies: AF
    4919   00:59BC                      
    4920   00:59BC                      GETBYTE:
    4921   00:59BC  C5                      push    bc
    4922   00:59BD  D5                      push    de
    4923   00:59BE  E5                      push    hl
    4924   00:59BF  CD 0C 59                call    GETSLT
    4925   00:59C2                          ; Slot in A, now get the address of our counter
    4926   00:59C2  CD 95 59                call    GETMEMPOINTER
    4927   00:59C5                          ; HL has the address of our memory area, param is 7 bytes after start
    4928   00:59C5  11 07 00                ld  de,MEMORY_SB_VAR_OFFSET
    4929   00:59C8  19                      add hl,de
    4930   00:59C9                          ; Ok, this is where our param is so get it
    4931   00:59C9  7E                      ld  a,(hl)
    4932   00:59CA  E1                      pop hl
    4933   00:59CB  D1                      pop de
    4934   00:59CC  C1                      pop bc
    4935   00:59CD  C9                      ret
    4936   00:59CE                      
    4937   00:59CE                      ;--- Set a one byte param value in high memory
    4938   00:59CE                      ;    Input:  A = new counter value
    4939   00:59CE                      ;    Output: none
    4940   00:59CE                      ;    Modifies: AF
    4941   00:59CE                      
    4942   00:59CE                      SETBYTE:
    4943   00:59CE  C5                      push    bc
    4944   00:59CF  D5                      push    de
    4945   00:59D0  E5                      push    hl
    4946   00:59D1  F5                      push    af                      ; Save parameter
    4947   00:59D2  CD 0C 59                call    GETSLT
    4948   00:59D5                          ; Slot in A, now get the address
    4949   00:59D5  CD 95 59                call    GETMEMPOINTER
    4950   00:59D8                          ; HL has the address of our memory area, byte param is 7 bytes after start
    4951   00:59D8  11 07 00                ld  de,MEMORY_SB_VAR_OFFSET
    4952   00:59DB  19                      add hl,de
    4953   00:59DC                          ; HL has the address of param
    4954   00:59DC  F1                      pop af                          ; Restore parameter
    4955   00:59DD  77                      ld  (hl),a
    4956   00:59DE  E1                      pop hl
    4957   00:59DF  D1                      pop de
    4958   00:59E0  C1                      pop bc
    4959   00:59E1  C9                      ret
    4960   00:59E2                      
    4961   00:59E2                      ;--- Obtain a two bytes param saved in high memory
    4962   00:59E2                      ;    Input:  none
    4963   00:59E2                      ;    Output: HL = param
    4964   00:59E2                      ;    Modifies: AF, HL
    4965   00:59E2                      
    4966   00:59E2                      GETWORD:
    4967   00:59E2  C5                      push    bc
    4968   00:59E3  D5                      push    de
    4969   00:59E4  CD 0C 59                call    GETSLT
    4970   00:59E7                          ; Slot in A, now get the address of our counter
    4971   00:59E7  CD 95 59                call    GETMEMPOINTER
    4972   00:59EA                          ; HL has the address of our memory area, param is 7 bytes after start
    4973   00:59EA  11 0B 00                ld  de,MEMORY_DB_VAR_OFFSET
    4974   00:59ED  19                      add hl,de
    4975   00:59EE                          ; Ok, this is where our param is so get it
    4976   00:59EE  5E                      ld  e,(hl)
    4977   00:59EF  23                      inc hl
    4978   00:59F0  56                      ld  d,(hl)
    4979   00:59F1  EB                      ex  de,hl                       ; Return in HL
    4980   00:59F2  D1                      pop de
    4981   00:59F3  C1                      pop bc
    4982   00:59F4  C9                      ret
    4983   00:59F5                      
    4984   00:59F5                      ;--- Set a two bytes param value in high memory
    4985   00:59F5                      ;    Input:  HL = new counter value
    4986   00:59F5                      ;    Output: none
    4987   00:59F5                      ;    Modifies: AF
    4988   00:59F5                      
    4989   00:59F5                      SETWORD:
    4990   00:59F5  C5                      push    bc
    4991   00:59F6  D5                      push    de
    4992   00:59F7  E5                      push    hl
    4993   00:59F8  CD 0C 59                call    GETSLT
    4994   00:59FB                          ; Slot in A, now get the address
    4995   00:59FB  CD 95 59                call    GETMEMPOINTER
    4996   00:59FE                          ; HL has the address of our memory area, byte param is 7 bytes after start
    4997   00:59FE  11 0B 00                ld  de,MEMORY_DB_VAR_OFFSET
    4998   00:5A01  19                      add hl,de
    4999   00:5A02                          ; HL has the address of param
    5000   00:5A02  D1                      pop de                          ; Restore parameter in DE
    5001   00:5A03  73                      ld  (hl),e
    5002   00:5A04  23                      inc hl
    5003   00:5A05  72                      ld  (hl),d
    5004   00:5A06  EB                      ex  de,hl                       ; Restore HL original value
    5005   00:5A07  D1                      pop de
    5006   00:5A08  C1                      pop bc
    5007   00:5A09  C9                      ret
    5008   00:5A0A                      
    5009   00:5A0A                      ;--- Restores BC / DE / HL copy saved in high memory
    5010   00:5A0A                      ;    Input:  none
    5011   00:5A0A                      ;    Output: BC / DE / HL
    5012   00:5A0A                      ;    Modifies: AF
    5013   00:5A0A                      
    5014   00:5A0A                      REGRESTORE:
    5015   00:5A0A  CD 0C 59                call    GETSLT
    5016   00:5A0D                          ; Slot in A, now get the address of our counter
    5017   00:5A0D  CD 95 59                call    GETMEMPOINTER
    5018   00:5A10                          ; HL has the address of our memory area, param is 7 bytes after start
    5019   00:5A10  11 0D 00                ld  de,MEMORY_REGBACKUP_OFFSET
    5020   00:5A13  19                      add hl,de
    5021   00:5A14                          ; Ok, this is where our param is so get it
    5022   00:5A14  4E                      ld  c,(hl)
    5023   00:5A15  23                      inc hl
    5024   00:5A16  46                      ld  b,(hl)
    5025   00:5A17  23                      inc hl
    5026   00:5A18  5E                      ld  e,(hl)
    5027   00:5A19  23                      inc hl
    5028   00:5A1A  56                      ld  d,(hl)
    5029   00:5A1B  23                      inc hl
    5030   00:5A1C  7E                      ld  a,(hl)
    5031   00:5A1D  23                      inc hl
    5032   00:5A1E  66                      ld  h,(hl)
    5033   00:5A1F  6F                      ld  l,a
    5034   00:5A20  C9                      ret
    5035   00:5A21                      
    5036   00:5A21                      ;--- Backups BC / DE /HL in high memory
    5037   00:5A21                      ;    Input:  BC / DE / HL
    5038   00:5A21                      ;    Output: none
    5039   00:5A21                      ;    Modifies: AF
    5040   00:5A21                      
    5041   00:5A21                      REGBACKUP:
    5042   00:5A21  E5                      push    hl
    5043   00:5A22  D5                      push    de
    5044   00:5A23  C5                      push    bc
    5045   00:5A24  CD 0C 59                call    GETSLT
    5046   00:5A27                          ; Slot in A, now get the address
    5047   00:5A27  CD 95 59                call    GETMEMPOINTER
    5048   00:5A2A                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5049   00:5A2A  11 0D 00                ld  de,MEMORY_REGBACKUP_OFFSET
    5050   00:5A2D  19                      add hl,de
    5051   00:5A2E                          ; HL has the address of param
    5052   00:5A2E  C1                      pop bc                          ; Restore BC
    5053   00:5A2F  71                      ld  (hl),c
    5054   00:5A30  23                      inc hl
    5055   00:5A31  70                      ld  (hl),b
    5056   00:5A32  23                      inc hl
    5057   00:5A33  D1                      pop de                          ; Restore DE
    5058   00:5A34  73                      ld  (hl),e
    5059   00:5A35  23                      inc hl
    5060   00:5A36  72                      ld  (hl),d
    5061   00:5A37  23                      inc hl
    5062   00:5A38  E3                      ex (sp),hl                      ; backup the address and get HL value
    5063   00:5A39  7D                      ld  a,l
    5064   00:5A3A  E3                      ex (sp),hl                      ; return it to the stack and get back the pointer
    5065   00:5A3B  77                      ld  (hl),a                      ; save l
    5066   00:5A3C  23                      inc hl
    5067   00:5A3D  E3                      ex (sp),hl                      ; backup the address and get HL value
    5068   00:5A3E  7C                      ld  a,h
    5069   00:5A3F  E3                      ex (sp),hl                      ; return it to the stack and get back the pointer
    5070   00:5A40  77                      ld  (hl),a                      ; save h
    5071   00:5A41  E1                      pop hl                          ; Restore HL original value
    5072   00:5A42  C9                      ret
    5073   00:5A43                      
    5074   00:5A43                      ;--- Restores BC copy saved in high memory
    5075   00:5A43                      ;    Input:  none
    5076   00:5A43                      ;    Output: BC
    5077   00:5A43                      ;    Modifies: AF
    5078   00:5A43                      
    5079   00:5A43                      BCRESTORE:
    5080   00:5A43  E5                      push    hl
    5081   00:5A44  D5                      push    de
    5082   00:5A45  CD 0C 59                call    GETSLT
    5083   00:5A48                          ; Slot in A, now get the address of our counter
    5084   00:5A48  CD 95 59                call    GETMEMPOINTER
    5085   00:5A4B                          ; HL has the address of our memory area, param is 7 bytes after start
    5086   00:5A4B  11 0D 00                ld  de,MEMORY_BCBACKUP_OFFSET
    5087   00:5A4E  19                      add hl,de
    5088   00:5A4F                          ; Ok, this is where our param is so get it
    5089   00:5A4F  4E                      ld  c,(hl)
    5090   00:5A50  23                      inc hl
    5091   00:5A51  46                      ld  b,(hl)
    5092   00:5A52  D1                      pop de
    5093   00:5A53  E1                      pop hl
    5094   00:5A54  C9                      ret
    5095   00:5A55                      
    5096   00:5A55                      ;--- Backups BC in high memory
    5097   00:5A55                      ;    Input:  BC
    5098   00:5A55                      ;    Output: none
    5099   00:5A55                      ;    Modifies: AF
    5100   00:5A55                      
    5101   00:5A55                      BCBACKUP:
    5102   00:5A55  D5                      push    de
    5103   00:5A56  E5                      push    hl
    5104   00:5A57  C5                      push    bc
    5105   00:5A58  CD 0C 59                call    GETSLT
    5106   00:5A5B                          ; Slot in A, now get the address
    5107   00:5A5B  CD 95 59                call    GETMEMPOINTER
    5108   00:5A5E                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5109   00:5A5E  11 0D 00                ld  de,MEMORY_BCBACKUP_OFFSET
    5110   00:5A61  19                      add hl,de
    5111   00:5A62                          ; HL has the address of param
    5112   00:5A62  C1                      pop bc                          ; Restore BC
    5113   00:5A63  71                      ld  (hl),c
    5114   00:5A64  23                      inc hl
    5115   00:5A65  70                      ld  (hl),b
    5116   00:5A66  E1                      pop hl                          ; Restore HL original value
    5117   00:5A67  D1                      pop de                          ; Restore DE
    5118   00:5A68  C9                      ret
    5119   00:5A69                      
    5120   00:5A69                      ;--- Restores HL copy saved in high memory
    5121   00:5A69                      ;    Input:  none
    5122   00:5A69                      ;    Output: HL
    5123   00:5A69                      ;    Modifies: AF
    5124   00:5A69                      
    5125   00:5A69                      HLRESTORE:
    5126   00:5A69  C5                      push    bc
    5127   00:5A6A  D5                      push    de
    5128   00:5A6B  CD 0C 59                call    GETSLT
    5129   00:5A6E                          ; Slot in A, now get the address of our counter
    5130   00:5A6E  CD 95 59                call    GETMEMPOINTER
    5131   00:5A71                          ; HL has the address of our memory area, param is 7 bytes after start
    5132   00:5A71  11 11 00                ld  de,MEMORY_HLBACKUP_OFFSET
    5133   00:5A74  19                      add hl,de
    5134   00:5A75                          ; Ok, this is where our param is so get it
    5135   00:5A75  5E                      ld  e,(hl)
    5136   00:5A76  23                      inc hl
    5137   00:5A77  56                      ld  d,(hl)
    5138   00:5A78  EB                      ex  de,hl
    5139   00:5A79  D1                      pop de
    5140   00:5A7A  C1                      pop bc
    5141   00:5A7B  C9                      ret
    5142   00:5A7C                      
    5143   00:5A7C                      ;--- Backups HL in high memory
    5144   00:5A7C                      ;    Input:  HL
    5145   00:5A7C                      ;    Output: none
    5146   00:5A7C                      ;    Modifies: AF
    5147   00:5A7C                      
    5148   00:5A7C                      HLBACKUP:
    5149   00:5A7C  D5                      push    de
    5150   00:5A7D  C5                      push    bc
    5151   00:5A7E  E5                      push    hl
    5152   00:5A7F  CD 0C 59                call    GETSLT
    5153   00:5A82                          ; Slot in A, now get the address
    5154   00:5A82  CD 95 59                call    GETMEMPOINTER
    5155   00:5A85                          ; HL has the address of our memory area, byte param is 7 bytes after start
    5156   00:5A85  11 11 00                ld  de,MEMORY_HLBACKUP_OFFSET
    5157   00:5A88  19                      add hl,de
    5158   00:5A89                          ; HL has the address of param
    5159   00:5A89  D1                      pop de                          ; Restore HL in de
    5160   00:5A8A  73                      ld  (hl),e
    5161   00:5A8B  23                      inc hl
    5162   00:5A8C  72                      ld  (hl),d
    5163   00:5A8D  EB                      ex  de,hl                       ; Restore HL
    5164   00:5A8E  C1                      pop bc                          ; Restore BC
    5165   00:5A8F  D1                      pop de                          ; Restore DE
    5166   00:5A90  C9                      ret
    5167   00:5A91                      
    5168   00:5A91                      ;--- Obtain if DNS is ready saved in high memory
    5169   00:5A91                      ;    Input:  none
    5170   00:5A91                      ;    Output: A = DNS ready value
    5171   00:5A91                      ;    Modifies: AF
    5172   00:5A91                      
    5173   00:5A91                      GETDNSREADY:
    5174   00:5A91  C5                      push    bc
    5175   00:5A92  D5                      push    de
    5176   00:5A93  E5                      push    hl
    5177   00:5A94  CD 0C 59                call    GETSLT
    5178   00:5A97                          ; Slot in A, now get the address
    5179   00:5A97  CD 95 59                call    GETMEMPOINTER
    5180   00:5A9A                          ; HL has the address of our memory area, DNS ready is 8 bytes after start
    5181   00:5A9A  11 08 00                ld  de,MEMORY_DNS_READY_OFFSET
    5182   00:5A9D  19                      add hl,de
    5183   00:5A9E                          ; Ok, get it
    5184   00:5A9E  7E                      ld  a,(hl)
    5185   00:5A9F  E1                      pop hl
    5186   00:5AA0  D1                      pop de
    5187   00:5AA1  C1                      pop bc
    5188   00:5AA2  C9                      ret
    5189   00:5AA3                      
    5190   00:5AA3                      ;--- Set DNS redy in high memory
    5191   00:5AA3                      ;    Input:  A = new value
    5192   00:5AA3                      ;    Output: none
    5193   00:5AA3                      ;    Modifies: AF
    5194   00:5AA3                      
    5195   00:5AA3                      SETDNSREADY:
    5196   00:5AA3  C5                      push    bc
    5197   00:5AA4  D5                      push    de
    5198   00:5AA5  E5                      push    hl
    5199   00:5AA6  F5                      push    af                      ; Save parameter
    5200   00:5AA7  CD 0C 59                call    GETSLT
    5201   00:5AAA                          ; Slot in A, now get the address
    5202   00:5AAA  CD 95 59                call    GETMEMPOINTER
    5203   00:5AAD                          ; HL has the address of our memory area, DNS ready is 8 bytes after start
    5204   00:5AAD  11 08 00                ld  de,MEMORY_DNS_READY_OFFSET
    5205   00:5AB0  19                      add hl,de
    5206   00:5AB1                          ; HL has the address of DNS ready
    5207   00:5AB1  F1                      pop af                          ; Restore parameter
    5208   00:5AB2  77                      ld  (hl),a
    5209   00:5AB3  E1                      pop hl
    5210   00:5AB4  D1                      pop de
    5211   00:5AB5  C1                      pop bc
    5212   00:5AB6  C9                      ret
    5213   00:5AB7                      
    5214   00:5AB7                      ;--- Obtain DNS result saved in high memory
    5215   00:5AB7                      ;    Input:  none
    5216   00:5AB7                      ;    Output: HL DE = DNS result
    5217   00:5AB7                      ;    Modifies: AF
    5218   00:5AB7                      
    5219   00:5AB7                      GETDNSRESULT:
    5220   00:5AB7  C5                      push    bc
    5221   00:5AB8  CD 0C 59                call    GETSLT
    5222   00:5ABB                          ; Slot in A, now get the address
    5223   00:5ABB  CD 95 59                call    GETMEMPOINTER
    5224   00:5ABE                          ; HL has the address of our memory area, DNS result is 9 bytes after start
    5225   00:5ABE  11 09 00                ld  de,MEMORY_DNS_RES_OFFSET
    5226   00:5AC1  19                      add hl,de
    5227   00:5AC2                          ; Ok, get it, first bytes are hl
    5228   00:5AC2  5E                      ld  e,(hl)
    5229   00:5AC3  23                      inc hl
    5230   00:5AC4  56                      ld  d,(hl)
    5231   00:5AC5  D5                      push    de                      ; for now, save in stack, so we can restore to HL later
    5232   00:5AC6  23                      inc hl
    5233   00:5AC7  5E                      ld  e,(hl)
    5234   00:5AC8  23                      inc hl
    5235   00:5AC9  56                      ld  d,(hl)
    5236   00:5ACA  E1                      pop hl                          ; and now restore HL value from stack
    5237   00:5ACB  C1                      pop bc
    5238   00:5ACC  C9                      ret
    5239   00:5ACD                      
    5240   00:5ACD                      ;--- Set DNS result in high memory
    5241   00:5ACD                      ;    Input:  HL DE = new value
    5242   00:5ACD                      ;    Output: none
    5243   00:5ACD                      ;    Modifies: AF
    5244   00:5ACD                      
    5245   00:5ACD                      SETDNSRESULT:
    5246   00:5ACD  C5                      push    bc
    5247   00:5ACE  D5                      push    de
    5248   00:5ACF  E5                      push    hl
    5249   00:5AD0  CD 0C 59                call    GETSLT
    5250   00:5AD3                          ; Slot in A, now get the address
    5251   00:5AD3  CD 95 59                call    GETMEMPOINTER
    5252   00:5AD6                          ; HL has the address of our memory area, DNS result is 9 bytes after start
    5253   00:5AD6  11 09 00                ld  de,MEMORY_DNS_RES_OFFSET
    5254   00:5AD9  19                      add hl,de
    5255   00:5ADA                          ; HL has the address of DNS result
    5256   00:5ADA  C1                      pop bc                          ; Restore parameter HL in BC
    5257   00:5ADB  71                      ld  (hl),c
    5258   00:5ADC  23                      inc hl
    5259   00:5ADD  70                      ld  (hl),b
    5260   00:5ADE  D1                      pop de                          ; Restore parameter DE in DE
    5261   00:5ADF  23                      inc hl
    5262   00:5AE0  73                      ld  (hl),e
    5263   00:5AE1  23                      inc hl
    5264   00:5AE2  72                      ld  (hl),d
    5265   00:5AE3  69                      ld  l,c
    5266   00:5AE4  60                      ld  h,b                         ; And HL is restored
    5267   00:5AE5  C1                      pop bc                          ; Restore BC
    5268   00:5AE6  C9                      ret
    5269   00:5AE7                      
    5270   00:5AE7                      ;--- Convert a character to upper-case if it is a lower-case letter
    5271   00:5AE7                      TOUPPER:
    5272   00:5AE7  FE 61                   cp  "a"
    5273   00:5AE9  D8                      ret c
    5274   00:5AEA  FE 7B                   cp  "z"+1
    5275   00:5AEC  D0                      ret nc
    5276   00:5AED  E6 DF                   and #DF
    5277   00:5AEF  C9                      ret
    5278   00:5AF0                      
    5279   00:5AF0                      ;*********************************************
    5280   00:5AF0                      ;***       WAIT_RESPONSE_FROM_ESP          ***
    5281   00:5AF0                      ;*** Will wait ESP to send a response,     ***
    5282   00:5AF0                      ;*** discarding all data until it is found.***
    5283   00:5AF0                      ;***                                       ***
    5284   00:5AF0                      ;*** Inputs:                               ***
    5285   00:5AF0                      ;*** HL - Expected response string         ***
    5286   00:5AF0                      ;*** A - Response Size                     ***
    5287   00:5AF0                      ;*** DE - TimeOut in ticks                 ***
    5288   00:5AF0                      ;***                                       ***
    5289   00:5AF0                      ;*** Output:                               ***
    5290   00:5AF0                      ;*** A - 0 if response received            ***
    5291   00:5AF0                      ;*** otherwise response not received and   ***
    5292   00:5AF0                      ;*** timed-out.                            ***
    5293   00:5AF0                      ;***                                       ***
    5294   00:5AF0                      ;*** Changes HL, BC, AF, DE, IX            ***
    5295   00:5AF0                      ;*********************************************
    5296   00:5AF0                      WRFE_WAIT_DATA:
    5297   00:5AF0                          LOAD_STS_PORT_IN_A
    5297   00:5AF0  3A 07 7F          >     ld  a,(MEM_IN_STS_PORT)
    5298   00:5AF3  CB 6F                   bit 5,a                         ; If nz Port #07 is not available
    5299   00:5AF5  20 06                   jr  nz,WRFE_STS_NOT_AVAILABLE
    5300   00:5AF7  CB 47                   bit 0,a                         ; if nz has data
    5301   00:5AF9  C0                      ret nz
    5302   00:5AFA  1B                      dec de
    5303   00:5AFB  76                      halt
    5304   00:5AFC  C9                      ret
    5305   00:5AFD                      WRFE_STS_NOT_AVAILABLE:
    5306   00:5AFD  11 00 00                ld  de,0
    5307   00:5B00  AF                      xor a
    5308   00:5B01  C9                      ret
    5309   00:5B02                      
    5310   00:5B02                      WRFE_COMPARE:
    5311   00:5B02  47                      ld  b,a
    5312   00:5B03  7E                      ld  a,(hl)
    5313   00:5B04  B8                      cp  b
    5314   00:5B05  C0                      ret nz
    5315   00:5B06  23                      inc hl
    5316   00:5B07  C9                      ret
    5317   00:5B08                      
    5318   00:5B08                      WAIT_RESPONSE_FROM_ESP:
    5319   00:5B08  4F                      ld  c,a                         ; Response size in C
    5320   00:5B09  E5                      push    hl                      ; Save HL
    5321   00:5B0A  AF                      xor a
    5322   00:5B0B                      WRFE_ST1:
    5323   00:5B0B  DD 67                   ld  ixh,a                       ; We start at index 0
    5324   00:5B0D                      
    5325   00:5B0D                      WRFE_LOOP:
    5326   00:5B0D  CD F0 5A                call    WRFE_WAIT_DATA
    5327   00:5B10  20 07                   jr  nz,WRFE_LOOP.1
    5328   00:5B12  7B                      ld  a,e
    5329   00:5B13  B2                      or  d
    5330   00:5B14  CA 34 5B                jp  z,WRFE_RET_ERROR
    5331   00:5B17  18 F4                   jr  WRFE_LOOP
    5332   00:5B19                      WRFE_LOOP.1:
    5333   00:5B19                          ; nz, check the data
    5334   00:5B19                          RECEIVE_DATA
    5334   00:5B19  3A 06 7F          >     ld a,(MEM_IN_DATA_PORT)
    5335   00:5B1C                          ; Ok, now the byte is in A, let's compare
    5336   00:5B1C                      WRFE_IDXCMD:
    5337   00:5B1C  CD 02 5B                call WRFE_COMPARE
    5338   00:5B1F                          ; if match
    5339   00:5B1F  28 07                   jr  z,WRFE_RSP_MATCH
    5340   00:5B21                          ; did not match, let's zero the rsp index
    5341   00:5B21  AF                      xor a
    5342   00:5B22  DD 67                   ld  ixh,a                       ; re-start at index 0
    5343   00:5B24  E1                      pop hl                          ; restore the response index
    5344   00:5B25  E5                      push    hl                      ; and keep it in stack
    5345   00:5B26                          ; back to get another byte
    5346   00:5B26  18 E5                   jr  WRFE_LOOP
    5347   00:5B28                      WRFE_RSP_MATCH:
    5348   00:5B28                          ; match
    5349   00:5B28  DD 24                   inc ixh
    5350   00:5B2A  DD 7C                   ld  a,ixh
    5351   00:5B2C  B9                      cp  c
    5352   00:5B2D                          ; if a = c done and response is success
    5353   00:5B2D  28 02                   jr  z,WRFE_RET_OK
    5354   00:5B2F                          ; not done, back to get more bytes
    5355   00:5B2F  18 DC                   jr  WRFE_LOOP
    5356   00:5B31                      WRFE_RET_OK:
    5357   00:5B31  E1                      pop hl
    5358   00:5B32  AF                      xor a
    5359   00:5B33  C9                      ret
    5360   00:5B34                      WRFE_RET_ERROR:
    5361   00:5B34  E1                      pop hl
    5362   00:5B35  3E 01                   ld  a,1
    5363   00:5B37  C9                      ret
    5364   00:5B38                      
    5365   00:5B38                      ;*********************************************
    5366   00:5B38                      ;***              RESET ESP                ***
    5367   00:5B38                      ;*** If RESET ok, A will be 0, otherwise   ***
    5368   00:5B38                      ;*** failure                               ***
    5369   00:5B38                      ;*********************************************
    5370   00:5B38                      RESET_ESP:
    5371   00:5B38                          ; Is ESP installed?
    5372   00:5B38                          CLEAR_UART                      ; Clear UART
    5372   00:5B38  3E 14             >     ld  a,20
    5372   00:5B3A  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    5373   00:5B3D  3E 3F                   ld  a,CMD_QUERY_ESP
    5374   00:5B3F                          SEND_DATA
    5374   00:5B3F  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    5375   00:5B42  21 D7 5C                ld  hl,RSP_CMD_QUERY_ESP        ; Expected response
    5376   00:5B45  11 3C 00                ld  de,60                       ; Up to 1s @ 60Hz
    5377   00:5B48  3E 02                   ld  a,RSP_CMD_QUERY_ESP_SIZE    ; Size of response
    5378   00:5B4A  CD 08 5B                call    WAIT_RESPONSE_FROM_ESP
    5379   00:5B4D  B7                      or  a
    5380   00:5B4E  3E 01                   ld  a,1
    5381   00:5B50  28 03                   jr  z,RESET_ESP_INIT            ; ESP Found
    5382   00:5B52  06 00                   ld  b,0                         ; 0 if no response
    5383   00:5B54  C9                      ret
    5384   00:5B55                      RESET_ESP_INIT:
    5385   00:5B55  06 03                   ld  b,3                         ; Retry up to 10 times
    5386   00:5B57                      RESET_ESP_LOOP:
    5387   00:5B57                          CLEAR_UART
    5387   00:5B57  3E 14             >     ld  a,20
    5387   00:5B59  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    5388   00:5B5C                          SET_SPEED
    5388   00:5B5C  AF                >     xor a
    5388   00:5B5D  32 06 7F          >     ld  (MEM_OUT_CMD_PORT),a
    5389   00:5B60  76                      halt
    5390   00:5B61  76                      halt                            ; Wait a little to make sure speed is adjusted
    5391   00:5B62  3E 57                   ld  a,CMD_WRESET_ESP
    5392   00:5B64                          SEND_DATA
    5392   00:5B64  32 07 7F          >     ld  (MEM_OUT_TX_PORT),a
    5393   00:5B67  21 D2 5C                ld  hl,RSP_CMD_RESET_ESP        ; Expected response
    5394   00:5B6A  11 5A 00                ld  de,90                       ; Up to 1.5s @ 60Hz
    5395   00:5B6D  3E 05                   ld  a,RSP_CMD_RESET_ESP_SIZE    ; Size of response
    5396   00:5B6F  C5                      push    bc                      ; Save retry counter
    5397   00:5B70  CD 08 5B                call    WAIT_RESPONSE_FROM_ESP
    5398   00:5B73  C1                      pop bc                          ; restore retry counter
    5399   00:5B74  B7                      or  a                           ; Did WAIT RESPONSE return zero?
    5400   00:5B75  C8                      ret z                           ; Yes, Warm Reset Ok
    5401   00:5B76  10 DF                   djnz RESET_ESP_LOOP             ; No, decrement retry counter and let the loop check
    5402   00:5B78                          ; No more retries? Then check if it is old ESP FW
    5403   00:5B78                      RESET_CHK_IF_INSTALLED:
    5404   00:5B78                          ; No more retries? Then it is old ESP FW
    5405   00:5B78  06 01                   ld  b,1
    5406   00:5B7A  C9                      ret
    5407   00:5B7B                      
    5408   00:5B7B                      ;*********************************************
    5409   00:5B7B                      ;***              SET TIME                 ***
    5410   00:5B7B                      ;*** H - Hour                              ***
    5411   00:5B7B                      ;*** L - Minutes                           ***
    5412   00:5B7B                      ;*** D - Seconds                           ***
    5413   00:5B7B                      ;***                                       ***
    5414   00:5B7B                      ;*** A - 0 if Ok otherwise invalid time    ***
    5415   00:5B7B                      ;*********************************************
    5416   00:5B7B                      SET_TIME:
    5417   00:5B7B  7C                      ld  a,h                         ; Hour in A
    5418   00:5B7C  FE 18                   cp  24                          ; Compare to 24
    5419   00:5B7E  30 12                   jr  nc,SET_TIME_ERR             ; If 24 or more, invalid
    5420   00:5B80  7D                      ld  a,l                         ; Minutes in A
    5421   00:5B81  FE 3C                   cp  60                          ; Compare to 60
    5422   00:5B83  30 0D                   jr  nc,SET_TIME_ERR             ; If 60 or more, invalid
    5423   00:5B85  7A                      LD  a,d                         ; Seconds in D
    5424   00:5B86  FE 3C                   cp  60                          ; Compare to 60
    5425   00:5B88  30 08                   jr  nc,SET_TIME_ERR             ; If 60 or more invalid
    5426   00:5B8A  44                      ld  b,h                         ; Hour in B
    5427   00:5B8B  4D                      ld  c,l                         ; Minutes in C
    5428   00:5B8C  5A                      ld  e,d                         ; Seconds in E
    5429   00:5B8D  CD 95 5B                call    SET_RTC_TIME            ; Set time in RTC
    5430   00:5B90  AF                      xor a                           ; 0 in A
    5431   00:5B91  C9                      ret                             ; Return
    5432   00:5B92                      ;   Invalid parameter
    5433   00:5B92                      SET_TIME_ERR:
    5434   00:5B92  3E 01                   ld  a,1                         ; Invalid Time
    5435   00:5B94  C9                      ret                             ; Return
    5436   00:5B95                      
    5437   00:5B95                      SET_RTC_TIME:
    5438   00:5B95  6B                      ld  l,e                         ; Seconds in L
    5439   00:5B96  61                      ld  h,c                         ; Minutes in H
    5440   00:5B97  50                      ld  d,b                         ; Hour in D
    5441   00:5B98  CD F0 5B                call    STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13, and set Mode / Page 0
    5442   00:5B9B  3E 0F                   ld  a,#F                        ; Register F
    5443   00:5B9D  D3 B4                   out (#B4),a
    5444   00:5B9F  3E 02                   ld  a,2
    5445   00:5BA1  D3 B5                   out (#B5),a                     ; Timer reset seconds and on both clock pulses
    5446   00:5BA3  1E 00                   ld  e,0                         ; Start at register 0
    5447   00:5BA5  C3 2B 5C                jp  SET_RTC_DATE.1              ; And save L, H and D, function will return from there
    5448   00:5BA8                      
    5449   00:5BA8                      ;*********************************************
    5450   00:5BA8                      ;***              SET DATE                 ***
    5451   00:5BA8                      ;*** HL - Year from 1980 to 2079           ***
    5452   00:5BA8                      ;*** D - Month from 1 to 12                ***
    5453   00:5BA8                      ;*** E - Day from 1 to 31                  ***
    5454   00:5BA8                      ;***                                       ***
    5455   00:5BA8                      ;*** A - 0 if Ok otherwise invalid Date    ***
    5456   00:5BA8                      ;*********************************************
    5457   00:5BA8                      SET_DATE:
    5458   00:5BA8  01 44 F8                ld  bc,#F844
    5459   00:5BAB  09                      add hl,bc
    5460   00:5BAC  30 32                   jr  nc,SET_DATE_ERR             ; No carry -> Year is less than 1980, invalid date
    5461   00:5BAE  7C                      ld  a,h
    5462   00:5BAF  B7                      or  a
    5463   00:5BB0  20 2E                   jr  nz,SET_DATE_ERR             ; If H is set, means year is greater than 2235 ,invalid
    5464   00:5BB2  7D                      ld  a,l
    5465   00:5BB3  FE 64                   cp  100
    5466   00:5BB5  30 29                   jr  nc,SET_DATE_ERR             ; If L >= 100 year is greater than 2079, invalid
    5467   00:5BB7  47                      ld  b,a                         ; Year - 1980 in B
    5468   00:5BB8  7A                      ld  a,d                         ; Now test month
    5469   00:5BB9  3D                      dec a
    5470   00:5BBA  FE 0C                   cp  12                          ; If 12 or less this should carry
    5471   00:5BBC  30 22                   jr  nc,SET_DATE_ERR             ; otherwise invalid
    5472   00:5BBE  21 E3 5B                ld  hl,DAYS_IN_MONTH            ; Days in Month table
    5473   00:5BC1  85                      add a,l                         ; add our month
    5474   00:5BC2  6F                      ld  l,a                         ; back in L
    5475   00:5BC3  30 01                   jr  nc,SET_DATE1                ; no carry done
    5476   00:5BC5  24                      inc h                           ; otherwise increase H
    5477   00:5BC6                      SET_DATE1:
    5478   00:5BC6  3E 1C                   ld  a,28                        ; 28 days
    5479   00:5BC8  BE                      cp  (hl)                        ; If month is 28 days, February, need to check if leap and limit is 29 in this year
    5480   00:5BC9  20 08                   jr  nz,SET_DATE2                ; if not, skip below code , so probably above check is if month is february
    5481   00:5BCB  78                      ld  a,b                         ; Year - 1980 in A again
    5482   00:5BCC  E6 03                   and 3                           ; if other than 0, non divisible per 4, so not a leap year
    5483   00:5BCE  20 03                   jr  nz,SET_DATE2                ; Regular year
    5484   00:5BD0  21 EF 5B                ld  hl,DAYS_IN_FEBRUARY_LEAP    ; HL has address of 29 days, maximum number of days for february in leap year
    5485   00:5BD3                      SET_DATE2:
    5486   00:5BD3  7B                      ld  a,e                         ; Day of month in A
    5487   00:5BD4  3D                      dec a                           ; Decrement
    5488   00:5BD5  BE                      cp  (hl)                        ; Compare with Days in month
    5489   00:5BD6  30 08                   jr  nc,SET_DATE_ERR             ; If day is greater than how many days in month, invalid
    5490   00:5BD8  6B                      ld  l,e                         ; Day of month in L
    5491   00:5BD9  62                      ld  h,d                         ; Month in H
    5492   00:5BDA  50                      ld  d,b                         ; Year - 1980 in D
    5493   00:5BDB  CD 15 5C                call    SET_RTC_DATE            ; Set date in RTC
    5494   00:5BDE  AF                      xor a                           ; A = 0
    5495   00:5BDF  C9                      ret                             ; Success
    5496   00:5BE0                      ;   Invalid parameter
    5497   00:5BE0                      SET_DATE_ERR:
    5498   00:5BE0  3E 01                   ld  a,1
    5499   00:5BE2  C9                      ret
    5500   00:5BE3                      
    5501   00:5BE3                      ; Table of top day value for each month
    5502   00:5BE3                      DAYS_IN_MONTH:          db  31,28,31,30,31,30,31,31,30,31,30,31
    5502   00:5BE3  1F 1C 1F 1E 1F 1E 1F 1F 1E 1F 1E 1F 
    5503   00:5BEF                      ; And top day value in February when Leap Year
    5504   00:5BEF  1D                  DAYS_IN_FEBRUARY_LEAP:  db  29
    5505   00:5BF0                      
    5506   00:5BF0                      ; Will select Mode 00 (Date and Time page) and stop clock counting
    5507   00:5BF0                      ; Register D value will be left in A
    5508   00:5BF0                      STOP_RTC_COUNT_SET_MODE0:
    5509   00:5BF0  3E 0D                   ld  a,#D
    5510   00:5BF2  D3 B4                   out (#B4),a                     ; Select RTC register D (mode)
    5511   00:5BF4  DB B5                   in  a,(#B5)                     ; read register D
    5512   00:5BF6  E6 04                   and 4                           ; Save Alarm EN setting, and mode register is 00 and stop counting time
    5513   00:5BF8  D3 B5                   out (#B5),a                     ; And save
    5514   00:5BFA  C9                      ret
    5515   00:5BFB                      
    5516   00:5BFB                      ; Will get a non BCD value in A, convert it to BCD and then save it in
    5517   00:5BFB                      ; a register pair that starts in the register indicated in E
    5518   00:5BFB                      ; Register E will have the next register after that register pair
    5519   00:5BFB                      RTC_SAVE_REGISTERPAIR:
    5520   00:5BFB  4F                      ld  c,a                         ; Save A in C
    5521   00:5BFC  AF                      xor a                           ; 0 in A
    5522   00:5BFD  06 08                   ld  b,8                         ; 8 in B, number of bits for conversion
    5523   00:5BFF                      RTC_SAVE_REGISTERPAIR.1:
    5524   00:5BFF  CB 01                   rlc c                           ; Leftmost bit in Carry
    5525   00:5C01  8F                      adc a,a                         ; A = (A * 2) + Carry
    5526   00:5C02  27                      daa                             ; decimal adjust A, shift = BCD x 2 + carry
    5527   00:5C03  10 FA                   djnz    RTC_SAVE_REGISTERPAIR.1 ; Repeat for 8 bits
    5528   00:5C05  CD 0C 5C                call    SET_RTC_REG             ; Save LSB in register and increase register address
    5529   00:5C08  0F                      rrca
    5530   00:5C09  0F                      rrca
    5531   00:5C0A  0F                      rrca
    5532   00:5C0B  0F                      rrca                            ; now MSB is in LSB position
    5533   00:5C0C                      SET_RTC_REG:
    5534   00:5C0C  47                      ld  b,a                         ; save value to set in B
    5535   00:5C0D  7B                      ld  a,e                         ; and now register address in A
    5536   00:5C0E  D3 B4                   out (#B4),a                     ; The register we want to set
    5537   00:5C10  78                      ld  a,b                         ; restore value
    5538   00:5C11  D3 B5                   out (#B5),a                     ; save it
    5539   00:5C13  1C                      inc e                           ; increase register address, as this usually is done in pairs
    5540   00:5C14  C9                      ret
    5541   00:5C15                      
    5542   00:5C15                      ; Auxiliary function for SET_DATE and SET_TIME
    5543   00:5C15                      ; SET_RTC_DATE will save date, parameters:
    5544   00:5C15                      ; L - Day
    5545   00:5C15                      ; H - Month
    5546   00:5C15                      ; D - Years since 1980
    5547   00:5C15                      ; All values are regular values, this function will properly convert them
    5548   00:5C15                      ;
    5549   00:5C15                      ; SET_RTC_DATE.1 is used by SET_TIME as well
    5550   00:5C15                      ; It will save three register pairs, starting with the register in E
    5551   00:5C15                      ; First pair is updated with value in L
    5552   00:5C15                      ; Second pair is updated with value in H
    5553   00:5C15                      ; Third pair is updated with value in D
    5554   00:5C15                      SET_RTC_DATE:
    5555   00:5C15  CD F0 5B                call    STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13, and set Mode / Page 0
    5556   00:5C18  F6 01                   or  1                           ; Set Bit 0, so Mode / Page 1
    5557   00:5C1A  D3 B5                   out (#B5),a                     ; save it in register 13, now page 1 selected
    5558   00:5C1C  3E 0B                   ld  a,#B                        ; Leap Year Counter Register
    5559   00:5C1E  D3 B4                   out (#B4),a                     ; Select it
    5560   00:5C20  7A                      ld  a,d                         ; Load Years in leap year counter
    5561   00:5C21  D3 B5                   out (#B5),a                     ; So it has count of leap years (0 is 1980, leap, and every time it is 4, leap year again)
    5562   00:5C23  CD F0 5B                call    STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13 and set mode / page 0
    5563   00:5C26  CD F0 5B                call    STOP_RTC_COUNT_SET_MODE0; do it a second time... DOS does it, don't want to JYNX it :P
    5564   00:5C29  1E 07                   ld  e,7                         ; Register 7
    5565   00:5C2B                      SET_RTC_DATE.1:
    5566   00:5C2B  7D                      ld  a,l                         ; A has day
    5567   00:5C2C  CD FB 5B                call    RTC_SAVE_REGISTERPAIR   ; Will convert day to BCD and save in registers 7 and 8
    5568   00:5C2F  7C                      ld  a,h                         ; A has month
    5569   00:5C30  CD FB 5B                call    RTC_SAVE_REGISTERPAIR   ; Will convert month to BCD and save in register 9 and A
    5570   00:5C33  7A                      ld  a,d                         ; A has how many years since 1980
    5571   00:5C34  CD FB 5B                call    RTC_SAVE_REGISTERPAIR   ; Will convert to BCD and save in register B and C
    5572   00:5C37  3E 0D                   ld  a,#D                        ; Register D
    5573   00:5C39  D3 B4                   out (#B4),a                     ; Send it
    5574   00:5C3B  DB B5                   in  a,(#B5)                     ; Read its value
    5575   00:5C3D  F6 08                   or  8                           ; Start counting time again
    5576   00:5C3F  D3 B5                   out (#B5),a                     ; Send
    5577   00:5C41  C9                      ret
    5578   00:5C42                      
    5579   00:5C42                      ; Pattern setup routine
    5580   00:5C42                      PATTERN_SETUP:
    5581   00:5C42  AF                      xor a                           ; Bit-16, V9938 and V9958 only
    5582   00:5C43  21 88 00                ld  hl,#0088                    ; Bit-15 to 0, pattern base address = #0088
    5583   00:5C46  CD B6 5C                call SET_VDP_WRITE
    5584   00:5C49  21 56 5C                ld  hl,PATTERN_DATA             ; Point to hl
    5585   00:5C4C  06 60                   ld  b,8*12                      ; Redraw 12 chars, max 12 chars are suggested
    5586   00:5C4E  0E 98                   ld  c,#98                       ; port #98
    5587   00:5C50                      OUTI_TO_VRAM_TMS9918:
    5588   00:5C50  ED A3                   outi                            ; Slower than otir but useful on TMS9918 which requires 29 T-states
    5589   00:5C52  C2 50 5C                jp  nz,OUTI_TO_VRAM_TMS9918     ; Therefore, don't use 'djnz' here!
    5590   00:5C55  C9                      ret
    5591   00:5C56                      PATTERN_DATA:
    5592   00:5C56                      ; Pattern-01 is CHR$(1)+CHR$(81) = SCAN_TERMINATOR_OPEN
    5593   00:5C56  06                      db  %00000110
    5594   00:5C57  09                      db  %00001001
    5595   00:5C58  09                      db  %00001001
    5596   00:5C59  FC                      db  %11111100                   ; "Opened Padlock"
    5597   00:5C5A  FC                      db  %11111100
    5598   00:5C5B  FC                      db  %11111100
    5599   00:5C5C  FC                      db  %11111100
    5600   00:5C5D  00                      db  %00000000
    5601   00:5C5E                      ; Pattern-02 is CHR$(1)+CHR$(82) = SCAN_TERMINATOR_ENC
    5602   00:5C5E  30                      db  %00110000
    5603   00:5C5F  48                      db  %01001000
    5604   00:5C60  48                      db  %01001000
    5605   00:5C61  FC                      db  %11111100                   ; "Closed Padlock"
    5606   00:5C62  FC                      db  %11111100
    5607   00:5C63  FC                      db  %11111100
    5608   00:5C64  FC                      db  %11111100
    5609   00:5C65  00                      db  %00000000
    5610   00:5C66                      ; Pattern-03 is CHR$(1)+CHR$(83) = Wi-Fi Connected to the AP:
    5611   00:5C66  00                      db  %00000000
    5612   00:5C67  00                      db  %00000000
    5613   00:5C68  70                      db  %01110000
    5614   00:5C69  70                      db  %01110000                   ; "Full Access Point"
    5615   00:5C6A  70                      db  %01110000
    5616   00:5C6B  20                      db  %00100000
    5617   00:5C6C  20                      db  %00100000
    5618   00:5C6D  70                      db  %01110000
    5619   00:5C6E                      ; Pattern-04 is CHR$(1)+CHR$(84) = Wi-Fi Failed to connect to:
    5620   00:5C6E  00                      db  %00000000
    5621   00:5C6F  88                      db  %10001000
    5622   00:5C70  50                      db  %01010000
    5623   00:5C71  20                      db  %00100000                   ; "X"
    5624   00:5C72  50                      db  %01010000
    5625   00:5C73  88                      db  %10001000
    5626   00:5C74  00                      db  %00000000
    5627   00:5C75  00                      db  %00000000
    5628   00:5C76                      ; Pattern-05 is CHR$(1)+CHR$(85) = Requesting connection to:
    5629   00:5C76  00                      db  %00000000
    5630   00:5C77  00                      db  %00000000
    5631   00:5C78  50                      db  %01010000
    5632   00:5C79  20                      db  %00100000                   ; "Partial Access Point"
    5633   00:5C7A  50                      db  %01010000
    5634   00:5C7B  20                      db  %00100000
    5635   00:5C7C  20                      db  %00100000
    5636   00:5C7D  70                      db  %01110000
    5637   00:5C7E                      ; Pattern-06 is CHR$(1)+CHR$(86) = Wi-Fi Did not find the AP:
    5638   00:5C7E  00                      db  %00000000
    5639   00:5C7F  70                      db  %01110000
    5640   00:5C80  88                      db  %10001000
    5641   00:5C81  10                      db  %00010000                   ; "?"
    5642   00:5C82  20                      db  %00100000
    5643   00:5C83  00                      db  %00000000
    5644   00:5C84  20                      db  %00100000
    5645   00:5C85  00                      db  %00000000
    5646   00:5C86                      ; Pattern-07 is CHR$(1)+CHR$(87) = Wi-Fi is Idle, AP configured:
    5647   00:5C86  00                      db  %00000000
    5648   00:5C87  00                      db  %00000000
    5649   00:5C88  00                      db  %00000000
    5650   00:5C89  20                      db  %00100000                   ; "i"
    5651   00:5C8A  00                      db  %00000000
    5652   00:5C8B  20                      db  %00100000
    5653   00:5C8C  20                      db  %00100000
    5654   00:5C8D  70                      db  %01110000
    5655   00:5C8E                      ; Pattern-08 is CHR$(1)+CHR$(88) = Left Middle Wave
    5656   00:5C8E  00                      db  %00000000
    5657   00:5C8F  20                      db  %00100000
    5658   00:5C90  40                      db  %01000000
    5659   00:5C91  40                      db  %01000000                   ; "("
    5660   00:5C92  40                      db  %01000000
    5661   00:5C93  20                      db  %00100000
    5662   00:5C94  00                      db  %00000000
    5663   00:5C95  00                      db  %00000000
    5664   00:5C96                      ; Pattern-09 is CHR$(1)+CHR$(89) = Right Middle Wave
    5665   00:5C96  00                      db  %00000000
    5666   00:5C97  20                      db  %00100000
    5667   00:5C98  10                      db  %00010000
    5668   00:5C99  10                      db  %00010000                   ; ")"
    5669   00:5C9A  10                      db  %00010000
    5670   00:5C9B  20                      db  %00100000
    5671   00:5C9C  00                      db  %00000000
    5672   00:5C9D  00                      db  %00000000
    5673   00:5C9E                      ; Pattern-10 is CHR$(1)+CHR$(90) = Wi-Fi is reconnecting to:
    5674   00:5C9E  00                      db  %00000000
    5675   00:5C9F  00                      db  %00000000
    5676   00:5CA0  00                      db  %00000000
    5677   00:5CA1  A8                      db  %10101000                   ; "..."
    5678   00:5CA2  00                      db  %00000000
    5679   00:5CA3  00                      db  %00000000
    5680   00:5CA4  00                      db  %00000000
    5681   00:5CA5  00                      db  %00000000
    5682   00:5CA6                      ; Pattern-11 is CHR$(1)+CHR$(91) = Double Dot
    5683   00:5CA6  00                      db  %00000000
    5684   00:5CA7  00                      db  %00000000
    5685   00:5CA8  00                      db  %00000000
    5686   00:5CA9  00                      db  %00000000                   ; ".."
    5687   00:5CAA  00                      db  %00000000
    5688   00:5CAB  66                      db  %01100110
    5689   00:5CAC  66                      db  %01100110
    5690   00:5CAD  00                      db  %00000000
    5691   00:5CAE                      ; Pattern-12 is CHR$(1)+CHR$(92) = Copyright
    5692   00:5CAE  38                      db  %00111000
    5693   00:5CAF  44                      db  %01000100
    5694   00:5CB0  BA                      db  %10111010
    5695   00:5CB1  A2                      db  %10100010                   ; "(c)"
    5696   00:5CB2  BA                      db  %10111010
    5697   00:5CB3  44                      db  %01000100
    5698   00:5CB4  38                      db  %00111000
    5699   00:5CB5  00                      db  %00000000
    5700   00:5CB6                      ; http://map.grauw.nl/articles/vdp_tut.php
    5701   00:5CB6                      ; Set VDP address counter to write from address AHL (17-bits)
    5702   00:5CB6                      ; Enables the interrupts
    5703   00:5CB6                      SET_VDP_WRITE:
    5704   00:5CB6  CB 04                   rlc h
    5705   00:5CB8  17                      rla
    5706   00:5CB9  CB 04                   rlc h
    5707   00:5CBB  17                      rla
    5708   00:5CBC  CB 3C                   srl h
    5709   00:5CBE  CB 3C                   srl h
    5710   00:5CC0  F3                      di
    5711   00:5CC1  D3 99                   out (#99),a
    5712   00:5CC3  3E 8E                   ld  a,14+128
    5713   00:5CC5  D3 99                   out (#99),a
    5714   00:5CC7  7D                      ld  a,l
    5715   00:5CC8  00                      nop                             ; Do not remove this 'nop' here!
    5716   00:5CC9  D3 99                   out (#99),a
    5717   00:5CCB  7C                      ld  a,h
    5718   00:5CCC  F6 40                   or  64
    5719   00:5CCE  FB                      ei
    5720   00:5CCF  D3 99                   out (#99),a
    5721   00:5CD1  C9                      ret
    5722   00:5CD2                      
    5723   00:5CD2                      ;*********************************************
    5724   00:5CD2                      ;***    ESP Specific Commands/Responses    ***
    5725   00:5CD2                      ;*********************************************
    5726   00:5CD2                      ; Cold reset of ESP firmware
    5727   00:5CD2  (00:0052)           CMD_RESET_ESP           equ 'R'
    5728   00:5CD2                      ; Warm reset of ESP firmware
    5729   00:5CD2  (00:0057)           CMD_WRESET_ESP          equ 'W'
    5730   00:5CD2                      ; Hold Wi-Fi Connection On
    5731   00:5CD2  (00:0048)           CMD_WIFIHOLD_ESP        equ 'H'
    5732   00:5CD2                      ; Release Wi-Fi Connection Hold
    5733   00:5CD2  (00:0068)           CMD_WIFIRELEASE_ESP     equ 'h'
    5734   00:5CD2                      ; Get Updated time and date from internet
    5735   00:5CD2  (00:0047)           CMD_GET_TIME            equ 'G'
    5736   00:5CD2                      ; Query Auto Clock settings
    5737   00:5CD2  (00:0063)           CMD_QUERY_ACLK_SETTINGS equ 'c'
    5738   00:5CD2                      ; Set Auto Clock settings
    5739   00:5CD2  (00:0043)           CMD_SET_ACLK_SETTINGS   equ 'C'
    5740   00:5CD2                      ; Query ESP settings
    5741   00:5CD2  (00:0051)           CMD_QUERY_ESP_SETTINGS  equ 'Q'
    5742   00:5CD2                      ; Set Timer Value
    5743   00:5CD2  (00:0054)           CMD_TIMER_SET           equ 'T'
    5744   00:5CD2                      ; Turn Nagle On
    5745   00:5CD2  (00:0044)           CMD_NAGLE_ON            equ 'D'
    5746   00:5CD2                      ; Turn Nagle Off
    5747   00:5CD2  (00:004E)           CMD_NAGLE_OFF           equ 'N'
    5748   00:5CD2                      ; Turn Wi-Fi Off
    5749   00:5CD2  (00:004F)           CMD_WIFI_OFF            equ 'O'
    5750   00:5CD2                      ; Request to connect to a network
    5751   00:5CD2  (00:0041)           CMD_WIFI_CONNECT        equ 'A'
    5752   00:5CD2                      ; Request to start network scan
    5753   00:5CD2  (00:0053)           CMD_SCAN_START          equ 'S'
    5754   00:5CD2                      ; Request network scan result
    5755   00:5CD2  (00:0073)           CMD_SCAN_RESULTS        equ 's'
    5756   00:5CD2                      ; Request AP Status
    5757   00:5CD2  (00:0067)           CMD_AP_STS              equ 'g'
    5758   00:5CD2                      ; Get ESP firmware version
    5759   00:5CD2  (00:0056)           CMD_GET_ESP_VER         equ 'V'
    5760   00:5CD2                      ; After finishing Warm reset, ESP returns ready
    5761   00:5CD2  52 65 61 64 79      RSP_CMD_RESET_ESP       db  "Ready"
    5762   00:5CD7  (00:0005)           RSP_CMD_RESET_ESP_SIZE  equ 5
    5763   00:5CD7                      ; Query ESP Presence
    5764   00:5CD7  (00:003F)           CMD_QUERY_ESP           equ '?'
    5765   00:5CD7                      ; Query response
    5766   00:5CD7  4F 4B               RSP_CMD_QUERY_ESP       db  "OK"
    5767   00:5CD9  (00:0002)           RSP_CMD_QUERY_ESP_SIZE  equ 2
    5768   00:5CD9                      
    5769   00:5CD9                      ;--- Strings
    5770   00:5CD9                      ; Special thanks to KdL
    5771   00:5CD9                      ; He has contributed a lot to make the menus and strings
    5772   00:5CD9                      ; concise and much easier to read and understand!
    5773   00:5CD9  (00:0000)           STTERMINATOR            equ 0
    5774   00:5CD9  (00:000A)           LF                      equ 10
    5775   00:5CD9  (00:000B)           HOME                    equ 11
    5776   00:5CD9  (00:000C)           CLS                     equ 12
    5777   00:5CD9  (00:000D)           CR                      equ 13
    5778   00:5CD9  (00:001C)           GORIGHT                 equ 28
    5779   00:5CD9  (00:001D)           GOLEFT                  equ 29
    5780   00:5CD9                      
    5781   00:5CD9                      ENTERING_WIFI_SETUP:
    5782   00:5CD9  0C                      db  CLS
    5783   00:5CDA                          db  "Entering Wi-Fi Setup..."       ,CR,LF,LF,STTERMINATOR
    5783   00:5CDA  45 6E 74 65 72 69 6E 67 20 57 69 2D 46 69 20 53 
    5783   00:5CEA  65 74 75 70 2E 2E 2E 0D 0A 0A 00 
    5784   00:5CF5                      ;---
    5785   00:5CF5                      
    5786   00:5CF5                      WELCOME:
    5787   00:5CF5  0C                      db  CLS
    5788   00:5CF6                          db  "MSXPICO TCP/IP UNAPI 1.3"      ,CR,LF
    5788   00:5CF6  4D 53 58 50 49 43 4F 20 54 43 50 2F 49 50 20 55 
    5788   00:5D06  4E 41 50 49 20 31 2E 33 0D 0A 
    5789   00:5D10                          db  1,92," 2024 Oduvaldo Pavan Junior" ,CR,LF
    5789   00:5D10  01 5C 20 32 30 32 34 20 4F 64 75 76 61 6C 64 6F 
    5789   00:5D20  20 50 61 76 61 6E 20 4A 75 6E 69 6F 72 0D 0A 
    5790   00:5D2F                          db  "ducasp@gmail.com"              ,CR,LF,LF,STTERMINATOR
    5790   00:5D2F  64 75 63 61 73 70 40 67 6D 61 69 6C 2E 63 6F 6D 
    5790   00:5D3F  0D 0A 0A 00 
    5791   00:5D43                      ;---
    5792   00:5D43                      
    5793   00:5D43                      WELCOME_SF:
    5794   00:5D43                          db  "Quick Receive supported."      ,CR,LF,LF,STTERMINATOR
    5794   00:5D43  51 75 69 63 6B 20 52 65 63 65 69 76 65 20 73 75 
    5794   00:5D53  70 70 6F 72 74 65 64 2E 0D 0A 0A 00 
    5795   00:5D5F                      ;---
    5796   00:5D5F                      
    5797   00:5D5F                      WELCOME_CS:
    5798   00:5D5F                          db  "Wi-Fi is reconnecting to:    " ,GOLEFT,CR,LF
    5798   00:5D5F  57 69 2D 46 69 20 69 73 20 72 65 63 6F 6E 6E 65 
    5798   00:5D6F  63 74 69 6E 67 20 74 6F 3A 20 20 20 20 1D 0D 0A 
    5799   00:5D7F                          db  "(",1,88,1,90,1,89,") "         ,STTERMINATOR
    5799   00:5D7F  28 01 58 01 5A 01 59 29 20 00 
    5800   00:5D89                      
    5801   00:5D89                      WELCOME_NEXT:
    5802   00:5D89  0B                      db  HOME
    5803   00:5D8A  0A                      db  LF
    5804   00:5D8B  0A                      db  LF
    5805   00:5D8C  0A 0A 00                db  LF,LF,STTERMINATOR
    5806   00:5D8F                      ;---
    5807   00:5D8F                      
    5808   00:5D8F                      WELCOME_S_NEXT:
    5809   00:5D8F  0A                      db  LF
    5810   00:5D90  0A 0A 00                db  LF,LF,STTERMINATOR
    5811   00:5D93                      ;---
    5812   00:5D93                      
    5813   00:5D93                      WELCOME_SF_NEXT:
    5814   00:5D93  0A 0A 00                db  LF,LF,STTERMINATOR
    5815   00:5D96                      ;---
    5816   00:5D96                      
    5817   00:5D96                      WELCOME_CS0_NEXT:
    5818   00:5D96                          db  "Wi-Fi is Idle, AP configured:" ,GOLEFT,CR,LF
    5818   00:5D96  57 69 2D 46 69 20 69 73 20 49 64 6C 65 2C 20 41 
    5818   00:5DA6  50 20 63 6F 6E 66 69 67 75 72 65 64 3A 1D 0D 0A 
    5819   00:5DB6                          db  "(",1,88,1,87,1,89,") "         ,STTERMINATOR
    5819   00:5DB6  28 01 58 01 57 01 59 29 20 00 
    5820   00:5DC0                      
    5821   00:5DC0                      WELCOME_CS1_NEXT:
    5822   00:5DC0  0D 0A                   db  CR,LF
    5823   00:5DC2                          db  GORIGHT,GORIGHT,GORIGHT,GORIGHT,GORIGHT,GORIGHT,STTERMINATOR
    5823   00:5DC2  1C 1C 1C 1C 1C 1C 00 
    5824   00:5DC9                      
    5825   00:5DC9                      WELCOME_CS2_NEXT:
    5826   00:5DC9                          db  "Wi-Fi Wrong Password for:    " ,GOLEFT,CR,LF
    5826   00:5DC9  57 69 2D 46 69 20 57 72 6F 6E 67 20 50 61 73 73 
    5826   00:5DD9  77 6F 72 64 20 66 6F 72 3A 20 20 20 20 1D 0D 0A 
    5827   00:5DE9                          db  "(",1,88,1,82,1,89,") "         ,STTERMINATOR
    5827   00:5DE9  28 01 58 01 52 01 59 29 20 00 
    5828   00:5DF3                      
    5829   00:5DF3                      WELCOME_CS3_NEXT:
    5830   00:5DF3                          db  "Wi-Fi Did not find the AP:   " ,GOLEFT,CR,LF
    5830   00:5DF3  57 69 2D 46 69 20 44 69 64 20 6E 6F 74 20 66 69 
    5830   00:5E03  6E 64 20 74 68 65 20 41 50 3A 20 20 20 1D 0D 0A 
    5831   00:5E13                          db  "(",1,88,1,86,1,89,") "         ,STTERMINATOR
    5831   00:5E13  28 01 58 01 56 01 59 29 20 00 
    5832   00:5E1D                      
    5833   00:5E1D                      WELCOME_CS4_NEXT:
    5834   00:5E1D                          db  "Wi-Fi Failed to connect to:  " ,GOLEFT,CR,LF
    5834   00:5E1D  57 69 2D 46 69 20 46 61 69 6C 65 64 20 74 6F 20 
    5834   00:5E2D  63 6F 6E 6E 65 63 74 20 74 6F 3A 20 20 1D 0D 0A 
    5835   00:5E3D                          db  "(",1,88,1,84,1,89,") "         ,STTERMINATOR
    5835   00:5E3D  28 01 58 01 54 01 59 29 20 00 
    5836   00:5E47                      
    5837   00:5E47                      WELCOME_CS5_NEXT:
    5838   00:5E47                          db  "Wi-Fi Connected to the AP:   " ,GOLEFT,CR,LF
    5838   00:5E47  57 69 2D 46 69 20 43 6F 6E 6E 65 63 74 65 64 20 
    5838   00:5E57  74 6F 20 74 68 65 20 41 50 3A 20 20 20 1D 0D 0A 
    5839   00:5E67                          db  "(",1,88,1,83,1,89,") "         ,STTERMINATOR
    5839   00:5E67  28 01 58 01 53 01 59 29 20 00 
    5840   00:5E71                      
    5841   00:5E71                      MMENU_S_NEXT:
    5842   00:5E71  0D 0A 0A                db  CR,LF,LF
    5843   00:5E74                          db  "1 - Set Nagle Algorithm"       ,CR,LF
    5843   00:5E74  31 20 2D 20 53 65 74 20 4E 61 67 6C 65 20 41 6C 
    5843   00:5E84  67 6F 72 69 74 68 6D 0D 0A 
    5844   00:5E8D                          db  "2 - Set Wi-Fi On Period"       ,CR,LF
    5844   00:5E8D  32 20 2D 20 53 65 74 20 57 69 2D 46 69 20 4F 6E 
    5844   00:5E9D  20 50 65 72 69 6F 64 0D 0A 
    5845   00:5EA6                          db  "3 - Scan/Join Access Points"   ,CR,LF
    5845   00:5EA6  33 20 2D 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 
    5845   00:5EB6  63 65 73 73 20 50 6F 69 6E 74 73 0D 0A 
    5846   00:5EC3                          db  "4 - Wi-Fi and Clock Settings"  ,CR,LF,LF
    5846   00:5EC3  34 20 2D 20 57 69 2D 46 69 20 61 6E 64 20 43 6C 
    5846   00:5ED3  6F 63 6B 20 53 65 74 74 69 6E 67 73 0D 0A 0A 
    5847   00:5EE2                      ;---
    5848   00:5EE2                          db  "ESC to exit setup."            ,CR,LF,LF
    5848   00:5EE2  45 53 43 20 74 6F 20 65 78 69 74 20 73 65 74 75 
    5848   00:5EF2  70 2E 0D 0A 0A 
    5849   00:5EF7                      ;---
    5850   00:5EF7                          db  "Option: "                      ,STTERMINATOR
    5850   00:5EF7  4F 70 74 69 6F 6E 3A 20 00 
    5851   00:5F00                      
    5852   00:5F00                      MMENU_CLOCK_MSX2:
    5853   00:5F00  0C                      db  CLS
    5854   00:5F01                          db  "[ Wi-Fi and Clock Settings ]"  ,CR,LF,LF
    5854   00:5F01  5B 20 57 69 2D 46 69 20 61 6E 64 20 43 6C 6F 63 
    5854   00:5F11  6B 20 53 65 74 74 69 6E 67 73 20 5D 0D 0A 0A 
    5855   00:5F20                      ;---
    5856   00:5F20                          db  "0 - Wi-Fi & UNAPI are online"  ,CR,LF
    5856   00:5F20  30 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5856   00:5F30  49 20 61 72 65 20 6F 6E 6C 69 6E 65 0D 0A 
    5857   00:5F3E                          db  "1 - Also wait up to 10s for"   ,CR,LF
    5857   00:5F3E  31 20 2D 20 41 6C 73 6F 20 77 61 69 74 20 75 70 
    5857   00:5F4E  20 74 6F 20 31 30 73 20 66 6F 72 0D 0A 
    5858   00:5F5B                          db  "    internet availability and" ,GOLEFT,CR,LF
    5858   00:5F5B  20 20 20 20 69 6E 74 65 72 6E 65 74 20 61 76 61 
    5858   00:5F6B  69 6C 61 62 69 6C 69 74 79 20 61 6E 64 1D 0D 0A 
    5859   00:5F7B                          db  "    get time from SNTP server" ,GOLEFT,CR,LF
    5859   00:5F7B  20 20 20 20 67 65 74 20 74 69 6D 65 20 66 72 6F 
    5859   00:5F8B  6D 20 53 4E 54 50 20 73 65 72 76 65 72 1D 0D 0A 
    5860   00:5F9B                          db  "    adjusting the time zone"   ,CR,LF
    5860   00:5F9B  20 20 20 20 61 64 6A 75 73 74 69 6E 67 20 74 68 
    5860   00:5FAB  65 20 74 69 6D 65 20 7A 6F 6E 65 0D 0A 
    5861   00:5FB8                          db  "2 - The same as option 1 but"  ,CR,LF
    5861   00:5FB8  32 20 2D 20 54 68 65 20 73 61 6D 65 20 61 73 20 
    5861   00:5FC8  6F 70 74 69 6F 6E 20 31 20 62 75 74 0D 0A 
    5862   00:5FD6                          db  "    also will turn off Wi-Fi"  ,CR,LF
    5862   00:5FD6  20 20 20 20 61 6C 73 6F 20 77 69 6C 6C 20 74 75 
    5862   00:5FE6  72 6E 20 6F 66 66 20 57 69 2D 46 69 0D 0A 
    5863   00:5FF4                          db  "    when done"                 ,CR,LF
    5863   00:5FF4  20 20 20 20 77 68 65 6E 20 64 6F 6E 65 0D 0A 
    5864   00:6003                          db  "3 - Wi-Fi & UNAPI are offline" ,GOLEFT,CR,LF,LF
    5864   00:6003  33 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5864   00:6013  49 20 61 72 65 20 6F 66 66 6C 69 6E 65 1D 0D 0A 
    5864   00:6023  0A 
    5865   00:6024                      ;---
    5866   00:6024                          db  "MSX boot will take longer if"  ,CR,LF
    5866   00:6024  4D 53 58 20 62 6F 6F 74 20 77 69 6C 6C 20 74 61 
    5866   00:6034  6B 65 20 6C 6F 6E 67 65 72 20 69 66 0D 0A 
    5867   00:6042                          db  "options 1 or 2 are active."    ,CR,LF,LF,STTERMINATOR
    5867   00:6042  6F 70 74 69 6F 6E 73 20 31 20 6F 72 20 32 20 61 
    5867   00:6052  72 65 20 61 63 74 69 76 65 2E 0D 0A 0A 00 
    5868   00:6060                      ;---
    5869   00:6060                      
    5870   00:6060                      MMENU_CLOCK_MSX1:
    5871   00:6060  0C                      db  CLS
    5872   00:6061                          db  "[ Wi-Fi and Clock Settings ]"  ,CR,LF,LF
    5872   00:6061  5B 20 57 69 2D 46 69 20 61 6E 64 20 43 6C 6F 63 
    5872   00:6071  6B 20 53 65 74 74 69 6E 67 73 20 5D 0D 0A 0A 
    5873   00:6080                      ;---
    5874   00:6080                          db  "0 - Wi-Fi & UNAPI are online"  ,CR,LF
    5874   00:6080  30 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5874   00:6090  49 20 61 72 65 20 6F 6E 6C 69 6E 65 0D 0A 
    5875   00:609E                          db  "1 - Unavailable for MSX1"      ,CR,LF
    5875   00:609E  31 20 2D 20 55 6E 61 76 61 69 6C 61 62 6C 65 20 
    5875   00:60AE  66 6F 72 20 4D 53 58 31 0D 0A 
    5876   00:60B8                          db  "2 - Unavailable for MSX1"      ,CR,LF
    5876   00:60B8  32 20 2D 20 55 6E 61 76 61 69 6C 61 62 6C 65 20 
    5876   00:60C8  66 6F 72 20 4D 53 58 31 0D 0A 
    5877   00:60D2                          db  "3 - Wi-Fi & UNAPI are offline" ,GOLEFT,CR,LF,LF,STTERMINATOR
    5877   00:60D2  33 20 2D 20 57 69 2D 46 69 20 26 20 55 4E 41 50 
    5877   00:60E2  49 20 61 72 65 20 6F 66 66 6C 69 6E 65 1D 0D 0A 
    5877   00:60F2  0A 00 
    5878   00:60F4                      ;---
    5879   00:60F4                      
    5880   00:60F4                      MMENU_CLOCK_0:
    5881   00:60F4                          db  "Currently: ONLINE"             ,STTERMINATOR
    5881   00:60F4  43 75 72 72 65 6E 74 6C 79 3A 20 4F 4E 4C 49 4E 
    5881   00:6104  45 00 
    5882   00:6106                      
    5883   00:6106                      MMENU_CLOCK_1:
    5884   00:6106                          db  "Currently: TIME-OPT1, GMT"     ,STTERMINATOR
    5884   00:6106  43 75 72 72 65 6E 74 6C 79 3A 20 54 49 4D 45 2D 
    5884   00:6116  4F 50 54 31 2C 20 47 4D 54 00 
    5885   00:6120                      
    5886   00:6120                      MMENU_CLOCK_2:
    5887   00:6120                          db  "Currently: TIME-OPT2, GMT"     ,STTERMINATOR
    5887   00:6120  43 75 72 72 65 6E 74 6C 79 3A 20 54 49 4D 45 2D 
    5887   00:6130  4F 50 54 32 2C 20 47 4D 54 00 
    5888   00:613A                      
    5889   00:613A                      MMENU_CLOCK_3:
    5890   00:613A                          db  "Currently: OFFLINE"            ,STTERMINATOR
    5890   00:613A  43 75 72 72 65 6E 74 6C 79 3A 20 4F 46 46 4C 49 
    5890   00:614A  4E 45 00 
    5891   00:614D                      
    5892   00:614D                      MMENU_CLOCK_OPT:
    5893   00:614D  0D 0A 0A                db  CR,LF,LF
    5894   00:6150                      ;---
    5895   00:6150                          db  "ESC to return to main menu."   ,CR,LF,LF
    5895   00:6150  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    5895   00:6160  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    5896   00:616E                      ;---
    5897   00:616E                          db  "Option: "                      ,STTERMINATOR
    5897   00:616E  4F 70 74 69 6F 6E 3A 20 00 
    5898   00:6177                      
    5899   00:6177                      MMENU_GMT_OPT:
    5900   00:6177  0D 0A                   db  CR,LF
    5901   00:6179                          db  "Time Zone adjustment: "        ,STTERMINATOR
    5901   00:6179  54 69 6D 65 20 5A 6F 6E 65 20 61 64 6A 75 73 74 
    5901   00:6189  6D 65 6E 74 3A 20 00 
    5902   00:6190                      
    5903   00:6190                      MMENU_MANUALENTRY:
    5904   00:6190  0C                      db  CLS
    5905   00:6191                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    5905   00:6191  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    5905   00:61A1  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    5906   00:61AF                      ;---
    5907   00:61AF                          db  "ESC to return to main menu."   ,CR,LF,LF
    5907   00:61AF  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    5907   00:61BF  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    5908   00:61CD                      ;---
    5909   00:61CD                          db  "Manual entry, type SSID:"      ,CR,LF
    5909   00:61CD  4D 61 6E 75 61 6C 20 65 6E 74 72 79 2C 20 74 79 
    5909   00:61DD  70 65 20 53 53 49 44 3A 0D 0A 
    5910   00:61E7                          db  "(",1,88,1,83,1,89,") "         ,STTERMINATOR
    5910   00:61E7  28 01 58 01 53 01 59 29 20 00 
    5911   00:61F1                      
    5912   00:61F1                      MENU_MANUALENTRY_PWD:
    5913   00:61F1  0D 0A 0A                db  CR,LF,LF
    5914   00:61F4                      ;---
    5915   00:61F4                          db  "Password needed (y/n)? "             ,STTERMINATOR
    5915   00:61F4  50 61 73 73 77 6F 72 64 20 6E 65 65 64 65 64 20 
    5915   00:6204  28 79 2F 6E 29 3F 20 00 
    5916   00:620C                      
    5917   00:620C                      MMENU_SCAN:
    5918   00:620C  0C                      db  CLS
    5919   00:620D                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    5919   00:620D  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    5919   00:621D  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    5920   00:622B                      ;---
    5921   00:622B                          db  "Up to ",SCAN_MAX_PAGE_SIZE+48," APs per page." ,CR,LF,LF
    5921   00:622B  55 70 20 74 6F 20 38 20 41 50 73 20 70 65 72 20 
    5921   00:623B  70 61 67 65 2E 0D 0A 0A 
    5922   00:6243                      ;---
    5923   00:6243                          db  "Scanning networks..."          ,CR,LF,STTERMINATOR
    5923   00:6243  53 63 61 6E 6E 69 6E 67 20 6E 65 74 77 6F 72 6B 
    5923   00:6253  73 2E 2E 2E 0D 0A 00 
    5924   00:625A                      
    5925   00:625A                      MMENU_SCANF:
    5926   00:625A  0D 0A                   db  CR,LF
    5927   00:625C                          db  "Error or no networks found!"   ,CR,LF,STTERMINATOR
    5927   00:625C  45 72 72 6F 72 20 6F 72 20 6E 6F 20 6E 65 74 77 
    5927   00:626C  6F 72 6B 73 20 66 6F 75 6E 64 21 0D 0A 00 
    5928   00:627A                      
    5929   00:627A                      MMENU_SCANN:
    5930   00:627A  0D 0A                   db  CR,LF
    5931   00:627C                          db  "No networks found!"            ,CR,LF,STTERMINATOR
    5931   00:627C  4E 6F 20 6E 65 74 77 6F 72 6B 73 20 66 6F 75 6E 
    5931   00:628C  64 21 0D 0A 00 
    5932   00:6291                      
    5933   00:6291                      MMENU_SCANS:
    5934   00:6291  0C                      db  CLS
    5935   00:6292                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    5935   00:6292  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    5935   00:62A2  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    5936   00:62B0                      ;---
    5937   00:62B0                          db  "Networks available:"           ,CR,LF,LF,STTERMINATOR
    5937   00:62B0  4E 65 74 77 6F 72 6B 73 20 61 76 61 69 6C 61 62 
    5937   00:62C0  6C 65 3A 0D 0A 0A 00 
    5938   00:62C7                      ;---
    5939   00:62C7                      
    5940   00:62C7                      MMENU_CONNECTING:
    5941   00:62C7  0C                      db  CLS
    5942   00:62C8                          db  "[ Scan/Join Access Points ]"   ,CR,LF,LF
    5942   00:62C8  5B 20 53 63 61 6E 2F 4A 6F 69 6E 20 41 63 63 65 
    5942   00:62D8  73 73 20 50 6F 69 6E 74 73 20 5D 0D 0A 0A 
    5943   00:62E6                      ;---
    5944   00:62E6                          db  "Requesting connection to:"     ,CR,LF
    5944   00:62E6  52 65 71 75 65 73 74 69 6E 67 20 63 6F 6E 6E 65 
    5944   00:62F6  63 74 69 6F 6E 20 74 6F 3A 0D 0A 
    5945   00:6301                          db  "(",1,88,1,85,1,89,") "         ,STTERMINATOR
    5945   00:6301  28 01 58 01 55 01 59 29 20 00 
    5946   00:630B                      
    5947   00:630B                      MMENU_ASKPWD:
    5948   00:630B  0D 0A                   db  CR,LF
    5949   00:630D                          db  "Hit DEL as first character"    ,CR,LF
    5949   00:630D  48 69 74 20 44 45 4C 20 61 73 20 66 69 72 73 74 
    5949   00:631D  20 63 68 61 72 61 63 74 65 72 0D 0A 
    5950   00:6329                          db  "to hide/show the typing."      ,CR,LF
    5950   00:6329  74 6F 20 68 69 64 65 2F 73 68 6F 77 20 74 68 65 
    5950   00:6339  20 74 79 70 69 6E 67 2E 0D 0A 
    5951   00:6343                          db  "Password: "                    ,STTERMINATOR
    5951   00:6343  50 61 73 73 77 6F 72 64 3A 20 00 
    5952   00:634E                      
    5953   00:634E                      MMENU_SCANQ:
    5954   00:634E  0D 0A                   db  CR,LF
    5955   00:6350                          db  "ESC to return to main menu."   ,CR,LF
    5955   00:6350  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    5955   00:6360  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 
    5956   00:636D                          db  "SPACE BAR to scan again."  ,CR,LF
    5956   00:636D  53 50 41 43 45 20 42 41 52 20 74 6F 20 73 63 61 
    5956   00:637D  6E 20 61 67 61 69 6E 2E 0D 0A 
    5957   00:6387                          db  "ENTER to type SSID/AP name."   ,CR,LF,LF
    5957   00:6387  45 4E 54 45 52 20 74 6F 20 74 79 70 65 20 53 53 
    5957   00:6397  49 44 2F 41 50 20 6E 61 6D 65 2E 0D 0A 0A 
    5958   00:63A5                      ;---
    5959   00:63A5                          db  "Number to connect: "       ,STTERMINATOR
    5959   00:63A5  4E 75 6D 62 65 72 20 74 6F 20 63 6F 6E 6E 65 63 
    5959   00:63B5  74 3A 20 00 
    5960   00:63B9                      
    5961   00:63B9                      MMENU_SCANQM:
    5962   00:63B9  0D 0A                   db  CR,LF
    5963   00:63BB                          db  "ESC to return to main menu."   ,CR,LF
    5963   00:63BB  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    5963   00:63CB  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 
    5964   00:63D8                          db  "SPACE BAR to show next page."  ,CR,LF
    5964   00:63D8  53 50 41 43 45 20 42 41 52 20 74 6F 20 73 68 6F 
    5964   00:63E8  77 20 6E 65 78 74 20 70 61 67 65 2E 0D 0A 
    5965   00:63F6                          db  "ENTER to type SSID/AP name."   ,CR,LF,LF
    5965   00:63F6  45 4E 54 45 52 20 74 6F 20 74 79 70 65 20 53 53 
    5965   00:6406  49 44 2F 41 50 20 6E 61 6D 65 2E 0D 0A 0A 
    5966   00:6414                      ;---
    5967   00:6414                          db  "Number to connect: "       ,STTERMINATOR
    5967   00:6414  4E 75 6D 62 65 72 20 74 6F 20 63 6F 6E 6E 65 63 
    5967   00:6424  74 3A 20 00 
    5968   00:6428                      
    5969   00:6428                      SCAN_TERMINATOR_CUT:
    5970   00:6428                          db  GOLEFT,GOLEFT,1,91," ",GOLEFT,STTERMINATOR
    5970   00:6428  1D 1D 01 5B 20 1D 00 
    5971   00:642F                      
    5972   00:642F                      SCAN_TERMINATOR_OPEN:
    5973   00:642F                          db  " ",1,81,GOLEFT,CR,LF,STTERMINATOR
    5973   00:642F  20 01 51 1D 0D 0A 00 
    5974   00:6436                      
    5975   00:6436                      SCAN_TERMINATOR_ENC:
    5976   00:6436                          db  " ",1,82,GOLEFT,CR,LF,STTERMINATOR
    5976   00:6436  20 01 52 1D 0D 0A 00 
    5977   00:643D                      
    5978   00:643D                      MMENU_TIMEOUT:
    5979   00:643D  0C                      db  CLS
    5980   00:643E                          db  "   [ Set Wi-Fi On Period ]"    ,CR,LF,LF
    5980   00:643E  20 20 20 5B 20 53 65 74 20 57 69 2D 46 69 20 4F 
    5980   00:644E  6E 20 50 65 72 69 6F 64 20 5D 0D 0A 0A 
    5981   00:645B                      ;---
    5982   00:645B                          db  "Wi-Fi On Period allows to set" ,GOLEFT,CR,LF
    5982   00:645B  57 69 2D 46 69 20 4F 6E 20 50 65 72 69 6F 64 20 
    5982   00:646B  61 6C 6C 6F 77 73 20 74 6F 20 73 65 74 1D 0D 0A 
    5983   00:647B                          db  "a given period of time of"     ,CR,LF
    5983   00:647B  61 20 67 69 76 65 6E 20 70 65 72 69 6F 64 20 6F 
    5983   00:648B  66 20 74 69 6D 65 20 6F 66 0D 0A 
    5984   00:6496                          db  "inactivity to turn off Wi-Fi"  ,CR,LF
    5984   00:6496  69 6E 61 63 74 69 76 69 74 79 20 74 6F 20 74 75 
    5984   00:64A6  72 6E 20 6F 66 66 20 57 69 2D 46 69 0D 0A 
    5985   00:64B4                          db  "automatically."                ,CR,LF,LF
    5985   00:64B4  61 75 74 6F 6D 61 74 69 63 61 6C 6C 79 2E 0D 0A 
    5985   00:64C4  0A 
    5986   00:64C5                      ;---
    5987   00:64C5                          db  "0         - Always on"         ,CR,LF
    5987   00:64C5  30 20 20 20 20 20 20 20 20 20 2D 20 41 6C 77 61 
    5987   00:64D5  79 73 20 6F 6E 0D 0A 
    5988   00:64DC                          db  "1 to 30   - 30s"               ,CR,LF
    5988   00:64DC  31 20 74 6F 20 33 30 20 20 20 2D 20 33 30 73 0D 
    5988   00:64EC  0A 
    5989   00:64ED                          db  "31 to 600 - Use given period"  ,CR,LF
    5989   00:64ED  33 31 20 74 6F 20 36 30 30 20 2D 20 55 73 65 20 
    5989   00:64FD  67 69 76 65 6E 20 70 65 72 69 6F 64 0D 0A 
    5990   00:650B                          db  "> 600     - 600s"              ,CR,LF,LF,STTERMINATOR
    5990   00:650B  3E 20 36 30 30 20 20 20 20 20 2D 20 36 30 30 73 
    5990   00:651B  0D 0A 0A 00 
    5991   00:651F                      ;---
    5992   00:651F                      
    5993   00:651F                      MMENU_TIMEOUT_ALWAYSON:
    5994   00:651F                          db  "Wi-Fi is currently: ALWAYS ON" ,GOLEFT,CR,LF,LF
    5994   00:651F  57 69 2D 46 69 20 69 73 20 63 75 72 72 65 6E 74 
    5994   00:652F  6C 79 3A 20 41 4C 57 41 59 53 20 4F 4E 1D 0D 0A 
    5994   00:653F  0A 
    5995   00:6540                      ;---
    5996   00:6540                          db  "ESC to return to main menu."   ,CR,LF,LF
    5996   00:6540  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    5996   00:6550  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    5997   00:655E                      ;---
    5998   00:655E                          db  "Type desired period: "         ,STTERMINATOR
    5998   00:655E  54 79 70 65 20 64 65 73 69 72 65 64 20 70 65 72 
    5998   00:656E  69 6F 64 3A 20 00 
    5999   00:6574                      
    6000   00:6574                      MMENU_TIMEOUT_NOTALWAYSON1:
    6001   00:6574                          db  "Wi-Fi period set to: "         ,STTERMINATOR
    6001   00:6574  57 69 2D 46 69 20 70 65 72 69 6F 64 20 73 65 74 
    6001   00:6584  20 74 6F 3A 20 00 
    6002   00:658A                      
    6003   00:658A                      MMENU_TIMEOUT_NOTALWAYSON2:
    6004   00:658A  73 0D 0A 0A             db  "s"                             ,CR,LF,LF
    6005   00:658E                      ;---
    6006   00:658E                          db  "ESC to return to main menu."   ,CR,LF,LF
    6006   00:658E  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6006   00:659E  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    6007   00:65AC                      ;---
    6008   00:65AC                          db  "Type desired period: "         ,STTERMINATOR
    6008   00:65AC  54 79 70 65 20 64 65 73 69 72 65 64 20 70 65 72 
    6008   00:65BC  69 6F 64 3A 20 00 
    6009   00:65C2                      
    6010   00:65C2                      MMENU_NAGLE:
    6011   00:65C2  0C                      db  CLS
    6012   00:65C3                          db  "   [ Set Nagle Algorithm ]"    ,CR,LF,LF
    6012   00:65C3  20 20 20 5B 20 53 65 74 20 4E 61 67 6C 65 20 41 
    6012   00:65D3  6C 67 6F 72 69 74 68 6D 20 5D 0D 0A 0A 
    6013   00:65E0                      ;---
    6014   00:65E0                          db  "Nagle Algorithm might lower"   ,CR,LF
    6014   00:65E0  4E 61 67 6C 65 20 41 6C 67 6F 72 69 74 68 6D 20 
    6014   00:65F0  6D 69 67 68 74 20 6C 6F 77 65 72 0D 0A 
    6015   00:65FD                          db  "performance but create less"   ,CR,LF
    6015   00:65FD  70 65 72 66 6F 72 6D 61 6E 63 65 20 62 75 74 20 
    6015   00:660D  63 72 65 61 74 65 20 6C 65 73 73 0D 0A 
    6016   00:661A                          db  "network congestion."           ,CR,LF
    6016   00:661A  6E 65 74 77 6F 72 6B 20 63 6F 6E 67 65 73 74 69 
    6016   00:662A  6F 6E 2E 0D 0A 
    6017   00:662F                          db  "Nowadays it is mostly not"     ,CR,LF
    6017   00:662F  4E 6F 77 61 64 61 79 73 20 69 74 20 69 73 20 6D 
    6017   00:663F  6F 73 74 6C 79 20 6E 6F 74 0D 0A 
    6018   00:664A                          db  "needed and is the cause of"    ,CR,LF
    6018   00:664A  6E 65 65 64 65 64 20 61 6E 64 20 69 73 20 74 68 
    6018   00:665A  65 20 63 61 75 73 65 20 6F 66 0D 0A 
    6019   00:6666                          db  "latency and low performance"   ,CR,LF
    6019   00:6666  6C 61 74 65 6E 63 79 20 61 6E 64 20 6C 6F 77 20 
    6019   00:6676  70 65 72 66 6F 72 6D 61 6E 63 65 0D 0A 
    6020   00:6683                          db  "on packet-driven protocols."   ,CR,LF,LF
    6020   00:6683  6F 6E 20 70 61 63 6B 65 74 2D 64 72 69 76 65 6E 
    6020   00:6693  20 70 72 6F 74 6F 63 6F 6C 73 2E 0D 0A 0A 
    6021   00:66A1                      ;---
    6022   00:66A1                          db  "O - Turn it on/off"            ,CR,LF,LF,STTERMINATOR
    6022   00:66A1  4F 20 2D 20 54 75 72 6E 20 69 74 20 6F 6E 2F 6F 
    6022   00:66B1  66 66 0D 0A 0A 00 
    6023   00:66B7                      ;---
    6024   00:66B7                      
    6025   00:66B7                      MMENU_NAGLE_ON:
    6026   00:66B7                          db  "Nagle is currently: ON"        ,CR,LF,LF
    6026   00:66B7  4E 61 67 6C 65 20 69 73 20 63 75 72 72 65 6E 74 
    6026   00:66C7  6C 79 3A 20 4F 4E 0D 0A 0A 
    6027   00:66D0                      ;---
    6028   00:66D0                          db  "ESC to return to main menu."   ,CR,LF,LF
    6028   00:66D0  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6028   00:66E0  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    6029   00:66EE                      ;---
    6030   00:66EE                          db  "Option: "                      ,STTERMINATOR
    6030   00:66EE  4F 70 74 69 6F 6E 3A 20 00 
    6031   00:66F7                      
    6032   00:66F7                      MMENU_NAGLE_OFF:
    6033   00:66F7                          db  "Nagle is currently: OFF"       ,CR,LF,LF
    6033   00:66F7  4E 61 67 6C 65 20 69 73 20 63 75 72 72 65 6E 74 
    6033   00:6707  6C 79 3A 20 4F 46 46 0D 0A 0A 
    6034   00:6711                      ;---
    6035   00:6711                          db  "ESC to return to main menu."   ,CR,LF,LF
    6035   00:6711  45 53 43 20 74 6F 20 72 65 74 75 72 6E 20 74 6F 
    6035   00:6721  20 6D 61 69 6E 20 6D 65 6E 75 2E 0D 0A 0A 
    6036   00:672F                      ;---
    6037   00:672F                          db  "Option: "                      ,STTERMINATOR
    6037   00:672F  4F 70 74 69 6F 6E 3A 20 00 
    6038   00:6738                      
    6039   00:6738                      STR_SENDING:
    6040   00:6738                          db  "Sending command, wait..."      ,CR,LF,STTERMINATOR
    6040   00:6738  53 65 6E 64 69 6E 67 20 63 6F 6D 6D 61 6E 64 2C 
    6040   00:6748  20 77 61 69 74 2E 2E 2E 0D 0A 00 
    6041   00:6753                      
    6042   00:6753                      STR_SENDING_OK:
    6043   00:6753                          db  "Command sent Ok, done!"        ,CR,LF,STTERMINATOR
    6043   00:6753  43 6F 6D 6D 61 6E 64 20 73 65 6E 74 20 4F 6B 2C 
    6043   00:6763  20 64 6F 6E 65 21 0D 0A 00 
    6044   00:676C                      
    6045   00:676C                      STR_SENDING_OK_JN:
    6046   00:676C                          db  CR,GORIGHT,GORIGHT,1,83,CR,LF,LF
    6046   00:676C  0D 1C 1C 01 53 0D 0A 0A 
    6047   00:6774                      ;---
    6048   00:6774                          db  "Successfully connected!"       ,CR,LF,STTERMINATOR
    6048   00:6774  53 75 63 63 65 73 73 66 75 6C 6C 79 20 63 6F 6E 
    6048   00:6784  6E 65 63 74 65 64 21 0D 0A 00 
    6049   00:678E                      
    6050   00:678E                      STR_SENDING_NOK_JN:
    6051   00:678E                          db  CR,GORIGHT,GORIGHT,1,84,CR,LF,LF
    6051   00:678E  0D 1C 1C 01 54 0D 0A 0A 
    6052   00:6796                      ;---
    6053   00:6796                          db  "Fail to connect, if protected" ,GOLEFT,CR,LF
    6053   00:6796  46 61 69 6C 20 74 6F 20 63 6F 6E 6E 65 63 74 2C 
    6053   00:67A6  20 69 66 20 70 72 6F 74 65 63 74 65 64 1D 0D 0A 
    6054   00:67B6                          db  "network check password!"       ,CR,LF,STTERMINATOR
    6054   00:67B6  6E 65 74 77 6F 72 6B 20 63 68 65 63 6B 20 70 61 
    6054   00:67C6  73 73 77 6F 72 64 21 0D 0A 00 
    6055   00:67D0                      
    6056   00:67D0                      STR_SENDING_FAIL:
    6057   00:67D0                          db  "Command failure..."            ,CR,LF,STTERMINATOR
    6057   00:67D0  43 6F 6D 6D 61 6E 64 20 66 61 69 6C 75 72 65 2E 
    6057   00:67E0  2E 2E 0D 0A 00 
    6058   00:67E5                      
    6059   00:67E5                      STR_CLKUPDT_FAIL:
    6060   00:67E5                          db  "Failure retrieving date and"   ,CR,LF
    6060   00:67E5  46 61 69 6C 75 72 65 20 72 65 74 72 69 65 76 69 
    6060   00:67F5  6E 67 20 64 61 74 65 20 61 6E 64 0D 0A 
    6061   00:6802                          db  "time from SNTP server!"        ,CR,LF,LF
    6061   00:6802  74 69 6D 65 20 66 72 6F 6D 20 53 4E 54 50 20 73 
    6061   00:6812  65 72 76 65 72 21 0D 0A 0A 
    6062   00:681B                      ;---
    6063   00:681B                          db  "Press and hold F1 during"      ,CR,LF
    6063   00:681B  50 72 65 73 73 20 61 6E 64 20 68 6F 6C 64 20 46 
    6063   00:682B  31 20 64 75 72 69 6E 67 0D 0A 
    6064   00:6835                          db  "system boot to enter setup."   ,CR,LF,STTERMINATOR
    6064   00:6835  73 79 73 74 65 6D 20 62 6F 6F 74 20 74 6F 20 65 
    6064   00:6845  6E 74 65 72 20 73 65 74 75 70 2E 0D 0A 00 
    6065   00:6853                      
    6066   00:6853                      OK_S:
    6067   00:6853                          db  "Installed successfully!"       ,CR,LF,LF,STTERMINATOR
    6067   00:6853  49 6E 73 74 61 6C 6C 65 64 20 73 75 63 63 65 73 
    6067   00:6863  73 66 75 6C 6C 79 21 0D 0A 0A 00 
    6068   00:686E                      ;---
    6069   00:686E                      
    6070   00:686E                      FAIL_S:
    6071   00:686E  0C                      db  CLS
    6072   00:686F                          db  "ESP8266 Not Found!"            ,CR,LF,LF
    6072   00:686F  45 53 50 38 32 36 36 20 4E 6F 74 20 46 6F 75 6E 
    6072   00:687F  64 21 0D 0A 0A 
    6073   00:6884                      ;---
    6074   00:6884                          db  "Check that it is properly"     ,CR,LF
    6074   00:6884  43 68 65 63 6B 20 74 68 61 74 20 69 74 20 69 73 
    6074   00:6894  20 70 72 6F 70 65 72 6C 79 0D 0A 
    6075   00:689F                          db  "inserted in its connector."    ,CR,LF,STTERMINATOR
    6075   00:689F  69 6E 73 65 72 74 65 64 20 69 6E 20 69 74 73 20 
    6075   00:68AF  63 6F 6E 6E 65 63 74 6F 72 2E 0D 0A 00 
    6076   00:68BC                      
    6077   00:68BC                      FAIL_F:
    6078   00:68BC  0C                      db  CLS
    6079   00:68BD                          db  "ESP8266 FW Update Required!"   ,CR,LF,STTERMINATOR
    6079   00:68BD  45 53 50 38 32 36 36 20 46 57 20 55 70 64 61 74 
    6079   00:68CD  65 20 52 65 71 75 69 72 65 64 21 0D 0A 00 
    6080   00:68DB                      
    6081   00:68DB                      STR_WAITING:
    6082   00:68DB  0B                      db  HOME
    6083   00:68DC                          db  "Waiting for connection..."     ,GOLEFT,CR,LF,LF,LF,STTERMINATOR
    6083   00:68DC  57 61 69 74 69 6E 67 20 66 6F 72 20 63 6F 6E 6E 
    6083   00:68EC  65 63 74 69 6F 6E 2E 2E 2E 1D 0D 0A 0A 0A 00 
    6084   00:68FB                      ;---
    6085   00:68FB                      ;---
    6086   00:68FB                      
    6087   00:68FB                      STR_OOPS:
    6088   00:68FB  0C                      db  CLS
    6089   00:68FC                          db  "Oops! An unexpected error"     ,CR,LF
    6089   00:68FC  4F 6F 70 73 21 20 41 6E 20 75 6E 65 78 70 65 63 
    6089   00:690C  74 65 64 20 65 72 72 6F 72 0D 0A 
    6090   00:6917                          db  "occurred on the last reboot."  ,CR,LF,STTERMINATOR
    6090   00:6917  6F 63 63 75 72 72 65 64 20 6F 6E 20 74 68 65 20 
    6090   00:6927  6C 61 73 74 20 72 65 62 6F 6F 74 2E 0D 0A 00 
    6091   00:6936                      
    6092   00:6936                      ;============================
    6093   00:6936                      ;===  UNAPI related data  ===
    6094   00:6936                      ;============================
    6095   00:6936                      
    6096   00:6936                      ;--- Specification identifier (up to 15 chars)
    6097   00:6936                      
    6098   00:6936                      UNAPI_ID:               db  "TCP/IP",0
    6098   00:6936  54 43 50 2F 49 50 00 
    6099   00:693D                      UNAPI_ID_END:
    6100   00:693D                      
    6101   00:693D                      ;--- Implementation name (up to 63 chars and zero terminated)
    6102   00:693D                      
    6103   00:693D                      APIINFO:                db  "MSXPICO Wi-Fi UNAPI",0
    6103   00:693D  4D 53 58 50 49 43 4F 20 57 69 2D 46 69 20 55 4E 
    6103   00:694D  41 50 49 00 
    6104   00:6951                      
    6105   00:6951  C9 (5775)           ID_END: ds  #7FE0-ID_END,#C9
    6106   00:7FE0                      ;--- FS-A1GT compliant BIOS without logo (not for FS-A1ST BIOS)
    6107   00:7FE0                      BUILD_NAME:             db  "[ ESP8266P.ROM ]"
    6107   00:7FE0  5B 20 45 53 50 38 32 36 36 50 2E 52 4F 4D 20 5D 
    6108   00:7FF0                      ;--- Build date to be viewed via Hex Editor (16 bytes)
    6109   00:7FF0                      
    6110   00:7FF0                      BUILD_DATE:             db  "BUILD 2024/09/06"
    6110   00:7FF0  42 55 49 4C 44 20 32 30 32 34 2F 30 39 2F 30 36 
    6111   00:8000                      
    6112   00:8000                      SEG_CODE_END:
    6113   00:8000                      ; Final size must be 16384 bytes

    LABELS
-------------------------------------------------
00:00000000 X VERBOSE_ROM
00:00000001 X USE_MEM_IO
00:0000005F   CHGMOD
00:0000009C   CHSNS
00:0000009F   CHGET
00:000000A2   CHPUT
00:000000C0   BEEP
00:00000141   SNSMAT
00:00000156   KILBUF
00:0000F3B0   LINLEN
00:0000F3DB   CLIKSW
00:0000F3E1   REG2SAV
00:0000F3E3   REG4SAV
00:0000F676   TXTTAB
00:0000F847   ARG
00:0000FB20   HOKVLD
00:0000FC4A   HIMEM
00:0000FCA9   CSRSW
00:0000FCC1   EXPTBL
00:0000FD09   SLTWRK
00:0000FD9F   H_TIMI
00:0000FED0 X H_CLEA
00:0000FFCA   EXTBIO
00:00007F06   MEM_OUT_CMD_PORT
00:00007F07   MEM_OUT_TX_PORT
00:00007F06   MEM_IN_DATA_PORT
00:00007F07   MEM_IN_STS_PORT
00:00007FF2   MEM_PORT_F2
00:00000006 X OUT_CMD_PORT
00:00000007 X OUT_TX_PORT
00:00000006 X IN_DATA_PORT
00:00000007 X IN_STS_PORT
00:000000F2 X PORT_F2
00:00000001   API_V_P
00:00000002   API_V_S
00:00000001   ROM_V_P
00:00000003   ROM_V_S
00:0000001E   HIMEM_RESERVED_SIZE
00:00000000 X H_TIM_BACKUP_OFFSET
00:00000005   MEMORY_COUNTER_OFFSET
00:00000007   MEMORY_SB_VAR_OFFSET
00:00000008   MEMORY_DNS_READY_OFFSET
00:00000009   MEMORY_DNS_RES_OFFSET
00:0000000B   MEMORY_DB_VAR_OFFSET
00:0000000D   MEMORY_REGBACKUP_OFFSET
00:0000000D   MEMORY_BCBACKUP_OFFSET
00:0000000F X MEMORY_DEBACKUP_OFFSET
00:00000011   MEMORY_HLBACKUP_OFFSET
00:00000008   SCAN_MAX_PAGE_SIZE
00:0000001D   MAX_FN
00:00000000 X MAX_IMPFN
00:00000000 X ERR_OK
00:00000001   ERR_NOT_IMP
00:00000002 X ERR_NO_NETWORK
00:00000003 X ERR_NO_DATA
00:00000004   ERR_INV_PARAM
00:00000005 X ERR_QUERY_EXISTS
00:00000006 X ERR_INV_IP
00:00000007 X ERR_NO_DNS
00:00000008   ERR_DNS
00:00000009 X ERR_NO_FREE_CONN
00:0000000A X ERR_CONN_EXISTS
00:0000000B   ERR_NO_CONN
00:0000000C X ERR_CONN_STATE
00:0000000D X ERR_BUFFER
00:0000000E X ERR_LARGE_DGRAM
00:0000000F   ERR_INV_OPER
00:00000000 X UNAPI_TCPIP_NS_CLOSED
00:00000001 X UNAPI_TCPIP_NS_OPENING
00:00000002 X UNAPI_TCPIP_NS_OPEN
00:000000FF X UNAPI_TCPIP_NS_UNKNOWN
00:00004010   INIT
00:00004032   SCREEN_SETUP
00:00004038   IS_SCREEN1
00:00004061   NOT_DISABLED_BY_F2
00:00004078   F2_IS_NOT_F0
00:0000408E   WAIT_2S
00:00004096   BOOT_FROM_POWER_OFF
00:000040B6   F2_IS_PRESSED
00:000040C2   ESP_NOT_FOUND
00:000040CC   INIT_F_MSG
00:000040CF X INIT_F_WAIT
00:000040D1   INIT_F_LOOP_WAIT
00:000040D4 X AND_DONE
00:000040DA   INIT_UNAPI
00:00004107   INIT_UNAPI2
00:00004123   TRY_AGAIN
00:0000413C   STOP_TRYING
00:00004144   WAIT_4S
00:0000414A   INIT_CLOCKUPDATE
00:00004189   INIT_NOCLOCKUPDATE
00:00004193   INIT_NOCLOCKUPDAT2
00:000041A5   SAVE_HOOK2
00:000041B8   PATCH
00:000041CE   PATCH2
00:000041D8 X INIT_OK
00:000041E4   HIMEM_ALLOC
00:00004204 X PATCH_H_TIMI
00:00004221   ESPSETUP.EXIT
00:00004229   ENTERING_ESPSETUP
00:00004245   ESPSETUP
00:00004264   ESPSETUP_NEXT
00:000042A2   ESPSETUP_NEXT.2F
00:000042AE   ESPSETUP_NEXT.1G
00:000042B4   MM_CURSOR_BLINK
00:000042B7   CONN_CHG_LOOP
00:000042CF   MM_WAIT_INPUT
00:000042F5   MM_CURSOR_SW
00:00004309   GET_AP_STAT
00:00004321   CLK_MSX1_GO
00:00004339   CLK_MSX1_ADAPTERDIS
00:0000433F   CLK_MSX1_OPT
00:00004345   CLK_MSX1_WAIT_OPT_INPUT
00:0000435D   CLK_MSX1_SEND_CMD
00:00004372   START_CLK_AUTO
00:00004381 X CLK_AUTO_GO
00:00004398   CLK_AUTO_CHK1
00:000043A3   CLK_AUTO_CHK2
00:000043AE   CLK_AUTO_3
00:000043B6   CLK_AUTO_GMT
00:000043CB   CLK_AUTO_GMTP
00:000043D0   CLK_AUTO_GMTM
00:000043E6   CLK_AUTO_GMTD
00:000043F1   CLK_AUTO_GMT_OPT
00:000043F7   CLK_AUTO_WAIT_OPT_INPUT
00:00004419   CLK_AUTO_WAIT_GMT
00:00004438   CLK_AUTO_WAIT_GMT_INPUT
00:0000445C   CLK_AUTO_GMT_CHK_BS
00:00004467   CLK_AUTO_GMT_CHK_BS_MIN
00:0000446B   CLK_AUTO_GMT_CHK_DIGIT
00:0000447D   CLK_AUTO_GMT_BAD_INPUT
00:0000448B   CLK_AUTO_GMT_CHK_INPUT
00:000044A1   CLK_AUTO_GMT_CHK_CR
00:000044B4   CLK_AUTO_GMT_CHK_CD
00:000044CD   CLK_AUTO_SKIP_SIGN
00:000044D2   CLK_AUTO_GMT_CHK_CD.1
00:000044DB   CLK_AUTO_GMT_CHK_CSD
00:000044F3   CLK_AUTO_GMT_CHK_CSD1
00:00004504   CLK_AUTO_GMT_CHK_CSD2
00:00004510   CLK_AUTO_GMT_CHK_DONE
00:00004550   CLK_AUTO_GMT_CHK_RESULT
00:00004556   START_WIFI_SCAN
00:0000455E   START_WIFI_RESCAN
00:00004572   WIFI_SCAN_WAIT_END
00:0000458D   WIFI_SCAN_WAITHS
00:0000459A   WIFI_SCAN_SHOW_LIST
00:000045A6   WIFI_LIST_LOOP
00:000045BD   PRT_APNAMELP
00:000045D0   PRT_APNAMELP_CUT
00:000045D9   PRT_APENC
00:000045EA   PRT_APNOTENC
00:000045F2   PRT_AP_CHKLOOP
00:00004602   APLIST_OVERFLOW
00:00004612   APLIST_NO_OVERFLOW
00:00004615   APLIST_NOFLW
00:0000461C   WIFI_SELECT_AP
00:0000463A   WIFI_SELECT_SPACEBAR
00:00004647   WIFI_CONNECT_ME_CHOOSEN
00:00004652   WIFI_CONNECT_MANUAL_ENTRY
00:00004673   WIFI_CONNECT_ME_CHKPRT2
00:00004679   WIFI_CONNECT_ME_CHKPRTD
00:0000467F   WIFI_CONNECT_ME_0_TERM
00:0000469B   WIFI_CONNECT_ME_PWD_Y
00:000046A2   WIFI_CONNECT_ME_PWD
00:000046B3   WIFI_CONNECT_ME_BS
00:000046CA   WIFI_ME_CHECK_INPUT
00:000046D1   WIFI_CONNECT_SELECTION_OK
00:000046E5 X WIFI_CONNECT_AP_SRCH
00:000046E7   WIFI_CONNECT_AP_SRCH.1
00:000046F5   WIFI_CONNECT_AP_PWDQ
00:000046FA   WIFI_CONNECT_APSIZE
00:00004715   WIFI_CONNECT_RCV_PWD
00:0000472C   WIFI_CONNECT_RCV_PWD_STR
00:00004747   WIFI_CONNECT_RCV_PWD_CHAR
00:00004750   WIFI_CONNECT_RCV_CHKPRT2
00:00004756   WIFI_CONNECT_RCV_CHKPRTD
00:0000475C   WIFI_CONNECT_RCV_PWDH
00:00004770   WIFI_CONNECT_RCV_PWD_BS
00:0000478D   WIFI_PWD_CHECK_INPUT
00:00004794   WIFI_CONNECT_SENDCMD
00:000047B6   WIFI_CONNECT_SENDCMDLP
00:000047D5   WIFI_CONNECT_FAIL
00:000047DE   INPUT_WFSAP_BAD_INPUT
00:000047F4   WIFI_SCAN_NONETWORKS
00:000047FD   WIFI_SCAN_TIMEOUT
00:00004806   SET_WIFI_TIMEOUT
00:0000482F   WIFI_SET_ALWAYS_ON
00:0000483F   INPUT_TIMEOUT
00:0000486D   INPUT_TIMEOUT_BAD_INPUT
00:00004873   SET_WIFI_BS_INPUT
00:0000488D   SET_WIFI_CHECK_INPUT
00:000048C9   SET_WIFI_EXECUTE_SET_COMMAND
00:000048CC   SET_NAGLE
00:000048E5   SET_NAGLE_WI_ON
00:000048FD   NAGLE_IS_ON
00:00004903   SET_NAGLE_WI_OFF
00:0000491B   SET_ESP_WIFI_TIMEOUT
00:0000495B   SET_NAGLE_OFF
00:0000498C   STARTWIFISCAN
00:000049AA   SET_NAGLE_ON
00:000049DB   WAIT_4S_AND_THEN_MAINMENU
00:000049DF   WAIT_2S_AND_THEN_MAINMENU
00:000049E1   WAIT_AND_THEN_MAINMENU
00:000049E7   WAIT_250MS_AND_THEN_CONTINUE
00:000049E9   WAIT_BEFORE_CONTINUING
00:000049EE   ISCLKAUTO
00:00004A0A   CHECKNAGLE
00:00004A3F   CHECK_NAGLE_OFF
00:00004A58   CHECKTIMEOUT
00:00004A8A   CHECKTIMEOUT.1
00:00004A9B   CHECKTIMEOUT.2
00:00004AC1   CHECKTIMEOUT.3
00:00004AFA   CHECKTIMEOUT.END
00:00004AFE   MENU_SUB_BAD_END_1S
00:00004AFF   MENU_SUB_BAD_END
00:00004B00   MENU_BAD_END
00:00004B09   WAIT_MENU_QCMD_RESPONSE
00:00004B0B   WAIT_MENU_QCMD_RESPONSE_ST1
00:00004B1F   WAIT_MENU_QCMD_RESPONSE_ST1.1
00:00004B25   WAIT_MENU_QCMD_RESPONSE_RC
00:00004B34   WAIT_MENU_QCMD_RESPONSE_RC.1
00:00004B3B X WAIT_MENU_QCMD_RESPONSE_END_OK
00:00004B3E   WAIT_MENU_QCMD_RESPONSE_END
00:00004B40   WAIT_MENU_QCMD_RESPONSE_END_NOK
00:00004B46   WAIT_MENU_CMD_RESPONSE
00:00004B4A   WAIT_MENU_CMD_RESPONSE_ST1
00:00004B5E   WAIT_MENU_CMD_RESPONSE_ST1.1
00:00004B64   WAIT_MENU_CMD_RESPONSE_RC
00:00004B73   WAIT_MENU_CMD_RESPONSE_RC.1
00:00004B7A   WAIT_MENU_CMD_RESPONSE_ST2A
00:00004B89   WAIT_MENU_CMD_RESPONSE_ST2A.1
00:00004B8D   WAIT_MENU_CMD_RESPONSE_ST2B
00:00004B9C   WAIT_MENU_CMD_RESPONSE_ST2B.1
00:00004BA5   WAIT_MENU_CMD_RESPONSE_GET_DATA
00:00004BB4   WAIT_MENU_CMD_RESPONSE_GET_DATA.1
00:00004BC1   WAIT_MENU_CMD_RESPONSE_END_OK
00:00004BC8   WAIT_MENU_CMD_RESPONSE_END
00:00004BCE   WAIT_MENU_CMD_RESPONSE_END_NOK
00:00004BD7   WAIT_MENU_SCMD_RESPONSE
00:00004BDB   WAIT_MENU_SCMD_RESPONSE_ST1
00:00004BEF   WAIT_MENU_SCMD_RESPONSE_ST1.1
00:00004BF5   WAIT_MENU_SCMD_RESPONSE_RC
00:00004C04   WAIT_MENU_SCMD_RESPONSE_RC.1
00:00004C0B   WAIT_MENU_SCMD_RESPONSE_ST2A
00:00004C1A   WAIT_MENU_SCMD_RESPONSE_ST2A.1
00:00004C1F   WAIT_MENU_SCMD_RESPONSE_ST2B
00:00004C2E   WAIT_MENU_SCMD_RESPONSE_ST2B.1
00:00004C39   WAIT_MENU_SCMD_RESPONSE_GET_ENC
00:00004C48   WAIT_MENU_SCMD_RESPONSE_GET_ENC.1
00:00004C57 X WAIT_MENU_SCMD_RESPONSE_END_OK
00:00004C5B   WAIT_MENU_SCMD_RESPONSE_END
00:00004C5F   WAIT_MENU_SCMD_RESPONSE_END_NOK
00:00004C68   HLTIMEOUT
00:00004C6E   PRINTHL
00:00004C78   PRINTHLINE
00:00004C7B   PHLINEL
00:00004C9E   PHLINESPC
00:00004CA5   PHLINELR
00:00004CAF   DO_HTIMI
00:00004CBB   DO_HTIMI_END
00:00004CC3   DO_EXTBIO
00:00004CD4   LOOP
00:00004CF6   DO_EXTBIO2
00:00004D06   DO_EXTBIO3
00:00004D0B   JUMP_OLD2
00:00004D0E   JUMP_OLD
00:00004D1A   UNAPI_ENTRY
00:00004D2A   OK_FNUM
00:00004D38   UNDEFINED
00:00004D3B   FN_TABLE
00:00004D3B X FN_0
00:00004D3D X FN_1
00:00004D3F X FN_2
00:00004D41 X FN_3
00:00004D43 X FN_4
00:00004D45 X FN_5
00:00004D47 X FN_6
00:00004D49 X FN_7
00:00004D4B X FN_8
00:00004D4D X FN_9
00:00004D4F X FN_10
00:00004D51 X FN_11
00:00004D53 X FN_12
00:00004D55 X FN_13
00:00004D57 X FN_14
00:00004D59 X FN_15
00:00004D5B X FN_16
00:00004D5D X FN_17
00:00004D5F X FN_18
00:00004D61 X FN_19
00:00004D63 X FN_20
00:00004D65 X FN_21
00:00004D67 X FN_22
00:00004D69 X FN_23
00:00004D6B X FN_24
00:00004D6D X FN_25
00:00004D6F X FN_26
00:00004D71 X FN_27
00:00004D73 X FN_28
00:00004D75 X FN_29
00:00004D77   FN_NOT_IMP
00:00004D7A   END_OK
00:00004D7C   TCPIP_GENERIC_CHECK_TIME_OUT
00:00004D8C   UNAPI_GET_INFO
00:00004D97   TCPIP_GET_CAPAB
00:00004DAF   TCPIP_GET_CAPAB_ST1
00:00004DBB   TCPIP_GET_CAPAB_ST1.1
00:00004DC2   TCPIP_GET_CAPAB_RC
00:00004DCE   TCPIP_GET_CAPAB_RC.1
00:00004DD5   TCPIP_GET_CAPAB_ST2
00:00004DE1   TCPIP_GET_CAPAB_ST2.1
00:00004DF9   TCPIP_GET_CAPAB_BLK3
00:00004DF9   TCPIP_GET_CAPAB_BLK3_ST1
00:00004E05   TCPIP_GET_CAPAB_BLK3_ST1.1
00:00004E09   TCPIP_GET_CAPAB_BLK3_ST2
00:00004E15   TCPIP_GET_CAPAB_BLK3_ST2.1
00:00004E19   TCPIP_GET_CAPAB_BLK3_ST3
00:00004E25   TCPIP_GET_CAPAB_BLK3_ST3.1
00:00004E29   TCPIP_GET_CAPAB_BLK3_ST4
00:00004E35   TCPIP_GET_CAPAB_BLK3_ST4.1
00:00004E3B   TCPIP_GET_CAPAB_BLK2
00:00004E3B   TCPIP_GET_CAPAB_BLK2_ST1
00:00004E47   TCPIP_GET_CAPAB_BLK2_ST1.1
00:00004E4B   TCPIP_GET_CAPAB_BLK2_ST2
00:00004E57   TCPIP_GET_CAPAB_BLK2_ST2.1
00:00004E5B   TCPIP_GET_CAPAB_BLK2_ST3
00:00004E67   TCPIP_GET_CAPAB_BLK2_ST3.1
00:00004E6B   TCPIP_GET_CAPAB_BLK2_ST4
00:00004E77   TCPIP_GET_CAPAB_BLK2_ST4.1
00:00004E7B   TCPIP_GET_CAPAB_BLK2_ST5
00:00004E87   TCPIP_GET_CAPAB_BLK2_ST5.1
00:00004E8B   TCPIP_GET_CAPAB_BLK2_ST6
00:00004E97   TCPIP_GET_CAPAB_BLK2_ST6.1
00:00004E9D   TCPIP_GET_CAPAB_BLK1
00:00004E9D   TCPIP_GET_CAPAB_BLK1_ST1
00:00004EA9   TCPIP_GET_CAPAB_BLK1_ST1.1
00:00004EAD   TCPIP_GET_CAPAB_BLK1_ST2
00:00004EB9   TCPIP_GET_CAPAB_BLK1_ST2.1
00:00004EBD   TCPIP_GET_CAPAB_BLK1_ST3
00:00004EC9   TCPIP_GET_CAPAB_BLK1_ST3.1
00:00004ECD   TCPIP_GET_CAPAB_BLK1_ST4
00:00004ED9   TCPIP_GET_CAPAB_BLK1_ST4.1
00:00004EDD   TCPIP_GET_CAPAB_BLK1_ST5
00:00004EE9   TCPIP_GET_CAPAB_BLK1_ST5.1
00:00004EEF   TCPIP_GET_IPINFO
00:00004F04   TCPIP_GET_IPINFO_ST1
00:00004F10   TCPIP_GET_IPINFO_ST1.1
00:00004F17   TCPIP_GET_IPINFO_RC
00:00004F23   TCPIP_GET_IPINFO_RC.1
00:00004F2A   TCPIP_GET_IPINFO_ST2
00:00004F36   TCPIP_GET_IPINFO_ST2.1
00:00004F3C   TCPIP_GET_IPINFO_IP_ST1
00:00004F48   TCPIP_GET_IPINFO_IP_ST1.1
00:00004F4C   TCPIP_GET_IPINFO_IP_ST2
00:00004F58   TCPIP_GET_IPINFO_IP_ST2.1
00:00004F5C   TCPIP_GET_IPINFO_IP_ST3
00:00004F68   TCPIP_GET_IPINFO_IP_ST3.1
00:00004F6C   TCPIP_GET_IPINFO_IP_ST4
00:00004F78   TCPIP_GET_IPINFO_IP_ST4.1
00:00004F7E   TCPIP_NET_STATE
00:00004F8E   TCPIP_NET_STATE_ST1
00:00004F9A   TCPIP_NET_STATE_ST1.1
00:00004FA1   TCPIP_NET_STATE_RC
00:00004FAD   TCPIP_NET_STATE_RC.1
00:00004FB4   TCPIP_NET_STATE_ST2
00:00004FC0   TCPIP_NET_STATE_ST2.1
00:00004FC6   TCPIP_NET_STATE_NS_ST1
00:00004FD2   TCPIP_NET_STATE_NS_ST1.1
00:00004FD8   TCPIP_DNS_Q
00:00004FDC   TCPIP_DNS_Q_SIZE_LOOP
00:00004FE5   TCPIP_DNS_Q_SEND
00:00005002   TCPIP_DNS_Q_SENDLP
00:0000500D   TCPIP_DNS_Q_WAIT_RSP
00:00005013   TCPIP_DNSQ_SEND_ST1
00:0000501F   TCPIP_DNSQ_SEND_ST1.1
00:00005026   TCPIP_DNSQ_SEND_RC
00:00005032   TCPIP_DNSQ_SEND_RC.1
00:0000503B   TCPIP_DNSQ_SEND_RC_ST2
00:00005047   TCPIP_DNSQ_SEND_RC_ST2.1
00:0000504D   TCPIP_DNSQ_IP_ST1
00:00005059   TCPIP_DNSQ_IP_ST1.1
00:0000505D   TCPIP_DNSQ_IP_ST2
00:00005069   TCPIP_DNSQ_IP_ST2.1
00:0000506D   TCPIP_DNSQ_IP_ST3
00:00005079   TCPIP_DNSQ_IP_ST3.1
00:0000507D   TCPIP_DNSQ_IP_ST4
00:00005089   TCPIP_DNSQ_IP_ST4.1
00:00005099   TCPIP_DNS_S
00:000050AF   TCP_IP_DNS_S_NOCLR
00:000050B4   TCPIP_DNS_S_HASRESULT
00:000050BF   TCP_IP_DNS_S_RES_NOCLR
00:000050C2   TCPIP_DNS_S_NORESULT
00:000050C6   TCPIP_UDP_OPEN
00:000050E4   TCPIP_UDP_OPEN_ST1
00:000050F0   TCPIP_UDP_OPEN_ST1.1
00:000050F7   TCPIP_UDP_OPEN_RC
00:00005103   TCPIP_UDP_OPEN_RC.1
00:0000510A   TCPIP_UDP_OPEN_ST2
00:00005116   TCPIP_UDP_OPEN_ST2.1
00:0000511C   TCPIP_UDP_OPEN_CONN_ST1
00:00005128   TCPIP_UDP_OPEN_CONN_ST1.1
00:0000512E   TCPIP_UDP_CLOSE
00:00005144   TCPIP_UDP_CLOSE_ST1
00:00005150   TCPIP_UDP_CLOSE_ST1.1
00:00005157   TCPIP_UDP_CLOSE_RC
00:00005163   TCPIP_UDP_CLOSE_RC.1
00:0000516A   TCPIP_UDP_CLOSE_ST2
00:00005176   TCPIP_UDP_CLOSE_ST2.1
00:0000517E   TCPIP_UDP_STATE
00:00005193   TCPIP_UDP_STATE_ST1
00:0000519F   TCPIP_UDP_STATE_ST1.1
00:000051A6   TCPIP_UDP_STATE_RC
00:000051B2   TCPIP_UDP_STATE_RC.1
00:000051B9   TCPIP_UDP_STATE_ST2
00:000051C5   TCPIP_UDP_STATE_ST2.1
00:000051CB   TCPIP_UDP_STATE_RESP_ST1
00:000051D7   TCPIP_UDP_STATE_RESP_ST1.1
00:000051DB   TCPIP_UDP_STATE_RESP_ST2
00:000051E7   TCPIP_UDP_STATE_RESP_ST2.1
00:000051EB   TCPIP_UDP_STATE_RESP_ST3
00:000051F7   TCPIP_UDP_STATE_RESP_ST3.1
00:000051FB   TCPIP_UDP_STATE_RESP_ST4
00:00005207   TCPIP_UDP_STATE_RESP_ST4.1
00:0000520B   TCPIP_UDP_STATE_RESP_ST5
00:00005217   TCPIP_UDP_STATE_RESP_ST5.1
00:0000521D   TCPIP_UDP_SEND
00:00005264   TCPIP_UDP_SEND_R
00:00005274   TCPIP_UDP_SEND_ST1
00:00005280   TCPIP_UDP_SEND_ST1.1
00:00005287   TCPIP_UDP_SEND_RC
00:00005293   TCPIP_UDP_SEND_RC.1
00:0000529A   TCPIP_UDP_SEND_ST2
00:000052A6   TCPIP_UDP_SEND_ST2.1
00:000052AE   TCPIP_UDP_RCV_CHECK_TIME_OUT
00:000052BB   TCPIP_TCP_UDP_RETRY_QRCV
00:000052CD   TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY
00:000052D0   TCPIP_UDP_RCV
00:000052F2   TCPIP_UDP_RCV.RXRETRY
00:000052F8   TCPIP_UDP_RCV_ST1
00:00005304   TCPIP_UDP_RCV_ST1.1
00:00005313   TCPIP_UDP_RCV_RC
00:0000531F   TCPIP_UDP_RCV_RC.1
00:00005324   TCPIP_UDP_RCV_ST2A
00:00005330   TCPIP_UDP_RCV_ST2A.1
00:00005334   TCPIP_UDP_RCV_ST2B
00:00005340   TCPIP_UDP_RCV_ST2B.1
00:0000534C   TCPIP_UDP_RCV_IP_ST1
00:00005358   TCPIP_UDP_RCV_IP_ST1.1
00:0000535C   TCPIP_UDP_RCV_IP_ST2
00:00005368   TCPIP_UDP_RCV_IP_ST2.1
00:0000536C   TCPIP_UDP_RCV_IP_ST3
00:00005378   TCPIP_UDP_RCV_IP_ST3.1
00:0000537C   TCPIP_UDP_RCV_IP_ST4
00:00005388   TCPIP_UDP_RCV_IP_ST4.1
00:0000538C   TCPIP_UDP_RCV_PORT_ST1
00:00005398   TCPIP_UDP_RCV_PORT_ST1.1
00:0000539D   TCPIP_UDP_RCV_PORT_ST2
00:000053A9   TCPIP_UDP_RCV_PORT_ST2.1
00:000053B9   TCPIP_UDP_RCV_R
00:000053D0   TCPIP_TCP_OPEN_ERROR
00:000053D3   TCPIP_TCP_OPEN_ERROR2
00:000053DF   TCPIP_TCP_OPEN_ERROR2.1
00:000053EA   TCPIP_TCP_OPEN_ERROR3
00:000053F6   TCPIP_TCP_OPEN_ERROR3.1
00:000053FA   TCPIP_TCP_OPEN_ERROR4
00:000053FE   TCPIP_TCP_OPEN
00:0000542A   TCPIP_TCP_OPEN_CHECK_HOSTOF
00:00005431 X TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME
00:00005441   TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME_LOOP_PARAM
00:00005454   TCPIP_TCP_OPEN_SENDHOSTNAME
00:00005461   TCPIP_TCP_OPEN_NO_TLS
00:00005461   TCPIP_TCP_OPEN_NO_CHECKHOST
00:00005477   TCPIP_TCP_OPEN_R
00:00005481   TCPIP_TCP_OPEN_WAIT_RESPONSE
00:00005487   TCPIP_TCP_OPEN_ST1
00:00005493   TCPIP_TCP_OPEN_ST1.1
00:0000549A   TCPIP_TCP_OPEN_RC
00:000054A6   TCPIP_TCP_OPEN_RC.1
00:000054AF   TCPIP_TCP_OPEN_ST2
00:000054BB   TCPIP_TCP_OPEN_ST2.1
00:000054C1   TCPIP_TCP_OPEN_CONN_ST1
00:000054CD   TCPIP_TCP_OPEN_CONN_ST1.1
00:000054D3   TCPIP_TCP_CLOSE
00:000054E9   TCPIP_TCP_CLOSE_ST1
00:000054F5   TCPIP_TCP_CLOSE_ST1.1
00:000054FC   TCPIP_TCP_CLOSE_RC
00:00005508   TCPIP_TCP_CLOSE_RC.1
00:0000550F   TCPIP_TCP_CLOSE_ST2
00:0000551B   TCPIP_TCP_CLOSE_ST2.1
00:00005523   TCPIP_TCP_ABORT
00:00005539   TCPIP_TCP_ABORT_ST1
00:00005545   TCPIP_TCP_ABORT_ST1.1
00:0000554C   TCPIP_TCP_ABORT_RC
00:00005558   TCPIP_TCP_ABORT_RC.1
00:0000555F   TCPIP_TCP_ABORT_ST2
00:0000556B   TCPIP_TCP_ABORT_ST2.1
00:00005573   TCPIP_TCP_STATE_ERROR
00:00005576   TCPIP_TCP_STATE_ERROR2
00:00005582   TCPIP_TCP_STATE_ERROR2.1
00:00005598   TCPIP_TCP_STATE
00:000055A2   TCPIP_TCP_STATE_NOINFOBLOCK
00:000055BC   TCPIP_TCP_STATE_ST1
00:000055C8   TCPIP_TCP_STATE_ST1.1
00:000055CF   TCPIP_TCP_STATE_RC
00:000055DB   TCPIP_TCP_STATE_RC.1
00:000055E3   TCPIP_TCP_STATE_ST2
00:000055EF   TCPIP_TCP_STATE_ST2.1
00:000055F5   TCPIP_TCP_STATE_RESP_ST1
00:00005601   TCPIP_TCP_STATE_RESP_ST1.1
00:00005605   TCPIP_TCP_STATE_RESP_ST2
00:00005611   TCPIP_TCP_STATE_RESP_ST2.1
00:00005615   TCPIP_TCP_STATE_RESP_ST3
00:00005621   TCPIP_TCP_STATE_RESP_ST3.1
00:00005625   TCPIP_TCP_STATE_RESP_ST4
00:00005631   TCPIP_TCP_STATE_RESP_ST4.1
00:00005635   TCPIP_TCP_STATE_RESP_ST5
00:00005641   TCPIP_TCP_STATE_RESP_ST5.1
00:00005645   TCPIP_TCP_STATE_RESP_ST6
00:00005651   TCPIP_TCP_STATE_RESP_ST6.1
00:00005655   TCPIP_TCP_STATE_RESP_ST7
00:00005661   TCPIP_TCP_STATE_RESP_ST7.1
00:00005666   TCPIP_TCP_STATE_RESP_ST8
00:00005672   TCPIP_TCP_STATE_RESP_ST8.1
00:00005682   TCPIP_TCP_STATE_DISCARD_IBLOCK
00:0000568E   TCPIP_TCP_STATE_DISCARD_IBLOCK.1
00:00005699   TCPIP_TCP_STATE_GET_IBLOCK
00:0000569F   TCPIP_TCP_STATE_SAVE_IBLOCK
00:000056AB   TCPIP_TCP_STATE_SAVE_IBLOCK.1
00:000056BB X TCPIP_TCP_SEND_ERROR
00:000056BE   TCPIP_TCP_SEND_ERROR2
00:000056CA   TCPIP_TCP_SEND_ERROR2.1
00:000056D2   TCPIP_TCP_SEND
00:000056F0   TCPIP_TCP_SEND_R
00:00005700   TCPIP_TCP_SEND_ST1
00:0000570C   TCPIP_TCP_SEND_R.1
00:00005713   TCPIP_TCP_SEND_RC
00:0000571F   TCPIP_TCP_SEND_RC.1
00:00005726   TCPIP_TCP_SEND_ST2
00:00005732   TCPIP_TCP_SEND_ST2.1
00:0000573A   TCPIP_TCP_RCV_CHECK_TIME_OUT
00:00005747   TCPIP_TCP_RCV_RETRY_QRCV
00:00005759   TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY
00:0000575C   TCPIP_TCP_RCV_RET_ERR
00:0000575F   TCPIP_TCP_RCV_RET_ERR2
00:0000576B   TCPIP_TCP_RCV_RET_ERR2.1
00:00005772   TCPIP_TCP_RCV_RET_NODATA
00:00005779   TCPIP_TCP_RCV
00:0000579D   TCPIP_TCP_RCV.RXRETRY
00:000057A3   TCPIP_TCP_RCV_ST1
00:000057AF   TCPIP_TCP_RCV_ST1.1
00:000057BE   TCPIP_TCP_RCV_RC
00:000057CA   TCPIP_TCP_RCV_RC.1
00:000057D0   TCPIP_TCP_RCV_ST2A
00:000057DC   TCPIP_TCP_RCV_ST2A.1
00:000057E0   TCPIP_TCP_RCV_ST2B
00:000057EC   TCPIP_TCP_RCV_ST2B.1
00:000057FB   TCPIP_TCP_RCV_UDC_ST1
00:00005807   TCPIP_TCP_RCV_UDC_ST1.1
00:0000580A   TCPIP_TCP_RCV_UDC_ST2
00:00005816   TCPIP_TCP_RCV_UDC_ST2.1
00:00005823   TCPIP_TCP_RCV_R
00:0000583D   TCPIP_CONFIG_AUTOIP
00:00005857   TCPIP_CONFIG_AUTOIP_ST1
00:00005863   TCPIP_CONFIG_AUTOIP_ST1.1
00:0000586A   TCPIP_CONFIG_AUTOIP_RC
00:00005876   TCPIP_CONFIG_AUTOIP_RC.1
00:0000587D   TCPIP_CONFIG_AUTOIP_ST2
00:00005889   TCPIP_CONFIG_AUTOIP_ST2.1
00:0000588F   TCPIP_CONFIG_AUTOIP_CONF_ST1
00:0000589B   TCPIP_CONFIG_AUTOIP_CONF_ST1.1
00:000058A1   TCPIP_CONFIG_IP
00:000058C7   TCPIP_CONFIG_IP_ST1
00:000058D3   TCPIP_CONFIG_IP_ST1.1
00:000058DA   TCPIP_CONFIG_IP_RC
00:000058E6   TCPIP_CONFIG_IP_RC.1
00:000058EA   TCPIP_CONFIG_TTL
00:000058FC   TCPIP_CONFIG_PING
00:0000590C   GETSLT
00:0000592C   GETSLTT
00:0000594D   GETSLTT1
00:00005961   GETSLTTRET
00:00005965   GETWRK
00:00005979   GETMEMPOINTERADDR
00:0000598C   GETMEM_1
00:00005995   GETMEMPOINTER
00:0000599D   GETCOUNTER
00:000059AC   SETCOUNTER
00:000059BC   GETBYTE
00:000059CE   SETBYTE
00:000059E2   GETWORD
00:000059F5   SETWORD
00:00005A0A   REGRESTORE
00:00005A21   REGBACKUP
00:00005A43   BCRESTORE
00:00005A55   BCBACKUP
00:00005A69   HLRESTORE
00:00005A7C   HLBACKUP
00:00005A91   GETDNSREADY
00:00005AA3   SETDNSREADY
00:00005AB7   GETDNSRESULT
00:00005ACD   SETDNSRESULT
00:00005AE7   TOUPPER
00:00005AF0   WRFE_WAIT_DATA
00:00005AFD   WRFE_STS_NOT_AVAILABLE
00:00005B02   WRFE_COMPARE
00:00005B08   WAIT_RESPONSE_FROM_ESP
00:00005B0B X WRFE_ST1
00:00005B0D   WRFE_LOOP
00:00005B19   WRFE_LOOP.1
00:00005B1C X WRFE_IDXCMD
00:00005B28   WRFE_RSP_MATCH
00:00005B31   WRFE_RET_OK
00:00005B34   WRFE_RET_ERROR
00:00005B38   RESET_ESP
00:00005B55   RESET_ESP_INIT
00:00005B57   RESET_ESP_LOOP
00:00005B78 X RESET_CHK_IF_INSTALLED
00:00005B7B   SET_TIME
00:00005B92   SET_TIME_ERR
00:00005B95   SET_RTC_TIME
00:00005BA8   SET_DATE
00:00005BC6   SET_DATE1
00:00005BD3   SET_DATE2
00:00005BE0   SET_DATE_ERR
00:00005BE3   DAYS_IN_MONTH
00:00005BEF   DAYS_IN_FEBRUARY_LEAP
00:00005BF0   STOP_RTC_COUNT_SET_MODE0
00:00005BFB   RTC_SAVE_REGISTERPAIR
00:00005BFF   RTC_SAVE_REGISTERPAIR.1
00:00005C0C   SET_RTC_REG
00:00005C15   SET_RTC_DATE
00:00005C2B   SET_RTC_DATE.1
00:00005C42   PATTERN_SETUP
00:00005C50   OUTI_TO_VRAM_TMS9918
00:00005C56   PATTERN_DATA
00:00005CB6   SET_VDP_WRITE
00:00000052 X CMD_RESET_ESP
00:00000057   CMD_WRESET_ESP
00:00000048   CMD_WIFIHOLD_ESP
00:00000068   CMD_WIFIRELEASE_ESP
00:00000047   CMD_GET_TIME
00:00000063   CMD_QUERY_ACLK_SETTINGS
00:00000043   CMD_SET_ACLK_SETTINGS
00:00000051   CMD_QUERY_ESP_SETTINGS
00:00000054   CMD_TIMER_SET
00:00000044   CMD_NAGLE_ON
00:0000004E   CMD_NAGLE_OFF
00:0000004F   CMD_WIFI_OFF
00:00000041   CMD_WIFI_CONNECT
00:00000053   CMD_SCAN_START
00:00000073   CMD_SCAN_RESULTS
00:00000067   CMD_AP_STS
00:00000056 X CMD_GET_ESP_VER
00:00005CD2   RSP_CMD_RESET_ESP
00:00000005   RSP_CMD_RESET_ESP_SIZE
00:0000003F   CMD_QUERY_ESP
00:00005CD7   RSP_CMD_QUERY_ESP
00:00000002   RSP_CMD_QUERY_ESP_SIZE
00:00000000   STTERMINATOR
00:0000000A   LF
00:0000000B   HOME
00:0000000C   CLS
00:0000000D   CR
00:0000001C   GORIGHT
00:0000001D   GOLEFT
00:00005CD9   ENTERING_WIFI_SETUP
00:00005CF5   WELCOME
00:00005D43   WELCOME_SF
00:00005D5F   WELCOME_CS
00:00005D89   WELCOME_NEXT
00:00005D8F X WELCOME_S_NEXT
00:00005D93   WELCOME_SF_NEXT
00:00005D96   WELCOME_CS0_NEXT
00:00005DC0   WELCOME_CS1_NEXT
00:00005DC9   WELCOME_CS2_NEXT
00:00005DF3   WELCOME_CS3_NEXT
00:00005E1D   WELCOME_CS4_NEXT
00:00005E47   WELCOME_CS5_NEXT
00:00005E71   MMENU_S_NEXT
00:00005F00   MMENU_CLOCK_MSX2
00:00006060   MMENU_CLOCK_MSX1
00:000060F4   MMENU_CLOCK_0
00:00006106   MMENU_CLOCK_1
00:00006120   MMENU_CLOCK_2
00:0000613A   MMENU_CLOCK_3
00:0000614D   MMENU_CLOCK_OPT
00:00006177   MMENU_GMT_OPT
00:00006190   MMENU_MANUALENTRY
00:000061F1   MENU_MANUALENTRY_PWD
00:0000620C   MMENU_SCAN
00:0000625A   MMENU_SCANF
00:0000627A   MMENU_SCANN
00:00006291   MMENU_SCANS
00:000062C7   MMENU_CONNECTING
00:0000630B   MMENU_ASKPWD
00:0000634E   MMENU_SCANQ
00:000063B9   MMENU_SCANQM
00:00006428   SCAN_TERMINATOR_CUT
00:0000642F   SCAN_TERMINATOR_OPEN
00:00006436   SCAN_TERMINATOR_ENC
00:0000643D   MMENU_TIMEOUT
00:0000651F   MMENU_TIMEOUT_ALWAYSON
00:00006574   MMENU_TIMEOUT_NOTALWAYSON1
00:0000658A   MMENU_TIMEOUT_NOTALWAYSON2
00:000065C2   MMENU_NAGLE
00:000066B7   MMENU_NAGLE_ON
00:000066F7   MMENU_NAGLE_OFF
00:00006738   STR_SENDING
00:00006753   STR_SENDING_OK
00:0000676C   STR_SENDING_OK_JN
00:0000678E   STR_SENDING_NOK_JN
00:000067D0   STR_SENDING_FAIL
00:000067E5   STR_CLKUPDT_FAIL
00:00006853   OK_S
00:0000686E   FAIL_S
00:000068BC   FAIL_F
00:000068DB   STR_WAITING
00:000068FB   STR_OOPS
00:00006936   UNAPI_ID
00:0000693D X UNAPI_ID_END
00:0000693D   APIINFO
00:00006951   ID_END
00:00007FE0 X BUILD_NAME
00:00007FF0 X BUILD_DATE
00:00008000 X SEG_CODE_END


 Output: ESP8266P.rom
-------------------------------------------------

 Page: 00
  Org: 00004000  Size: *  Used: 00004000

   Address   Length Align   Label
   00004000   16384         INIT
